@@onCampaignLoad
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=1 ; color=yellow ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip= ; minWidth=90 ; 
[H:'
<!-- ---------------------------------------------------------------------------------------------------------------------------------- -->
<!-- ----------------------------------------------------------------------------- ----ONCAMPAIGNLOAD LIB:ONTOKENMOVE ----------------- -->
<!-- ---------------------------------------------------------------------------------------------------------------------------------- -->']

[h: info		= getInfo("client")]
[h: assert(json.type(info)== "OBJECT", "MAKE SURE THAT THE LIB TOKENS ARE ON THE TOKEN LAYER. After that, save and reload the campaign file.",0)]
[h: libs		= json.get(info, "library tokens")]
[h: botVersion	= json.get(libs, "lib:OnTokenMove")]
[h: assert(listContains(json.fields(libs), "Lib:EventMacros"), "Lib:EventMacros not found! Make sure that its in the campaign file, and then save and reload the campaign file",0)]
[h: mtVersion	= json.get(info, "version")]
[h: mtVersionNr	= substring(mtVersion, indexOf(mtVersion,"b")+1,indexOf(mtVersion,"b")+3)]
[h: thisLib		= getMacroLocation()]

[h:'<!-- initialize new settings -->']
[h,if(getLibProperty('maxGroupSelect','lib:EventMacros') == ""):	setLibProperty("maxGroupSelect", 500,"lib:EventMacros")]
[h,if(getLibProperty('maxOrderSelect','lib:EventMacros') == ""):	setLibProperty("maxOrderSelect", 300,"lib:EventMacros")]
[h,if(getLibProperty('linkedMappedPads','lib:EventMacros') == ""):	setLibProperty("linkedMappedPads", '{}',"lib:EventMacros")]
[h,if(getLibProperty('libCoordSize','lib:EventMacros') == ""):		setLibProperty("libCoordSize", 30,"lib:EventMacros")]
[h,if(getLibProperty('padNameList','lib:EventMacros') == ""):		setLibProperty("padNameList", "Ward, Linked, EventPad , ShadowPad, PadStart , PadEnd , InterPad , PadStartBorder , PadEndBorder , InterPadBorder , PadJump , PadDrop , InterJump , InterDrop , PadJumpBorder , PadDropBorder , InterJumpBorder , InterDropBorder , MappedPad , Roof, Foliage , Canopy","lib:EventMacros")]

[h:'<!-- defineFunction(function, macro, ignoreOutput, newScope) -->']
[h:prefix = "bot_"]

[h:'<!-- macro frame  macros -->']
[h:defineFunction(prefix+"MacroButtonsOTMSetup", "MacroButtonsOTMSetup@"+thisLib) ]
[h:defineFunction(prefix+"MacroButtonsOTMUtils", "MacroButtonsOTMUtils@"+thisLib) ]
[h:defineFunction(prefix+"createMacroButtonsOTMSetup", "createMacroButtonsOTMSetup@"+thisLib ) ]
[h:defineFunction(prefix+"createMacroButtonsOTMUtils", "createMacroButtonsOTMUtils@"+thisLib ) ]
[h:defineFunction(prefix+"MacroButtonsGroupMove", "MacroButtonsGroupMove@"+thisLib) ]
[h:defineFunction(prefix+"createMacroButtonsGroupMove", "createMacroButtonsGroupMove@"+thisLib) ]
[h:defineFunction(prefix+"HTMLMacroButton", "HTMLMacroButton@"+thisLib) ]
[h:defineFunction(prefix+"HTMLMacroImageButton", "HTMLMacroImageButton@"+thisLib) ]

[h:'<!--onTokenMove macros-->']
[h:defineFunction(prefix+"initializePads", "initializePads@"+thisLib, 0, 1 ) ]
[h:defineFunction(prefix+"initializeMap", "initializeMap@"+thisLib, 0, 0) ]
[h:defineFunction(prefix+"checkInterPads", "checkInterPads@"+thisLib, 0, 0 ) ]
[h:defineFunction(prefix+"altInitMap", "altInitMap@"+thisLib, 0, 0 ) ]
[h:defineFunction(prefix+"path2pads", "path2pads@"+thisLib, 1, 0 ) ]
[h:defineFunction(prefix+"chkMoveStop", "chkMoveStop@"+thisLib, 0, 0 ) ]
[h:defineFunction(prefix+"determineTokSize", "determineTokSize@"+thisLib, 0, 0 ) ]
[h:defineFunction(prefix+"moveVBLToken", "moveVBLToken@"+thisLib, 1, 0 ) ]

[h:'<!--Pad Macros-->']
[h:defineFunction(prefix+"Canopy", "Canopy@"+thisLib, 0, 0 ) ]
[h:defineFunction(prefix+"PadStart", "PadStart@"+thisLib, 0, 0 ) ]
[h:defineFunction(prefix+"PadEnd", "PadEnd@"+thisLib, 0, 0 ) ]
[h:defineFunction(prefix+"PadStartBorder", "PadStartBorder@"+thisLib, 0, 0 ) ]
[h:defineFunction(prefix+"PadEndBorder", "PadEndBorder@"+thisLib, 0, 0 ) ]
[h:defineFunction(prefix+"PadJump", "PadJump@"+thisLib, 0, 0 ) ]
[h:defineFunction(prefix+"PadJumpBorder", "PadJumpBorder@"+thisLib, 0, 0 ) ]
[h:defineFunction(prefix+"InterPad", "InterPad@"+thisLib, 0, 0 ) ]
[h:defineFunction(prefix+"InterPadBorder", "InterPadBorder@"+thisLib, 0, 0 ) ]
[h:defineFunction(prefix+"InterJump", "InterJump@"+thisLib, 0, 0 ) ]
[h:defineFunction(prefix+"InterJumpBorder", "InterJumpBorder@"+thisLib, 0, 0 ) ]
[h:defineFunction(prefix+"MappedPad", "MappedPad@"+thisLib, 0, 0 ) ]
[h:defineFunction(prefix+"Ward", "Ward@"+thisLib, 0, 0 ) ]
[h:defineFunction(prefix+"Roof", "Roof@"+thisLib, 0, 0 ) ]
[h:defineFunction(prefix+"Foliage", "Foliage@"+thisLib, 0, 0 ) ]
[h:defineFunction(prefix+"EventPad", "EventPad@"+thisLib, 0, 0 ) ]
[h:defineFunction(prefix+"EventArea", "EventArea@"+thisLib, 1, 0 ) ]
[h:defineFunction(prefix+"ShadowPad", "ShadowPad@"+thisLib, 1, 0 ) ]
[h:defineFunction(prefix+"Linked", "Linked@"+thisLib, 1, 0 ) ]

[h:'<!--shadowPads-->']
[h:defineFunction(prefix+"doShadowPad", "doShadowPad@"+thisLib, 1, 0 ) ]
[h:defineFunction(prefix+"setReference", "setReference@"+thisLib, 1, 0 ) ]
[h:defineFunction(prefix+"shadowCoords", "shadowCoords@"+thisLib, 1, 0 ) ]
[h:defineFunction(prefix+"removeShadow", "removeShadow@"+thisLib, 1, 0 ) ]

[h:'<!--Teleport and Roof-->']
[h:defineFunction(prefix+"roofSwap", "roofSwap@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"teleport", "teleport@"+thisLib, 0, 1 ) ]
[h:defineFunction(prefix+"mapTeleport", "mapTeleport@"+thisLib, 0, 1 ) ]
[h:defineFunction(prefix+"setRoof", "setRoof@"+thisLib, 0, 1 ) ]
[h:defineFunction(prefix+"setVBLRoof", "setVBLRoof@"+thisLib, 1, 1 ) ]

[h:'<!-- Door Map Button macros -->']
[h:defineFunction(prefix+"operateLever", "operateLever@"+thisLib, 0, 0 ) ]
[h:defineFunction(prefix+"toggleLock", "toggleLock@"+thisLib, 1, 1 ) ]

[h:'<!-- Group Move macros -->']
[h:defineFunction(prefix+"setGroup", "setGroup@"+thisLib, 1, 0) ]
[h:defineFunction(prefix+"clearGroup", "clearGroup@"+thisLib, 1, 0) ]
[h:defineFunction(prefix+"rotateCW", "rotateCW@"+thisLib, 1, 0) ]
[h:defineFunction(prefix+"rotateCCW", "rotateCCW@"+thisLib, 1, 0) ]
[h:defineFunction(prefix+"spreadGroup", "spreadGroup@"+thisLib, 1, 0) ]
[h:defineFunction(prefix+"contractGroup", "contractGroup@"+thisLib, 1, 0) ]
[h:defineFunction(prefix+"formationSquare", "formationSquare@"+thisLib, 1, 0) ]
[h:defineFunction(prefix+"formationWedge", "formationWedge@"+thisLib, 1, 0) ]
[h:defineFunction(prefix+"formationPWedge", "formationPWedge@"+thisLib, 1, 0) ]
[h:defineFunction(prefix+"formationLine", "formationLine@"+thisLib, 1, 0) ]
[h:defineFunction(prefix+"formationEchelon", "formationEchelon@"+thisLib, 1, 0) ]
[h:defineFunction(prefix+"formationStagger", "formationStagger@"+thisLib, 1, 0) ]

[h:'<!-- Assigned Pads -->']
[h:defineFunction(prefix+"assignPads", "assignPads@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"execAssignPads", "execAssignPads@"+thisLib, 1, 1 ) ]

[h:'<!--animateMove macros-->']
[h:defineFunction(prefix+"animateMove", "animateMove@"+thisLib, 1,0 ) ]
[h:defineFunction(prefix+"animateText", "animateText@"+thisLib, 1,1 ) ]
[h:defineFunction(prefix+"delay", "delay@"+thisLib, 1,1 ) ]

[h:'<!-- bubblobills Delete Utility-->']
[h:defineFunction(prefix+"buildInputString","buildInputString@"+thisLib)]

[h:'<!-- Door Animation -->']
[h:defineFunction(prefix+"setDoor", "setDoor@"+thisLib, 0, 1 ) ]
[h:defineFunction(prefix+"toggleDoor", "toggleDoor@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"toggleDoors", "toggleDoors@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"isDoorClosed", "isDoorClosed@"+thisLib)] 
[h:defineFunction(prefix+"setVBLDoor", "setVBLDoor@"+thisLib,1,0)] 

[h:'<!-- EVENT macros-->']
[h:defineFunction(prefix+"getEventType", "getEventType@"+thisLib, 1,0) ]
[h:defineFunction(prefix+"convertTrapPit", "convertTrapPit@"+thisLib, 0,1) ]
[h:defineFunction(prefix+"setEventPad", "setEventPad@"+thisLib, 0, 1 ) ]
[h:defineFunction(prefix+"setEventButton", "setEventButton@"+thisLib, 0, 1 ) ]
[h:defineFunction(prefix+"resetPit", "resetPit@"+thisLib, 0, 1 ) ]
[h:defineFunction(prefix+"executeEvent", "executeEvent@"+thisLib, 0, 1 ) ]

[h:'<!-- orderFrame -->']
[h:defineFunction(prefix+"orderFrame", "orderFrame@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"groupFrame", "groupFrame@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"reOrderTokens", "reOrderTokens@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"orderWarning", "orderWarning@"+thisLib, 1, 1 ) ]

[h:'<!-- 10. geometric functions -->']
[defineFunction(prefix+"pointInTriangle", "pointInTriangle@"+thisLib, 1, 1)]
[defineFunction(prefix+"pointInCone", "pointInCone@"+thisLib, 1, 1)]

[defineFunction(prefix+"showTriangle", "showTriangle@"+thisLib, 1, 1)]
[defineFunction(prefix+"showCone", "showCone@"+thisLib, 1, 1)]
[defineFunction(prefix+"showLine", "showLine@"+thisLib, 1, 1)]
[defineFunction(prefix+"showSquare", "showSquare@"+thisLib, 1, 1)]
[defineFunction(prefix+"showCircle", "showCircle@"+thisLib, 1, 1)]

[defineFunction(prefix+"getTriangleCoords", "getTriangleCoords@"+thisLib, 1, 1)]
[defineFunction(prefix+"getConeCoords", "getConeCoords@"+thisLib, 1, 1)]
[defineFunction(prefix+"getLineCoords", "getLineCoords@"+thisLib, 1, 1)]
[defineFunction(prefix+"getSquareCoords", "getSquareCoords@"+thisLib, 1, 1)]
[defineFunction(prefix+"getCircleCoords", "getCircleCoords@"+thisLib, 1, 1)]

[defineFunction(prefix+"pointOnTriangle", "pointOnTriangle@"+thisLib, 1, 1)]
[defineFunction(prefix+"pointOnCone", "pointOnCone@"+thisLib, 1, 1)]
[defineFunction(prefix+"pointOnLine", "pointOnLine@"+thisLib, 1, 1)]
[defineFunction(prefix+"pointOnSquare", "pointOnSquare@"+thisLib, 1, 1)]
[defineFunction(prefix+"pointOnCircle", "pointOnCircle@"+thisLib, 1, 1)]

[defineFunction(prefix+"selectOnTriangle", "selectOnTriangle@"+thisLib, 1, 1)]
[defineFunction(prefix+"selectOnCone", "selectOnCone@"+thisLib, 1, 1)]
[defineFunction(prefix+"selectOnLine", "selectOnLine@"+thisLib, 1, 1)]
[defineFunction(prefix+"selectOnSquare", "selectOnSquare@"+thisLib, 1, 1)]
[defineFunction(prefix+"selectOnCircle", "selectOnCircle@"+thisLib, 1, 1)]

[defineFunction(prefix+"getNeighbourXY", "getNeighbourXY@"+thisLib, 1, 1)]
[defineFunction(prefix+"isClockWise", "isClockWise@"+thisLib, 1, 1)]

[h:'<!-- 11. Tables  -->']
[defineFunction(prefix+"createTable", "createTable@"+thisLib,1,1)]

[defineFunction(prefix+"getRows", "getRows@"+thisLib,1,1)]
[defineFunction(prefix+"getColumns", "getColumns@"+thisLib,1,1)]
[defineFunction(prefix+"table", "table@"+thisLib,1,1)]
[defineFunction(prefix+"deleteTable", "deleteTable@"+thisLib,1,1)]
[defineFunction(prefix+"showTable", "showTable@"+thisLib,1,1)]
[defineFunction(prefix+"setTable", "setTable@"+thisLib,1,1)]
[defineFunction(prefix+"searchRow", "searchRow@"+thisLib,0,0)]

[defineFunction(prefix+"listMTTables", "listMTTables@"+thisLib,1,1)]
[defineFunction(prefix+"listBoTTables", "listBoTTables@"+thisLib,1,1)]

[defineFunction("json.paths", "json.paths@"+thisLib,1,1)]
[defineFunction("json.pget", "json.pget@"+thisLib,1,1)]
[defineFunction("json.pset", "json.pset@"+thisLib,1,1)]
[defineFunction("json.pappend", "json.pappend@"+thisLib,1,1)]

[h:'<!-- math -->']
[h:defineFunction(prefix+"pi", "pi@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"cos", "cos@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"sin", "sin@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"tan", "tan@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"toRadians", "toRadians@"+thisLib, 1, 1 ) ]
[h:defineFunction("odd", "odd@"+thisLib)]
[h:defineFunction("mod", "mod@"+thisLib,1,1)]
[h:defineFunction(prefix+"facingToCoord", "facingToCoord@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"facingToCoordX", "facingToCoordX@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"facingToCoordY", "facingToCoordY@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"getTokenFacing", "getTokenFacing@"+thisLib,1,1)] 
[h:defineFunction(prefix+"setTokenFacing", "setTokenFacing@"+thisLib,1,1)] 

[h:'<!-- MESSAGE macros-->']
[h:defineFunction(prefix+"message", "message@"+thisLib,1,1)]
[h:defineFunction(prefix+"self", "self@"+thisLib,1,1)]
[h:defineFunction(prefix+"nself", "nself@"+thisLib,1,1)]
[h:defineFunction(prefix+"all", "all@"+thisLib,1,1)]
[h:defineFunction(prefix+"gm", "gm@"+thisLib,1,1)]
[h:defineFunction(prefix+"ngm", "ngm@"+thisLib,1,1)]
[h:defineFunction(prefix+"selfgm", "selfgm@"+thisLib,1,1)]
[h:defineFunction(prefix+"nselfgm", "nselfgm@"+thisLib,1,1)]
[h:defineFunction(prefix+"ownergm", "ownergm@"+thisLib,1,1)]
[h:defineFunction(prefix+"nownergm", "nownergm@"+thisLib,1,1)]

[h:'<!-- Rumbles Delete Utility-->']
[h:defineFunction(prefix+"cpyDelMacros","cpyDelMacros@"+thisLib)]
[h:defineFunction(prefix+"undoDelMacros","undoDelMacros@"+thisLib)]
[h:defineFunction(prefix+"pasteMacros","pasteMacros@"+thisLib)]

[h:'<!-- Rumbles Dice box -->']
[h:defineFunction("dbxOutputTo","dbxOutputTo@"+thisLib)]
[h:defineFunction("dbxLaunch", "Launch Dice Box@"+thisLib)]

[h:'<!-- Aliasmasks Disguise Macros -->']
[H: defineFunction("bot_useDisguise","useDisguise@"+thisLib,1,1)]

[h:'<!-- LMarkus Whispers -->']
[H: defineFunction( 'bot_outputTo', 'outputTo@this' )]
[H: defineFunction( 'bot_whisperFrame', 'whisperFrame@this' )]

[h:'<!-- scatter -->']
[h:defineFunction(prefix+"scatter", "scatter@"+thisLib)]
[h:defineFunction(prefix+"buildForest", "buildForest@"+thisLib)]
[h:defineFunction(prefix+"chooseTrunks", "chooseTrunks@"+thisLib)]
[h:defineFunction(prefix+"getValidTrunks", "getValidTrunks@"+thisLib, 0, 0)]
[h:defineFunction(prefix+"createCrowd", "createCrowd@"+thisLib)]
[h:defineFunction(prefix+"moveCrowd", "moveCrowd@"+thisLib,1,1)]
[h:defineFunction(prefix+"moveCrowdPlus", "moveCrowdPlus@"+thisLib,1,1)]
[h:defineFunction(prefix+"chooseCrowd", "chooseCrowd@"+thisLib)]
[h:defineFunction(prefix+"getValidCrowd", "getValidCrowd@"+thisLib, 0, 0)]
[h:defineFunction(prefix+"mapEditor", "mapEditor@"+thisLib, 1, 1)]
[h:defineFunction(prefix+"fieldEditDialog", "fieldEditDialog@"+thisLib, 1, 1)]
[h:defineFunction(prefix+"quitEditor", "quitEditor@"+thisLib, 1, 1)]
[h:defineFunction(prefix+"moveToHidden", "moveToHidden@"+thisLib, 1, 1)]
[h:defineFunction(prefix+"moveToToken", "moveToToken@"+thisLib, 1, 1)]

[h:'<!-- Summon macros-->']
[h:defineFunction(prefix+"summonToken", "summonToken@"+thisLib, 0, 1) ]
[h:defineFunction(prefix+"getValidTokens", "getValidTokens@"+thisLib, 0, 0) ]

[h:'<!-- Dungeon builder -->']
[h:defineFunction(prefix+"getFieldValue", "getFieldValue@"+thisLib, 1, 1) ]

[h:'<!--Timer functions -->']
[h:defineFunction(prefix+"resetTimer", "resetTimer@"+thisLib, 1, 1)]
[h:defineFunction(prefix+"timeOut", "timeOut@"+thisLib, 1, 1)]
[h:defineFunction(prefix+"startTime", "startTime@"+thisLib, 1, 1)]
[h:defineFunction(prefix+"pauseTime", "pauseTime@"+thisLib, 1, 1)]
[h:defineFunction(prefix+"resumeTime", "resumeTime@"+thisLib, 1, 1)]
[h:defineFunction(prefix+"subTime", "subTime@"+thisLib, 1, 1)]
[h:defineFunction(prefix+"totalTime", "totalTime@"+thisLib, 1, 1)]
[h:defineFunction(prefix+"formatTime", "formatTime@"+thisLib, 1, 1)]

[h:'<!--util macros-->']
[h:defineFunction(prefix+"removeTokens", "removeTokens@"+thisLib,1,1)]
[h:defineFunction(prefix+"manualText", "manualText@"+thisLib)]
[h:defineFunction(prefix+"manFunctionsTxt", "manFunctionsTxt@"+thisLib)]
[h:defineFunction(prefix+"settings", "settings@"+thisLib)]
[h:defineFunction(prefix+"renumberToks", "renumberToks@"+thisLib)]
[h:defineFunction(prefix+"toggleSpecial", "toggleSpecial@"+thisLib)]
[h:defineFunction(prefix+"abortProcess", "abortProcess@"+thisLib)]
[h:defineFunction(prefix+"setDrawOrder", "setDrawOrder@"+thisLib)]
[h:defineFunction(prefix+"removeP20", "removeP20@"+thisLib)]
[h:defineFunction(prefix+"setLightSource", "setLightSource@"+thisLib,1,1)]
[h:defineFunction(prefix+"applyLightSource", "applyLightSource@"+thisLib,1,0)]
[h:defineFunction(prefix+"movementLock", "movementLock@"+thisLib,1,1)]
[h:defineFunction(prefix+"tokenLock", "tokenLock@"+thisLib,1,1)]
[h:defineFunction(prefix+"toggleFullScreen", "toggleFullScreen@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"isFullScreen", "isFullScreen@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"rotateGroup", "rotateGroup@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"showHandout", "showHandout@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"benchmark", "benchmark@"+thisLib, 0, 1 ) ]
[h:defineFunction(prefix+"diagnose", "diagnose@"+thisLib, 1, 0 ) ]

[h:'<!--documented util macros-->']
[h:defineFunction(prefix+"createSplices", "createSplices@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"getPath", "getPath@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"getTokensPath", "getTokensPath@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"ids2Names", "ids2Names@"+thisLib)]
[h:defineFunction(prefix+"ids2NamesArray", "ids2NamesArray@"+thisLib)]
[h:defineFunction(prefix+"showHTML", "showHTML@"+thisLib)]
[h:defineFunction("pause", "pause@"+thisLib, 1,0 ) ]
[h:defineFunction(prefix+"inStr", "inStr@"+thisLib)] 
[h:defineFunction(prefix+"getGridSize", "getGridSize@"+thisLib,1,1)]
[h:defineFunction(prefix+"round2Grid", "round2Grid@"+thisLib,1,1)]
[h:defineFunction(prefix+"ppc2GridCoord", "ppc2GridCoord@"+thisLib,1,1)]

[h:defineFunction(prefix+"snapAngle", "snapAngle@"+thisLib,1,1)]
[h:defineFunction(prefix+"snapToGrid", "snapToGrid@"+thisLib,1,1)]
[h:defineFunction(prefix+"travelAngle", "travelAngle@"+thisLib,1,1)]
[h:defineFunction(prefix+"seekToken", "seekToken@"+thisLib,1,1)]
[h:defineFunction(prefix+"getNewImage", "getNewImage@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"execAllPlayers", "execAllPlayers@"+thisLib,1,1)]
[h:defineFunction(prefix+"sortTokByProp", "sortTokByProp@"+thisLib,1,1)]
[h:defineFunction(prefix+"debugInfo", "debugInfo@"+thisLib,1,0)]
[h:defineFunction(prefix+"switchMap", "switchMap@"+thisLib,1,0)]
[h:defineFunction(prefix+"findDuplicates", "findDuplicates@"+thisLib,1,0)]

[h:'<!-- VBL -->']
[h:defineFunction(prefix+"createVBL", "createVBL@"+thisLib, 1, 0 ) ]
[h:defineFunction(prefix+"removeVBL", "removeVBL@"+thisLib, 1, 0 ) ]
[h:defineFunction(prefix+"VBLGrenade", "VBLGrenade@"+thisLib, 1, 0 ) ]
[h:defineFunction(prefix+"moveStamp", "moveStamp@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"setVBL", "setVBL@"+thisLib, 1, 0 ) ]
[h:defineFunction(prefix+"extendPoint", "extendPoint@"+thisLib, 1, 0 ) ]
[h:defineFunction(prefix+"drawFgVBL", "drawFgVBL@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"saveFgVBL", "saveFgVBL@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"drawBgVBL", "drawBgVBL@"+thisLib, 1, 1 ) ]
[h:defineFunction(prefix+"saveBgVBL", "saveBgVBL@"+thisLib, 1, 1 ) ]

[h:'<!-- REDEFINED FUNCTIONS -->']
<!-- isdefined: 0 no, 1 yes, 2 mt core function -->
[h,if(getLibProperty('fullScreenBroadcast','lib:EventMacros') == 1 && isFunctionDefined("broadcast") == 2):defineFunction("broadcast", "bot_broadcast@"+thisLib, 1, 1 ) ]

[H: '<!------------------------------------------------------- ASSERTIONS, check if settings are set up correctly -->']
[h:baseMap		= getLibProperty("baseMapName", "lib:EventMacros")]
[h:mapList		= getAllMapNames("json")]
[h,if(!json.contains(mapList, baseMap)), CODE:{
	<!-- if this is the first time someone sets up then check if your on the right map, lib eventmacros is there, settings is run once -->
	[botTok	= findToken("lib:OnTokenMove")]
	[emTok	= findToken("lib:EventMacros")]
	[assert(botTok != "", "BASE map name is not set up correctly. Please run Settings and set up the correct BASE map, when done run onCampaignLoad macro on the lib:OnTokenMove token",0)]
	[assert(emTok != "", "Make sure that there is a lib:EventMacros on the same map as lib:OnTokenMove and that you have run the settings (and set up the BASE map correctly in the settings)",0)]
	[setLibProperty("baseMapName", getCurrentMapName(), "lib:EventMacros")]
	[bot_settings()]
	[baseMap		= getLibProperty("baseMapName", "lib:EventMacros")]
}]

[H: '<!------------------------------------------------------- Check if list of logged on GMs has changed -->']
[h:newGmNames = getLibProperty("gmNames", "lib:EventMacros")]
[h,if(json.type(newGmNames)!="ARRAY"):newGmNames	= "[]"]
[h:oldgmNames = newGmNames]
[H:playerName = json.fromList(getPlayerName())]
[h:tmpAllPlayers = getAllPlayerNames("json")]
[H,if(isGM()), CODE:{
	[newGmNames	= json.union(newGmNames,playerName)]
	[intersect	= '[]']
}; { 
	[intersect	= json.intersection(newGmNames,playerName)]
	[if(!json.isEmpty(intersect)): newGmNames = json.difference(newGmNames,playerName)]
}]
[H: newGmNames = json.intersection(tmpAllPlayers,newGmNames)]

[H: '<!------------------------------------------------------- if the list has changed, make sure you do the update on the BASE map!! -->']
[h:oldMap			= getCurrentMapName()]
[h,if(!json.equals(oldgmNames,newGmNames)), CODE:{
	[setCurrentMap(baseMap)]
 	[setLibProperty("gmNames",newGmNames, "lib:EventMacros")]
}; {}]

[h:noGM = json.isEmpty(getLibProperty("gmNames", "lib:EventMacros"))]
[h,if(noGM), CODE:{
	[abort(input(
		"junk|<html><b>The system has no GMs registered.<br>If you started the game without a gm restart it and correct it.<br>Else pick the gm from the list below</b></html>|-|LABEL|SPAN=TRUE",
		"gmNames|"+getAllPlayerNames()+"|Select the gm|LIST|SELECT=0 VALUE=STRING"
	))]
	[setLibProperty("gmNames", json.fromList(gmNames), "lib:EventMacros")]
}]

[H: '<!-- ----------------------------------------------------- /Check if list of logged on GMs has changed -->']

[h:'<!-- ------------------- check for areas, if theyre not initialized do so now ------------------------>']
[h: linkedAreas = getLibProperty("linkedAreas", "Lib:EventMacros") ]
[h, if(json.type(linkedAreas)=="UNKNOWN"): setLibProperty("linkedAreas", "{}", "Lib:EventMacros")]

[h:'<!-- ------------------ if the maps are not initialized, do so now ----------------------------------->']
[h:oldMapsPads		= getLibProperty("allMapsPads", "lib:EventMacros")]
[h:initialized		= 1]
[h:chckMapsOCL		= getLibProperty("checkMapsOCL", "lib:EventMacros")]
[h:macroLocation	= getMacroLocation()]

[h, if(json.type(oldMapsPads)=='OBJECT' && chckMapsOCL), CODE:{
	[excludedMaps	= getLibProperty("excludedMaps","lib:EventMacros")]
	[toCheckMaps	= json.difference(mapList, excludedMaps)]
	[foreach(currentMap, mapList,""), CODE:{
		[setCurrentMap(currentMap)]
		<!-- find the map on which the lib token is located -->
		[if(findToken(macroLocation) != ""): macroMap = currentMap]
		<!-- check if map is initialized -->
		[if(!json.contains(oldMapsPads, currentMap) && json.contains(toCheckMaps, currentMap)):initialized = 0]<br>
	}]
}; {}]

[h, if(json.type(oldMapsPads)!='OBJECT' && chckMapsOCL), CODE:{
	[initialized	= 0]
	[foreach(currentMap, mapList,""), CODE:{
		[setCurrentMap(currentMap)]
		[if(findToken(macroLocation) != ""): macroMap = currentMap]
	}]
}; {}]

[r,if(!initialized && chckMapsOCL), CODE:{
	[r:bot_initializePads(1)]
	[h:newMapsPads = macro.return]
	[h:setCurrentMap(macroMap)]
	[h:setLibProperty("allMapsPads",newMapsPads,"lib:EventMacros")]
}; {}]

[h,if(getLibProperty('runSwitchForm','lib:EventMacros')==1), CODE:{
	[macro("SwitchFrame@Lib:OnTokenMove"):""]
}; {}]

<!-- AMs disguise macro initialization -->
[H: disguiseMacro	= getLibProperty("am.bot.disguiseMacro")]
[H, if(json.isEmpty(disguiseMacro)), CODE: {
	[macroName	= "Use Disguise"]
	[index		= getMacroIndexes(macroName)]
	[command	= getMacroCommand(index)]
	[props		= json.set(getMacroProps(index,"json"),"command",command)]
	[props		= json.removeAll(props,json.set("{}","index","","group",""))]
	[setLibProperty("am.bot.disguiseMacro",props)]
};{}]

[h:disableOCLCheck		= getLibProperty('disableOCLCheck','lib:EventMacros')]
[h,if(disableOCLCheck != 1), CODE:{
	[h:'<!-- -------------------------------- OUTPUT TO CHAT THROUGH BROADCAST -------------------------------- -->']
	
	<!-- check for installation errors and sets the messages error messages - NO NEW SCOPE
	stateOutput, tokOutput, tableOutput, libOwnerOutput	-->
	[h:bot_diagnose(1)]

	[vblSupport		= if(bot_inStr(lower(mtVersion), "nerps") || mtVersionNr > 89, 1, 0)]
	[vblOutput		= if(vblSupport, "&nbsp;v This Maptool version <b>supports</b> automatic vision blocking manipulation, this functionality will be <b>enabled</b>", "&nbsp;x This Maptool version <b>does <u><font color='red'>not</font></u> support</b> automatic vision blocking manipulation, this functionality will be <b>disabled</b>"))]
	[setLibProperty('vblSupport',vblSupport,'lib:EventMacros')]
	[message		= "&nbsp;v Current online GM's are: <b>"+json.toList(newGmNames) + "</b>"]
	[message		= listAppend(message, "&nbsp;v This campaign runs in Maptool version <b>"+mtVersion+"</b>","<br>")]
	[message		= listAppend(message, "&nbsp;v This campaign if powered by version <b>"+botVersion+"</b> of the <b>Bag of Tricks</b> (<font color='blue'><a href='http://forums.rptools.net/viewtopic.php?f=46&t=16066#p170978'>check for updates</a></font>)","<br>")]
	[message		= listAppend(message, vblOutput,"<br>")]
	[message		= listAppend(message, stateOutput,"<br>")]
	[message		= listAppend(message, tokOutput,"<br>")]
	[message		= listAppend(message, tableOutput,"<br>")]
	[message		= listAppend(message, libOwnerOutput,"<br>")]

	[if(right != ""): message = replace(message, "&nbsp;v ", right+"&nbsp;")]
	[if(wrong != ""): message = replace(message, "&nbsp;x ", wrong+"&nbsp;")]
	<!-- 0:message, OPTIONAL1:headertxt, 2:color (bgcolor-txtcolor), 3:userList, 4:token, 5:target6:broadcast-->
	[bot_message(message, "<b>Bag of Tricks - OnCampaignLoad checks</b>", "maroon-yellow", bot_self())]
};{}]

<!-- ---------------------- on campaign load goto map and coords settings, must come AFTER diagnose due to the map switching -------------------------------------------------------- -->
[h,if(getLibProperty('useStartUpMap','lib:EventMacros')==1), CODE:{
	[setCurrentMap(getLibProperty('startUpMap','lib:EventMacros'))]
	[gotoCoord	= getLibProperty('startUpCoords','lib:EventMacros')]
	[h,if(findToken("centreOnMePad") != "" && getLibProperty('useCentreOnMePad','lib:EventMacros')==1), CODE:{
		<!-- if centreOnMePad checkbox is checked AND the token is on the map, centre the map on there -->
		[goto(getTokenX(0,"centreOnMePad"),getTokenY(0,"centreOnMePad"))]
	}; {
		<!-- else centre the map on the given coords -->
		<!-- you can set either a coordinate e.g. 4,5 or a token name e.g. "Nihilus Faine" -->
		[if(listCount(gotoCoord)==2): goto(listGet(gotoCoord, 0),listGet(gotoCoord, 1)) ; goto(gotoCoord)]
	}]
}; {
	[setCurrentMap(oldMap)]
}]

<!-- make sure there is no output to chat -->
[abort(0)]

@@(Un)Show Area
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=43 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This macro shows predefined areas by putting token in the cells that are part of the Area.<br>When you run this macro again the tokens are removed again.<br><br>Hence this macro can be used to change pre defined area. To do this first run this macro<br>for the area you wish to change. The map will then be filled with tokens. Then move these<br>tokens around, delete them, copy them until youre happy. Then run <i>Define Area</i> and<br>enter a name for the new Area (can be the same as the original in which case it will be<br>overwritten) and click ok. A new Area is now defined. Finally you can run Show Area again<br>to remove the tokens. Note that is you created new tokens that these will NOT be removed by<br>this macro. ; minWidth=90 ; 
[h,macro("showArea@lib:OnTokenMove"):""]

@@<i>Animate Text
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=10 ; color=blue ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip= ; minWidth=90 ; 
[h,macro("animateTextInput@lib:OnTokenMove"):""]

@@Activate Group
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=112 ; color=aqua ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This opens a 'group select' frame which is required for the 'Select Group' to function.<br>When this panel is closed you can still group and ungroup, but the 'auto select' will only<br>work when this frame is active. ; minWidth=90 ; 
[h, macro("openGroupFrame@Lib:OnTokenMove"):""]

@@Activate Switches
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=13 ; color=orange ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This macro activates a frame. As long as that frame is open the following functions are active:<br>- Door Switches (user can click them to open doors) <br>- Event Buttons (user can click them to activate linked macro) <br>- Full screen mode (if turned on in the settings, frames are automatically turned into Dialogs) <br>- Group select tokens (user can select one token and the rest is auto-selected)<br>- Force token selection (token that gm selects on his client is also selected on a player client)<br></html> ; minWidth=90 ; 
[h, macro("openFrame@Lib:OnTokenMove"):""]

@@Alt. Init. Pads
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=4 ; color=fuchsia ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip= ; minWidth=90 ; 
[r:bot_altInitMap()]

@@Animate Move
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=11 ; color=blue ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip= ; minWidth=90 ; 
[r:bot_animateMove()]

@@Assign Areas
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=42 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>With this macro you can link predefined Areas to Event Macros and to the Limit Movement macro<br>The Event Macro will be triggered when a token moves over the Area. The handling of this is left<br>to the macro itself ; minWidth=90 ; 
[h,macro("assignArea@lib:OnTokenMove"):""]

@@Assign Tokens to Pads
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=51 ; color=blue ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>With this macro you can assign token that are on the TOKEN or HIDDEN layer to Assignpads.<br>Tokens assigned to Assignpads will be moved onto their assigned pad when you run Execute<br>Assignpads<br> ; minWidth=90 ; 
[h:bot_assignPads()]

@@Auto Disguise Btn
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=81a ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>When you click this, a text box will appear with<br>a token property you can add to your Campaign<br>Property token properties to automatically<br>add the <i>Use Disguise</i> button to tokens.</html> ; minWidth=90 ; 
[h:'<!-- -------------------------------------- autoDisguiseButton -------------------------------------------------------- -->']

[H, if(json.isEmpty(macro.args)), CODE: {
	[propText		= '*autoDisguiseButton:[macro("autoDisguiseButton@lib:disguise"): currentToken()]']
	[input(
		"label|<html><b>Copy text in to Token Property to auto load Disguise Button:</b><br></html>||LABEL|SPAN=TRUE",
		strformat("Text|%{propText}||TEXT|SPAN=TRUE WIDTH=50")
	)]
};{
	[id				= json.get(macro.args,0)]
	[switchToken(id)]
	[disguiseMacro	= getLibProperty("am.bot.disguiseMacro",getMacroLocation())]
	[setProperty("autoDisguiseButton","")]
	[if(!hasMacro("Use Disguise")): createMacro(disguiseMacro)]
}]

@@Bag of Tricks Macros
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=11pt ; sortBy=1 ; color=black ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip= ; minWidth=193 ; 
[r:bot_MacroButtonsOTMSetup()]

@@Build Forest
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=21 ; color=blue ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>Select a one ore more images of a Tree top (Canopy) and click this button to randomly spread them over an area</html> ; minWidth=90 ; 
[r:bot_buildForest()]

@@Choose Crowd
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=24 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This will show a form where you can select or deselect crowd tokens images<br>which are on the BASE map. The checked images will be (randomly) used for<br>the <i>Create Crowd</i> macro.</html> ; minWidth=90 ; 
[h:bot_chooseCrowd()]

@@Choose Trunks
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=20 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This will show a form where you can select or deselect tree trunk images<br>which are on the BASE map. The checked images will be (randomly) used for the <i>Canopy</i> pads</html> ; minWidth=90 ; 
[r:bot_chooseTrunks()]

@@Contract Group
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=94 ; color=maroon ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=Select one token of a group and contract the other tokens with an offset of X=-1 and Y=-1 ; minWidth=90 ; 
[h:bot_contractGroup()]

@@Convert Trap/Pits
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=11a ; color=green ; playerEditable=false ; applyToSelected=true ; group=(drag to) Campaign Macros ; tooltip=<html>This macro will convert ALL Pits and Traps on ALL (not excluded) maps to EventPads.<br>For pits you will need to rewrite the macro slightly before it works again. ; minWidth=90 ; 
[r:bot_convertTrapPit()]

@@Copy / Del. Macro
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=11pt ; sortBy=82 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html> This macro allows you to select macros on the selected token. The selected macros you can copy or delete.<br> <br> In case of <b>copy</b>, they will be stored in a property on lib:EventMacros. When you select another token you can <br> click <i>Paste Macros</i>. This will open a similar frame where you can select the macros to paste on the selected<br> token.<br> In case of <b>delete</b> you have the option to <i>allow undo</i>. The selected macros will be deleted from the token<br> and if allow undo is turned on, they will be stored in a property on that token. So you can later choose to undo the<br> process. </html> ; minWidth=90 ; 
[H: bot_cpyDelMacros()]

@@Create Crowd
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=25 ; color=blue ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>Same as choose trunks. Creates a list of tokens which 'Create Crowd' uses.<br> Based on tokens on BASE map starting name with 'Crowd ' ; minWidth=90 ; 
[h:bot_createCrowd()]

@@Define Area
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=41 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>With this macro you can define an Event Area which you then can link to an event macro, to be triggered when a token moves over this area. ; minWidth=90 ; 
[h,macro("defineArea@lib:OnTokenMove"):""]

@@Diagnose Maps
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=11pt ; sortBy=81b ; color=red ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>Map diagnosis. This function checks ALL maps and ALL (lib)tokens for potential issues.<br> It checks whether token names contain non-alphanumerical characters and checks the libs for the<br> same and owner ship and visibility. Any errors are rendered in a frame with hyperlinks that lead<br> you to the token. </html> ; minWidth=90 ; 
[h:bot_diagnose()]

@@Draw Area
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=43 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This macro fills up an area with tokens. You can either select ONE token and run it, or run it without selection.<br>If you select one token before you run this then that token will be added to the dropdown. ; minWidth=90 ; 
[h,macro("toggleAreaDraw@lib:OnTokenMove"):""]

@@Draw Order
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy=111 ; color=aqua ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This opens a 'group select' frame which is required for the 'Select Group' to function.<br>When this panel is closed you can still group and ungroup, but the 'auto select' will only<br>work when this frame is active. ; minWidth=90 ; 
[h, macro("openOrderFrame@Lib:OnTokenMove"):""]

@@Echelon Formation
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=98 ; color=maroon ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=Select one token of a group and put them in formation ; minWidth=90 ; 
[h:bot_formationEchelon()]

@@Execute AssignPads
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=52 ; color=blue ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>Before you can use this macro you first need to assign token to the special Assignpads.<br>Once that is done, you can run this macro and pick the Assignpads to be executed.<br>On execution the linked token will be moved to its assigned pad.<br> ; minWidth=90 ; 
[h:bot_execAssignPads()]

@@Execute Event
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=11 ; color=blue ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=Select a door (that has been initialized) and click this button to open or close it ; minWidth=90 ; 
[r:bot_executeEvent()]

@@Execute event
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=33 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This macro generates a list of macros per group from the lib:Event token.<br>You can select one or more macros which then will be executed ; minWidth=90 ; 
[r:bot_executeEvent()]

@@Fill Area
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=43 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This macro fills a predefined area with tokens</html> ; minWidth=90 ; 
[h,macro("fillArea@lib:OnTokenMove"):""]

@@Find Duplicates
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=77 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=Give a list of all tokens of all layers on current map that have the same name ; minWidth=90 ; 
[h:bot_findDuplicates()]

@@Formation Buttons
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=83 ; color=maroon ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>Select a group of tokens to group them for group move.<br>Note that any previous set groups for any of the tokens will be<br>cleared if you run this macro.<br>Also note that this macro makes use of the label field of the<br>token and any current value will get overwritten!!. Changing<br>this value after a group has been set will de-activate group-<br>movement when you move THAT token. The token will still be<br>part of the group and will be moved if another token of the<br>group is moved ; minWidth=90 ; 
[h:bot_MacroButtonsGroupMove()]

@@Group (Move)
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=101 ; color=maroon ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>Select a group of tokens to group them for group move.<br>Note that any previous set groups for any of the tokens will be<br>cleared if you run this macro.<br>Also note that this macro makes use of the label field of the<br>token and any current value will get overwritten!!. Changing<br>this value after a group has been set will de-activate group-<br>movement when you move THAT token. The token will still be<br>part of the group and will be moved if another token of the<br>group is moved ; minWidth=90 ; 
[h:bot_setGroup()]

@@Group (Select)
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=113 ; color=aqua ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This macro creates a 'select group' of all currently selected tokens.<br>After a group is set (and the group select frame is active) when you<br>select one token of the group, all the other tokens of the group will be<br>automatically selected as well. This is particularly usefull when drawing<br>maps and you want to group a set of tokens into one object. ; minWidth=90 ; 
[h, macro("setSelectGroup@Lib:OnTokenMove"):""]

@@Initialize Pads
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=3 ; color=red ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This macro cycles through all maps in the campaign file<br>looking for special pads. It will initialize any special pad it<br>encounters and report any errors  on the way ; minWidth=90 ; 
[r:bot_initializePads()]

@@Line Formation
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=97 ; color=maroon ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=Select one token of a group and put them in formation ; minWidth=90 ; 
[h:bot_formationLine()]

@@Lock Movement
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy=121 ; color=yellow ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>When this is turned ON, no PLAYER can move a token, only the GM can.</html> ; minWidth=90 ; 
[h:bot_movementLock()]

@@Lock Token
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy=121 ; color=yellow ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>When this is turned ON, no one (gm included) can move the selected token(s).<br>For this to work the toggle in the settings: 'Lock Movement for Locked Tokens' needs to be turned on!</html> ; minWidth=90 ; 
[h:bot_tokenLock()]

@@Manual
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=2 ; color=blue ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip= ; minWidth=90 ; 
[h:bot_manualText()]

@@Map Editor
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=28 ; color=maroon ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=Creates an overlay on the token layer where you can quickly create a new map. ; minWidth=90 ; 
[h:bot_mapEditor()]

@@Mass VBL
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=122 ; color=black ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This function draws VBL crosses on all tokens that match a search string ; minWidth=90 ; 
[h,macro("MassVBL@lib:OnTokenMove"):""]

@@Message Mngr
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=11pt ; sortBy=81b ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html> This macro allows you to store prepared messages and manage these.<br> For GM's these will be store on lib:EventMacros, for players these will <br> be stored on the token that they own (and is selected). <br> To add a picture to a message: <br> - create the message (and save it). <br> - select the token that contains the image (can be token,portrait or handout).<br> - click 'add selected image' for that message. The rest should be simple.<br> </html> ; minWidth=90 ; 
[macro("notes@Lib:OnTokenMove"):""]

@@Move Crowd
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=26 ; color=blue ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>Disperses a crowd created by the 'Create Crowd' macro.<br>Make sure the antagonist is on the map. ; minWidth=90 ; 
[h:bot_moveCrowd()]

@@Move Crowd +
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=27 ; color=blue ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>Disperses a crowd created by the 'Create Crowd' macro.<br> Make sure the antagonist is on the map.<br> <br> This macro uses more intelligence however and is more realistic<br> but MUCH slower (roughly 1 second per 10 tokens) ; minWidth=90 ; 
[h:bot_moveCrowdPlus()]

@@Move Token
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=8 ; color=black ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This macro will animate the movement of the selected token. An options panel will be shown first.</html> ; minWidth=90 ; 
[r:bot_animateMove()]

@@Move to hidden
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=30 ; color=maroon ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=Belongs to the map editor. Moves all pasted tokens to the HIDDEN layer so they're no longer visible ; minWidth=90 ; 
[h:bot_moveToHidden()]

@@Move to token
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=30a ; color=maroon ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=Belongs to the map editor. Moves all hidden tokens back to the TOKEN layer. ; minWidth=90 ; 
[h:bot_moveToToken()]

@@Packed-Wedge
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=96 ; color=maroon ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=Select one token of a group and put them in formation ; minWidth=90 ; 
[h:bot_formationPWedge()]

@@Pads Explorer
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=11pt ; sortBy=81 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=Show overview of special pads on map ; minWidth=90 ; 
[h:bot_initializeMap()]

@@Paste Macros
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=11pt ; sortBy=82 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html> This button you can use to paste macro on the selected token. Before you do this, you first need to run the <br> Copy/Del Macros button on another token. </html> ; minWidth=90 ; 
[H: bot_pasteMacros()]

@@Quit Editor
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=29 ; color=maroon ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=removes the overlay and the states of the pasted tokens ; minWidth=90 ; 
[h:bot_quitEditor()]

@@Remove %20
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=74 ; color=green ; playerEditable=false ; applyToSelected=true ; group=(drag to) Campaign Macros ; tooltip=This macro replaces %20 with spaces " " in the selected token names ; minWidth=90 ; 
[r:bot_removeP20()]

@@Renumber Tokens
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=72 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>When you have used the scatter function<br> (especially icw Spread) then you need to <br>renumber the scattered tokens before you <br>hit the initialize pads. Assuming that you <br>have scattered special tokens onto the map<br> ; minWidth=90 ; 
[r:bot_renumberToks()]

@@Reset Pit
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=31 ; color=green ; playerEditable=false ; applyToSelected=true ; group=(drag to) Campaign Macros ; tooltip=<html>This will reset a sprung pit. Select the pit and click this button<br>This macro can also be put on the selection panel of the token. ; minWidth=90 ; 
[h:setTokenImage(getTokenPortrait())]

@@Rotate CCW
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=92 ; color=maroon ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=Select a 'group' token and rotate the other corresponding group tokens around it ; minWidth=90 ; 
[h:bot_rotateCCW()]

@@Rotate CW
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=91 ; color=maroon ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=Select a 'group' token and rotate the other corresponding group tokens around it ; minWidth=90 ; 
[h:bot_rotateCW()]

@@Rumbles DiceBox
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=79 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>Opens a form with dices where you can set a group of dice to roll<br>The workings of the Dice box are pretty obvious. What might not be<br>obvious is that it supports 10 different dice boxes. You can click the<br>macro 10 times and set each frame individually. ; minWidth=90 ; 
[h:dbxLaunch()]

@@Scatter Tokens
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=22 ; color=blue ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip= ; minWidth=90 ; 
[r:bot_scatter()]

@@Seek Token
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=77 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This macro searches ALL maps and ALL tokens and<br>return those tokens of which the first part of <br>their name matches with the entered search string<br><b>Pop-ups on first use ; minWidth=90 ; 
[h,macro("seekToken@lib:OnTokenMove"):""]

@@Set Door
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=11pt ; sortBy=6 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>To use the <i>Toggle Door(s)</i> macro, select a door and click this button to set it up</html> ; minWidth=90 ; 
[r:bot_setDoor()]

@@Set Draw Order
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=71 ; color=green ; playerEditable=false ; applyToSelected=true ; group=(drag to) Campaign Macros ; tooltip=<html>This is just a handy macro where you can manually set the draw order of the token. <br>A high number means on top of all a low number means below all.<br>Then current number (draw order) is shown when you run this macro on a token ; minWidth=90 ; 
[h:bot_setDrawOrder()]

@@Set Event Button
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=32 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This macro can be used to link an Event Macro to a Event Button.<br><br>1. Create a macro on the lib:EventMacros token in the group: 'Event Button Macros', containing the<br>code that is activated when the button, e.g. 'Switch To Map'<br>2. Select the button (any token will do) to which that macro should apply e.g. "Switch to Fair Haven"<br>3. Run this macro<br>4. Select "Switch Map" from the list<br>5. In the "Give Arguments" box enter the arguments as a stringproperty, e.g."toMap=Fair Haven"<br><br>Here it is important that both the the arguments name (toMap) and the arguments (Fair Haven)<br>contains ONLY alphanumeric  characters!<br>Note that you can give multiple arguments! Just seperate them with a ; minWidth=90 ; 
[r:bot_setEventButton()]

@@Set Event Pad
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=32 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This macro can be used to link an Event Macro to an EventPad<br><br>1. Create a macro on the lib:EventMacros token in the group:<br>'Event Pad Macros', containing the code that is activated when the<br>Event is triggered. For example 'Spear Trap<br>2. Select an 'Event token'. This is a token which name starts with<br>'EventPad ' e.g. 'EventPad 1' or 'EventPad Pit Trap'.<br>This token can be placed on any layer<br>3. Run the macro 'Set Event Pad'<br>4. Pick an Event macro from the list, e.g. 'Standard Pit'<br>5. Then select the events on which this macro is triggered<br>7. Click OK <br>8. Run 'Initialize Maps'<br><br>The Event Pad is now set<br> ; minWidth=90 ; 
[r:bot_setEventPad()]

@@Set Light Source
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=75 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>The power of this button is that you can apply it to multiple tokens at once.<br>Select all tokens you want to set the light for before you hit this button.<br>You can set light sources to exclude in the settings.<br><b>Make sure that no lightsource in the campaign setting contains a comma: , </b></html> ; minWidth=90 ; 
[r:bot_setLightSource()]

@@Set Reference
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=75 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This macro is used to setup the <b>Shadow pads.</b><br> To sync the movement of the shadow token to the real token two reference tokens are required.<br> <br> To set this up do the following:<br> 1. create two tokens with the same name where one has the suffix &#39 ; minWidth=90 ; 
[h:bot_setReference()]

@@Set Roof
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=11pt ; sortBy=80 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>Here you can give a list of 'entry doors' through which a token can<br>enter the building. Note that these doors MUST be on the edge of the<br>roof (like real doors). If you leave this list empty, a token can move<br>anywhere on or over the 'roof' token</html> ; minWidth=90 ; 
[r:bot_setRoof()]

@@Set Token Size
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=76 ; color=green ; playerEditable=false ; applyToSelected=true ; group=(drag to) Campaign Macros ; tooltip=<html>This macro is usufull is you want to use Alt Init Pads macro to initialize a map.<br>With this macro you can pre-set the size of a token. So you won't be asked <br>for it when you run alt. init. maps.<br>Note that you only need to do this for free size tokens ; minWidth=90 ; 
[h,macro("setTokSize@lib:OnTokenMove"):""]

@@Set VBL Stamp
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=122 ; color=black ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This function applies a VBL (Vision Blocking Layer) upon a token. The VBL will move with the token as you move it. ; minWidth=90 ; 
[h,macro("setVBLStamp@lib:OnTokenMove"):""]

@@Settings
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=11pt ; sortBy=5 ; color=yellow ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip= ; minWidth=90 ; 
[r:bot_settings()]

@@Show Handout
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=79 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html> Pops up a dialog showing the handout of the selected token on all selected clients ; minWidth=90 ; 
[h,macro("showHandout@lib:OnTokenMove"):""]

@@Spread Group
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=93 ; color=maroon ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=Select one token of a group and spread the other tokens with an offset of X=1 and Y=1 ; minWidth=90 ; 
[h:bot_spreadGroup()]

@@Square Formation
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=100 ; color=maroon ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=Select one token of a group and put them in formation ; minWidth=90 ; 
[h:bot_formationSquare()]

@@StaggerFormation
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=99 ; color=maroon ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=Select one token of a group and put them in formation ; minWidth=90 ; 
[h:bot_formationStagger()]

@@Summon Token
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=23 ; color=blue ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>With this macro you can summon any token from the BASE map that is on the TOKEN layer.<br>If you select a token first before you click this button then the to-summon-token(s) will be<br>placed on the selected token. Else you can enter x and y coordinates of where you want to summon<br>the token. The types of tokens listed in the Dialog can be specified through the settings.</html> ; minWidth=90 ; 
[r:bot_summonToken()]

@@Switch Map
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=78 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html> Forces ALL clients to chosen map AND centres view on the token <i>centreOnMePad</i> <br><br>If you select tokens before you use this macro, then the option will be added to move<br>the selected tokens to the new map as well. These tokens will be placed near the <i>centreOnMePad</i><br><br>If there is no <i>centreOnMePad</i> then the coords (X,Y) 0,0 will be used instead. ; minWidth=90 ; 
[h,macro("switchMap@lib:OnTokenMove"):""]

@@Toggle Door
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=7 ; color=blue ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=Select a door (that has been initialized) and click this button to open or close it ; minWidth=90 ; 
[r:bot_toggleDoor()]

@@Toggle Door<b>s</b>
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=black ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This will show a pop-up with all the initialized doors<br>on the OBJECT LAYER. Here you can select which to open/close ; minWidth=90 ; 
[r:bot_toggleDoors()]

@@Toggle EventMove
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=900 ; color=red ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This will disable/enable the onTokenMoveEvent macros.<br>The onTokenMoveEvent can be demanding for every move<br>a token makes, especially when creating a map this can be<br>annoying. By clicking on this button you can temporarily<br>disable the event. Clicking it again will turn it on again.</html> ; minWidth=90 ; 
[r,macro("toggleOnTokenMove@lib:OnTokenMove"):""]

@@Toggle Full Screen
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=901 ; color=red ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>When toggled, the frames will be changed into dialogs,<br> which ARE allowed in full screen. This way when you<br> toggle this button you can have acces to chat and macros<br> in the form of dialogs.<br> In addition, when you have turned on the <i>redefine broadcast</i><br> setting in the settings, then when using the broadcast() function<br> a dialog will pop up showing the last message broadcasted. ; minWidth=90 ; 
[h,macro("toggleFullScreen@lib:OnTokenMove"):""]

@@Toggle Lock
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=11 ; color=blue ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=Select a door (that has been initialized) and click this button to open or close it ; minWidth=90 ; 
[r:bot_toggleLock()]

@@Toggle Mass VBL
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=122 ; color=black ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>With this function you can toggle saved mass VBL structures (set with Mass VBL macro) on and off ; minWidth=90 ; 
[h,macro("toggleMassVBL@lib:OnTokenMove"):""]

@@Toggle Special
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=73 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This macro toggles Canopy, <br>Foliage or Roofs on or off. <br>This also resets the tokens. ; minWidth=90 ; 
[r:bot_toggleSpecial()]

@@Undo Del. Macros
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=11pt ; sortBy=82 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html> If you deleted macros on the selected token using the Copy/Del Macros function<br> AND you had <i>allow undo</i> turned on, then you can use this function to undo<br> that process </html> ; minWidth=90 ; 
[H: bot_undoDelMacros()]

@@Ungroup (Move)
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=102 ; color=maroon ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=Select one token from a group and use this macro to clear the ENTIRE group ; minWidth=90 ; 
[h:bot_clearGroup()]

@@Ungroup (Select)
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=114 ; color=aqua ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This ungroups a 'Select Group'. You only need to select one token of the group to ungroup the entire group ; minWidth=90 ; 
[h, macro("clearSelectGroup@Lib:OnTokenMove"):""]

@@Use Disguise
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=11pt ; sortBy=81 ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html> - Clicking the <i>Use Disguise</i> button will add the current token image to your disguise list.<br> - Changing your image and clicking the button again will add a new image to list.<br> OR<br> - Selecting <i>image:tokens</i> together with the token will add those images to the disguise<br>list of the token<br><br>- A list will be shown for all the possible images you have loaded.<br> - You have the option to Change or Delete an image from your list.<br> - On the lib file, if you click <i>autoDisguiseButton</i> a text box will appear with a token<br>property you can add to your Campaign Property token properties to automatically add the<br> <i>Use Disguise</i> button to tokens.</html> ; minWidth=90 ; 
[H: bot_useDisguise()]

@@VBL Grenade
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=122 ; color=black ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>Select one or more tokens, run macro, set radius (in grid cells) and ALL VBL in that radius around the selected tokens will be cleared.</html> ; minWidth=90 ; 
[h,macro("VBLGrenade@lib:OnTokenMove"):""]

@@Wedge Formation
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=95 ; color=maroon ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=Select one token of a group and put them in formation ; minWidth=90 ; 
[h:bot_formationWedge()]

@@Whisper Frame
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=11pt ; sortBy=80a ; color=green ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=<html>This opens a frame where you can send formatted text to specific players.<br> <u>Alternatively</u> you can send a message to <u>all</u> players as if you<br> impersonate the selected token, without actually needing to impersonate it.<br> <br> <b>Notes</b> <br> - you must either be the gm or own the selected token to do this.<br> - the impersonation ONLY works with <i>all players</i> check box <br>   selected. (So not when some or all the individual player checkboxes are<br>   selected!!)</html> ; minWidth=90 ; 
[h:bot_whisperFrame()]

@@codeChecker
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=default ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip= ; minWidth= ; 
[h:name		= "initializePads"]
[h:index	= getMacroIndexes(name, ",", "lib:ontokenmove")]
[h:macro	= getMacroProps(index, "json", "lib:ontokenmove")]
[h:taText	= am.test.reformatMacroOutput(macro,"lib:ontokenmove")]

[H:am.test.openFrame("lib:ontokenmove","Original code",taText)]

[H:taText	= replace(taText,"&","&amp;")]
[H:taText	= replace(taText,"\\\\","&#92;")]
[H:taText	= replace(taText,"/","&#47;")]
[H:taText	= replace(taText,"[\$]","&#36;")]
[H:taText	= replace(taText,'"','@42@')]

[H:taText	= replace(taText,'"','@42@')]
[H:taText	= replace(taText,"	","@43@")]
[H:taText	= replace(taText,"<!--","@44@")]
[H:taText	= replace(taText,"-->","@45@")]
[H:taText	= replace(taText,"<","&lt;")]

      
[h:regex	= "([(){}\\[\\];<>:,'\\n]|@42@|@43@|@44@|@45@|&lt;|if)+"]
[h:result	= strfind(taText, regex)]

[h:gutStr	= ""]
[h,count(getFindCount(result),""), CODE:{ 
	[tmp	= getGroup(result, roll.count+1, 0)]
	[gutStr	= gutStr + tmp]

}]

[H:gutStr	= replace(gutStr,'@42@', '"')]
[H:gutStr	= replace(gutStr,'@43@', '	')]
[H:gutStr	= replace(gutStr,'@44@', '<!-- ')]
[H:gutStr	= replace(gutStr,'@45@', ' -->')]
[H:gutStr	= replace(gutStr,'&lt;', '<')]

[H:am.test.openFrame("lib:ontokenmove","gut code", gutStr)]

ok

@@reset ALL props
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=901 ; color=red ; playerEditable=false ; applyToSelected=false ; group=(drag to) Campaign Macros ; tooltip=(copy to Campaign panel) ; minWidth=90 ; 
[r,macro("deleteProps@lib:OnTokenMove"):""]

@@Canopy
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=default ; playerEditable=false ; applyToSelected=false ; group=3. Pad Macros ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------------CANOPY------------------------------------------------->']
[h:canopyTriggered = movedOverToken(padName,lastPath)]
[h,if(json.contains(canopyTriggered,startingLocation) || json.contains(canopyTriggered,currentLocation)), CODE:{
	[switchToken(padName)]
	[inHouse = if(json.contains(canopyTriggered,currentLocation), 1, 0)]
['pause("inHouse","canopyTriggered","currentLocation","padName", "lastPath")']
	[r,macro("roofSwap@this"): json.append("", inHouse, tok, padName, 0)]
	[switchToken(tok)]
}; {}]

@@EventArea
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=yellow ; playerEditable=false ; applyToSelected=false ; group=3. Pad Macros ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------------------- EventArea --------------------------------------------------->']
<!-- ignore output, no new scope -->

<!-- NOTE THAT ALL OUTPUT IS IGNORED, SO THE ONLY WAY TO GET SOMETHING TO THE CHAT IS BY USING BROADCAST! -->
<!-- Routine for an EventArea, EventArea is only triggered when the test subject is moved on or over the area-->

[areaCoords			= json.get(thisMapAreas, areaName)]
[intersectPath		= json.intersection(ignoreStartPath,areaCoords)]
[eventPadTriggered	= json.intersection(lastPath,areaCoords)]
[diffCount			= json.length(intersectPath)*DpC]
[if(!json.isEmpty(eventPadTriggered)), CODE:{ 

	[if(json.contains(thisMapLinks, areaName)):		strPropVars = json.get(thisMapLinks, areaName); strPropVars = ""]
	<!-- define:  "eventMacro, eventTriggerList" -->
	[if(strPropVars != ""), CODE: {
		[varsFromStrProp(strPropVars)]
	}; {
		[eventMacro = ""]
		[eventTriggerList = ""]
	}]

	[eventType		= bot_getEventType()]
	[triggered		= listContains(eventTriggerList, eventType)]
	[if(triggered),CODE:{
		[args			= json.append("", tok, eventType, areaName, lastPath, eventPadTriggered, 'area' , diffCount)]
		[macro(eventMacro+"@Lib:EventMacros"): args]
	}; {
		[macro.return = ""]
	}]
}]

@@EventPad
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=default ; playerEditable=false ; applyToSelected=false ; group=3. Pad Macros ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------------------- EventPad --------------------------------------------------->']
<!-- NOTE THAT ALL OUTPUT IS IGNORED, SO THE ONLY WAY TO GET SOMETHING TO THE CHAT IS BY USING BROADCAST! -->
<!-- Routine for an EventPad, EventPad is only triggered when the test subject is moved on or over the Eventtoken-->
[h: eventPadTriggered = movedOverToken(padName,lastPath)]
[h, if(!json.isEmpty(eventPadTriggered)), CODE:{
	<!-- check which event type this token triggers this can be 
	- movedOn 
	- movedOff 
	- movedOver 
	- movedNot		when you move the token but place it back on its original spot
	- movedReturn	when you move the token AND use way points AND leave the token but end the move onto the token
	- movedRemain	when you move but remain on the token during the entire move 
	- movedWard		(1001)	when you move the token over or onto a Ward -->
	[h:eventTypeList	= getProperty("w42.bot.eventTypeList", padName)]
	[h:eventType		= bot_getEventType()]
	[h:triggered		= listContains(eventTypeList, eventType)]
	<!-- With the use of the campaign macro you can set the name of the macro that should be called when the event is triggered-->
	[h,if(triggered),CODE:{
		[h:macroName = getProperty("w42.bot.macroName", padName)]
		[h:args = json.append("", tok, eventType, padName, lastPath, eventPadTriggered, 'pad')]
		[h,macro(macroName+"@Lib:EventMacros"): args]
	}; {
		[h:macro.return=""]
	}]
}; {}]

@@Foliage
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9b ; color=default ; playerEditable=false ; applyToSelected=false ; group=3. Pad Macros ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------------ FOLIAGE ------------------------------------------------->']
[h:foliageTriggered = movedOverToken(padName,lastPath)]
[h,if(!json.isEmpty(foliageTriggered)), CODE:{
	[switchToken(padName)]
	[inHouse = if(json.contains(foliageTriggered,currentLocation), 1, 0)]
	['foliageSwap(inHouse, tok, padName)']

	[args = json.append("", inHouse, tok, padName, 0)]
	[macro("roofSwap@this"): args]
	[switchToken(tok)]
}; {}]

@@InterJump
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=default ; playerEditable=false ; applyToSelected=false ; group=3. Pad Macros ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------------ InterJump ------------------------------------------------->']
[h:teleporterTriggered = movedOverToken(padName,lastPath)]
[h,if(json.contains(teleporterTriggered,currentLocation)), CODE:{
	[bot_mapTeleport(strPropFromVars("tok, padName, doAbort, eventMacroPreInterTeleport, eventMacroPostInterTeleport,doScaleTeleport,doSwitchInterMap", "UNSUFFIXED"))]
}; {}]

@@InterJumpBorder
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=default ; playerEditable=false ; applyToSelected=false ; group=3. Pad Macros ; tooltip= ; minWidth=90 ; 
[h:'<!-- ---------------------------------------- InterJumpBorder ------------------------------------------------->']
[h:teleporterTriggered = movedOverToken(padName,lastPath)]
[h,if(!json.isEmpty(teleporterTriggered)), CODE:{
	[bot_mapTeleport(strPropFromVars("tok, padName, doAbort, eventMacroPreInterTeleport, eventMacroPostInterTeleport,doScaleTeleport,doSwitchInterMap", "UNSUFFIXED"))]
}; {}]

@@InterPad
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=default ; playerEditable=false ; applyToSelected=false ; group=3. Pad Macros ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------------INTERPAD------------------------------------------------->']
[h:teleporterTriggered = movedOverToken(padName,lastPath)]
[h,if(json.contains(teleporterTriggered,currentLocation)), CODE:{
	[bot_mapTeleport(strPropFromVars("tok, padName, doAbort, eventMacroPreInterTeleport, eventMacroPostInterTeleport,doScaleTeleport,doSwitchInterMap", "UNSUFFIXED"))]
}; {}]

@@InterPadBorder
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=default ; playerEditable=false ; applyToSelected=false ; group=3. Pad Macros ; tooltip= ; minWidth=90 ; 
[h:'<!-- ---------------------------------------- InterPadBorder ------------------------------------------------->']
[h:teleporterTriggered = movedOverToken(padName,lastPath)]
[h,if(!json.isEmpty(teleporterTriggered)), CODE:{
	[bot_mapTeleport(strPropFromVars("tok, padName, doAbort, eventMacroPreInterTeleport, eventMacroPostInterTeleport,doScaleTeleport,doSwitchInterMap", "UNSUFFIXED"))]
}; {}]

@@Linked
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=10 ; color=default ; playerEditable=false ; applyToSelected=false ; group=3. Pad Macros ; tooltip= ; minWidth=90 ; 
[h:'<!-- ---------------------------------------- LINKED ----------------------------------------------- -->']
<!-- @@ 3 CODE LEVELS -->

<!-- abort if moving on or over the pad -->
[linkedTriggered	= movedOverToken(padName,lastPath)]
[h:startOnPad		= if(json.contains(linkedTriggered,startingLocation), 1, 0)]
[h:endOnPad			= if(json.contains(linkedTriggered,currentLocation),  1, 0)]
<!-- "Linked 1 Roof 2" == "Match1 Match2 Match3 Match4" -->
[h:linkId			= getGroup(strfind(padName, "[^\\s]+"), 2, 0)]
[h:startLinkId		= if(startOnPad, linkId, startLinkId)]
[h:endLinkId		= if(endOnPad, linkId, endLinkId)]

['pause("linkedTriggered","startOnPad","endOnPad","linkId","lastLinkId","startLinkId","endLinkId")']

[h,if(!json.isEmpty(linkedTriggered) && startOnPad != endOnPad), CODE:{
	<!-- first check if you know what the end pad is and if not, figure it out. This is needed to make the right decision -->
	<!-- do NOT switchToken before movedOverToken as it then does NOT work. -->
	[if(startOnPad && endLinkId == ""), CODE:{
		[linkedAll		= getProperty("w42.bot.linked", padName)]
		[foreach(pad, linkedAll), CODE:{
			[tlinkedTriggered	= movedOverToken(pad,lastPath)]
			[endLinkId			= if(json.contains(tlinkedTriggered,currentLocation),  linkId, endLinkId)]
		''
		}]
	''
	};{}]
	
	<!-- if endLinkId remains empty then you moved OF the linked pads. If endlinkId == lastLinkId (it *can* have a different id) then you remained and nothing should be done. -->
	[if(endLinkID != lastLinkId), CODE:{
		[switchToken(padName)]
		[linkedBridge	= getProperty("w42.bot.linkedBridge")]
		[linkedTunnel	= getProperty("w42.bot.linkedTunnel")]
		[linkedSpecial	= lower(getProperty("w42.bot.linkedSpecial"))]
		<!-- If you ALSO moved over a "Bridge" token then do NOT activate -->
		[overBridge	= 0]
		[foreach(pad, linkedBridge):overBridge	= max(overBridge, !json.isEmpty(movedOverToken(pad,lastPath)))]

		<!-- If tunnels are linked ONLY activate the roof if moved over a tunnel -->
		[overTunnel	= if(listCount(linkedTunnel), 0, 1)]
		[foreach(pad, linkedTunnel):overTunnel	= max(overTunnel, !json.isEmpty(movedOverToken(pad,lastPath)))]
		
		<!-- if you move OFF a roof that is linked to a e.g. Canopy where you move ON to then the roof is handled last and all tokens are deactivated. To prevent this keep track of activation -->
		['activated	= max(   eval("activated"+linkId),min(!overBridge, overTunnel, endOnPad )   )']
		['set("activated"+linkId, activated)']

		[activate	= min(!overBridge, overTunnel, endOnPad)]

		<!-- execute all linked special pads -->
		[foreach(pad, linkedSpecial):bot_roofSwap(activate, tok, pad, if(bot_inStr(pad, "roof"),1,0), roofHaloColor)]
		
		['pause("linkedTriggered","startOnPad","endOnPad","linkId","lastLinkId","startLinkId","endLinkId","lastPath","padName","tok","pathPadList","linkedAll","linkedPads", "overBridge","overTunnel")']
		[switchToken(tok)]
	}]
	
''
}; {}]

@@MappedPad
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=default ; playerEditable=false ; applyToSelected=false ; group=3. Pad Macros ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------------ MappedPad ------------------------------------------------->']
[h:teleporterTriggered = movedOverToken(padName,lastPath)]
[h,if(json.contains(teleporterTriggered,currentLocation)), CODE:{
	[iMapped = eval(string(getProperty("w42.bot.MappedPad", padName)))]
	[teleportEndName = "MappedPad " + iMapped)]

	[Token(padName): 			startCentreX	= getTokenX(1)]
	[Token(padName): 			startCentreY	= getTokenY(1)]
	[Token(teleportEndName): 	endCentreX		= getTokenX(1)]
	[Token(teleportEndName): 	endCentreY		= getTokenY(1)]

	[bot_teleport(strPropFromVars("tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport", "UNSUFFIXED"))]
	[goto(tok)]
}; {}]

@@PadEnd
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=default ; playerEditable=false ; applyToSelected=false ; group=3. Pad Macros ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------------- TELEPORTS END ------------------------------------------------->']
[h:teleporterTriggered = movedOverToken(padName,lastPath)]
[h,if(json.contains(teleporterTriggered,currentLocation)), CODE:{
	[teleportEndName = replace(padName, "End", "Start")]
	[Token(padName): 			startCentreX	= getTokenX(1)]
	[Token(padName): 			startCentreY	= getTokenY(1)]
	[Token(teleportEndName): 	endCentreX		= getTokenX(1)]
	[Token(teleportEndName): 	endCentreY		= getTokenY(1)]

	[bot_teleport(strPropFromVars("tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport", "UNSUFFIXED"))]
	[goto(tok)]
}; {}]

@@PadEndBorder
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=default ; playerEditable=false ; applyToSelected=false ; group=3. Pad Macros ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------------- PadEndBorder ------------------------------------------------->']
[h:teleporterTriggered = movedOverToken(padName,lastPath)]
[h,if(!json.isEmpty(teleporterTriggered)), CODE:{
	[teleportEndName = replace(padName, "End", "Start")]
	[Token(padName): 			startCentreX	= getTokenX(1)]
	[Token(padName): 			startCentreY	= getTokenY(1)]
	[Token(teleportEndName): 	endCentreX		= getTokenX(1)]
	[Token(teleportEndName): 	endCentreY		= getTokenY(1)]

	[bot_teleport(strPropFromVars("tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport", "UNSUFFIXED"))]
	[goto(tok)]
}; {}]

@@PadJump
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=default ; playerEditable=false ; applyToSelected=false ; group=3. Pad Macros ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------------- PadJump ------------------------------------------------->']
[h:teleporterTriggered = movedOverToken(padName,lastPath)]
[h,if(json.contains(teleporterTriggered,currentLocation)), CODE:{
	[teleportEndName = replace(padName, "Jump", "Drop")]
	[Token(padName): 			startCentreX	= getTokenX(1)]
	[Token(padName): 			startCentreY	= getTokenY(1)]
	[Token(teleportEndName): 	endCentreX		= getTokenX(1)]
	[Token(teleportEndName): 	endCentreY		= getTokenY(1)]

	[bot_teleport(strPropFromVars("tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport", "UNSUFFIXED"))]
	[goto(tok)]
}; {}]

@@PadJumpBorder
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=default ; playerEditable=false ; applyToSelected=false ; group=3. Pad Macros ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------------- PadJumpBorder ------------------------------------------------->']
[h:teleporterTriggered = movedOverToken(padName,lastPath)]
[h,if(!json.isEmpty(teleporterTriggered)), CODE:{
	[teleportEndName = replace(padName, "Jump", "Drop")]
	[Token(padName): 			startCentreX	= getTokenX(1)]
	[Token(padName): 			startCentreY	= getTokenY(1)]
	[Token(teleportEndName): 	endCentreX		= getTokenX(1)]
	[Token(teleportEndName): 	endCentreY		= getTokenY(1)]

	[bot_teleport(strPropFromVars("tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport", "UNSUFFIXED"))]
	[goto(tok)]
}; {}]

@@PadStart
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=default ; playerEditable=false ; applyToSelected=false ; group=3. Pad Macros ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------------- TELEPORTS START ------------------------------------------------->']
[h:teleporterTriggered = movedOverToken(padName,lastPath)]
[h,if(json.contains(teleporterTriggered,currentLocation)), CODE:{
	[teleportEndName = replace(padName, "Start", "End")]
	[Token(padName): 			startCentreX	= getTokenX(1)]
	[Token(padName): 			startCentreY	= getTokenY(1)]
	[Token(teleportEndName): 	endCentreX		= getTokenX(1)]
	[Token(teleportEndName): 	endCentreY		= getTokenY(1)]

	[bot_teleport(strPropFromVars("tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport", "UNSUFFIXED"))]
	[goto(tok)]
}; {}]

@@PadStartBorder
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=default ; playerEditable=false ; applyToSelected=false ; group=3. Pad Macros ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------------- PadStartBorder ------------------------------------------------->']
[h:teleporterTriggered = movedOverToken(padName,lastPath)]
[h,if(!json.isEmpty(teleporterTriggered)), CODE:{
	[teleportEndName = replace(padName, "Start", "End")]
	[Token(padName): 			startCentreX	= getTokenX(1)]
	[Token(padName): 			startCentreY	= getTokenY(1)]

	[Token(teleportEndName): 	endCentreX		= getTokenX(1)]
	[Token(teleportEndName): 	endCentreY		= getTokenY(1)]

	[bot_teleport(strPropFromVars("tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport", "UNSUFFIXED"))]
	[goto(tok)]
}; {}]

@@Roof
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=default ; playerEditable=false ; applyToSelected=false ; group=3. Pad Macros ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------------ROOF------------------------------------------------->']
[h:roofTriggered = movedOverToken(padName,lastPath)]
<!-- abort if moving inside the building OR moved over the building -->
[h: startInHouse	= if(json.contains(roofTriggered,startingLocation), 1, 0)]
[h: endInHouse		= if(json.contains(roofTriggered,currentLocation),  1, 0)]
[h: continue		= if(startInHouse == endInHouse, 0, 1)]

[h,if(!json.isEmpty(roofTriggered) && continue), CODE:{
	<!-- if doors are linked to the roof you can only enter the building through the door (if its open) -->
	[Doors = getProperty("w42.bot.Doors", padName)]
	[wentThroughDoor = if(listCount(Doors), 0,1)]
	[doorClosed = 0]
	[foreach(door, Doors), CODE:{
			[doorTriggered	= movedOverToken(door,lastPath)]
			[if(!json.isEmpty(doorTriggered)): wentThroughDoor = 1]
			[isClosed = if(getProperty("closedAngle", door) == bot_getTokenFacing(door), 1, 0)]
			[if(isClosed && wentThroughDoor): doorClosed = 1]
	}]
	[switchToken(padName)]
	['pause("Doors","wentThroughDoor","doorTriggered","lastPath","roofTriggered", "startInHouse", "continue")']
	[if(!isGM() && (!wentThroughDoor || doorClosed)),CODE:{
		[if(startInHouse)	: iEntryPoint = json.length(roofTriggered)-1; iEntryPoint = json.indexOf (lastPath, json.get(roofTriggered, 0))-1]
		[edgePoint		= json.get(lastPath, iEntryPoint)]
		[lastPath		= json.get(lastPath, 0, iEntryPoint)]
		[x 				= json.get(edgePoint, "x")]
		[y				= json.get(edgePoint, "y")]
		['pause("roofTriggered", "doorTriggered", "lastPath", "entryMod", "iEntryPoint","edgePoint","x","y", "startInHouse")']
		[moveToken(x, y, 1, tok)]
		[if(doorClosed):
			broadcast("You need to open the door first, before you can "+if(startInHouse,"exit","enter")+" the building")
		; 
			broadcast("You can only "+if(startInHouse,"exit","enter")+" this building through (one of) the door(s)")
		]
		[continue = 0]
	}; {}]		
	
	<!-- ROOFSWAP (inHouse, me, roofName, showHale) -->
	[if(continue): bot_roofSwap(endInHouse, tok, padName, 1, roofHaloColor)]
	[switchToken(tok)]
}; {}]

@@ShadowPad
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=11 ; color=default ; playerEditable=false ; applyToSelected=false ; group=3. Pad Macros ; tooltip= ; minWidth=90 ; 
[h:'<!----------------------------- ShadowPad -------------------------------->']
[h:eventPadTriggered = movedOverToken(padName,lastPath)]
[h,if(!json.isEmpty(eventPadTriggered)), CODE:{
	[event	= 	bot_getEventType()]
	[bot_doShadowPad(tok, event, padName)]
}]

@@Ward
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=default ; playerEditable=false ; applyToSelected=false ; group=3. Pad Macros ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------WARDED AREAS E.G. BARBED WIRE ON THE BASE MAP------------------------------->']
[h:wardedPadTriggered = movedOverToken(padName,lastPath)]
[h, if(!json.isEmpty(wardedPadTriggered)), CODE:{
	[entryPoint = json.get(wardedPadTriggered, 0)]
	[iEntryPoint = json.indexOf (lastPath, entryPoint)]
	[edgePoint =  json.get(lastPath, iEntryPoint-1)]
	[lastPath =  json.get(lastPath, 0, iEntryPoint-1)]
	
	[x = json.get(edgePoint, "x")]
	[y = json.get(edgePoint, "y")]
	[moveToken(x, y)]

	[broadcast("This area is warded, you are not allowed to move there")]
}; {}]

@@Clear Messages
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=11pt ; sortBy=20 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Plothos Message Manager ; tooltip= ; minWidth=90 ; 
[h:abort(input(
	"junkvar|Make sure you want to do this.|This action will erase ALL messages you have readied|label",
	"checkvar|No, Yes|Proceed?|radio|"
))]
[h:abort(checkvar)]

[h,if(currentToken() == "" && getSelected() != ""): switchToken(getSelected())]
[h,if(currentToken() == ""): isNPC	= 1; isNPC	= isNPC()]
[h,if(isGM() && isNPC): target	= "Lib:EventMacros"; target	= currentToken()]
[h,if(isGM() && isNPC): setLibProperty("plothos.bot.messages","{}",target); setProperty("Messages","{}",target)]

[macro("notes@this"):""]

@@Create New Message
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=11pt ; sortBy=20 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Plothos Message Manager ; tooltip= ; minWidth=193 ; 
[h:abort(input(
	"label|Msg1|Enter a label (no spaces) for this message data|text|width=20",
	"title|Important Info|Enter the title of the message (for the player to see)|text|width=20",
	"text|You are not illiterate|Enter the message text here|text|width=50",
	"italic|0|<html><i>Italic|CHECK",
	"bold|0|<html><b>Bold|CHECK",
	"underline|0|<html><u>Underline|CHECK",
	"color|black, gray, maroon, red, yellow, green, blue, navy, purple|Color|LIST"
))]

[h,if(currentToken() == "" && getSelected() != ""): switchToken(getSelected())]
[h,if(currentToken() == ""): isNPC	= 1; isNPC	= isNPC()]
[h,if(isGM() && isNPC): target		= "Lib:EventMacros"				; target		= currentToken()]
[h,if(isGM() && isNPC): messages	= getLibProperty("plothos.bot.messages",target)	; messages	= getProperty("Messages",target)]

[h,if(json.type(messages)=="UNKNOWN"): messages	= "{}"]
[h:usedlabels		= json.fields(messages)]
[h:overwritecheck	= 0]
[h:done				= 0]
[h,while(!done),CODE:{
	[if(listFind(usedlabels,label) == -1),CODE:{
		[done		= 1]
	}; {
		[abort(input(
			"junkvar|Proceed How?|The label "+label+" already exists|label",
			"msglabel2|"+label+"(2)|Enter another name|text|width=20",
			"overwritecheck|0|Or check here to overwrite the previous message|check"
		))]
		[if(overwritecheck==1): done = 1; label = msglabel2]
	}]
}]

<!-- initialize unused vars -->
[h:picID		= ""]
[h:picSize		= 0]
[h:picPos		= -1]

[h:messageinfo	= json.fromStrProp(strPropFromVars("title, text, italic, bold, underline, color, picID, picSize, picPos","UNSUFFIXED"))]
[h:messages		= json.set(messages,label,messageinfo)]

[h,if(isGM() && isNPC): setLibProperty("plothos.bot.messages",messages,target); setProperty("Messages",messages,target)]
[macro("notes@this"):""]

@@Delete Message
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=11pt ; sortBy=20 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Plothos Message Manager ; tooltip= ; minWidth=90 ; 
[h:msglabel	= macro.args]

[h:abort(input(	"confpick|No, Yes|Confirm that you wish to delete "+msglabel+"|radio|" ))]

[h,if(confpick == 1), CODE:{
	 [h,if(currentToken() == "" && getSelected() != ""): switchToken(getSelected())]
	 [h,if(currentToken() == ""): isNPC	= 1; isNPC	= isNPC()]
	 [h,if(isGM() && isNPC): target	= "Lib:EventMacros"; target	= currentToken()]
	 [h,if(isGM() && isNPC): messages	= getLibProperty("plothos.bot.messages",target); messages	= getProperty("Messages",target)]
	 [h:messages	= json.remove(messages,msglabel)]
	 [h,if(isGM() && isNPC): setLibProperty("plothos.bot.messages",messages,target); setProperty("Messages",messages,target)]
}; {}]

[macro("notes@this"):""]

@@Edit Message
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=11pt ; sortBy=20 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Plothos Message Manager ; tooltip= ; minWidth=90 ; 
[h:debug=0]
[h:varsFromStrProp(macro.args)]
[h:msglabelbefore	= msglabel]

[h,if(currentToken() == "" && getSelected() != ""): switchToken(getSelected())]
[h,if(currentToken() == ""): isNPC	= 1; isNPC	= isNPC()]
[h,if(isGM() && isNPC): target	= "Lib:EventMacros"; target	= currentToken()]
[h,if(isGM() && isNPC): messages	= getLibProperty("plothos.bot.messages",target); messages	= getProperty("Messages",target)]
[h:colors			= "black, gray, maroon, red, yellow, green, blue, navy, purple"]

[h:messageinfo		= json.get(messages,msglabel)]
[h:varsFromStrProp(json.toStrProp(messageinfo))]
[h,if(addPic):	picID	= bot_showHandout(1)]

[h,if(picID != ""), CODE:{
	[toFind		= strfind(picID, "(.*)-(.*)")]
	[tmp	= getFindCount(toFind)]
	[if(getFindCount(toFind)), CODE:{
		[picID		= getGroup(toFind,1,1)]
		[picSize	= getGroup(toFind,1,2)]
	}]

	[imageStr	= "<html><table><tr><td>Yes</td><td height='100'><img width=90 height=90 src='"+picID+"'></img>	</td></tr></table></html>"]
	[showPic	= "picHide|"+imageStr+", No, Remove|Show picture|RADIO|ORIENT=H SELECT=0"]
	[showSize	= "picSize|"+picSize+"|Size of picture (px)"]
	[showPos	= "picPos|below text, above text|Where to show the picture|RADIO|ORIENT=H SELECT=0"]
};{
	[picID		= ""]
	[picSize	= 0]
	[picPos		= -1]
	[picHide	= 0]
	[showPic	= ""]
	[showSize	= ""]
	[showPos	= ""]
}]

[h:abort(input(
	"msglabel|"+msglabel+"|Label used to find this in the manager|text|width	= 20",
	"title|"+title+"|Title shown in the text frame the player will see|text|width	= 20",
	"text|"+text+"|Text of the message|text|width	= 100",
	"italic|"+italic+"|<html><i>Italic|CHECK|",
	"bold|"+bold+"|<html><b>Bold|CHECK",
	"underline|"+underline+"|<html><u>Underline|CHECK",
	"color|black, gray, maroon, red, yellow, green, blue, navy, purple|<html><font color='"+listGet(colors,color)+"'><b>Color</b></font></html>|LIST|SELECT="+color,
	showPic,
	showSize,
	showPos
))]
[h,if(debug): bot_debugInfo("addPic, picID, msglabel, picHide")]

[h,if(picHide), CODE:{
	[picPos	= -1]
	[if(picHide	== 2): picID = ""]
};{}]

[h:messageinfo	= json.fromStrProp(strPropFromVars("title, text, italic, bold, underline, color, picID, picSize, picPos","UNSUFFIXED"))]

[h,if(msglabel != msglabelbefore), CODE:{
	[abort(input(
		"junkvar|You may copy or delete the original one|You have changed the label and will create a new msg|label",
		"copypick|Delete Original, Keep Original|Do which?|radio|"
	))]
	[if(copypick == 0): messageinfo	= json.remove(messageinfo,msglabelbefore)]
}; {}]

[h:usedlabels	= json.fields(messageinfo)]
[h:done			= 0]

[h,while(!done), CODE:{
	[if(listFind(usedlabels,msglabel)==-1),CODE:{
		[done	= 1]
	}; {
		[abort(input(
			"junkvar|Proceed How?|The label "+msglabel+" already exists|label",
			"msglabel2|"+msglabel+"(2)|Enter another name|text|width=20",
			"overwritecheck|0|Or check here to overwrite the previous message|check"
		))]
		[if(overwritecheck==1): done = 1; msglabel = msglabel2]
	}]
}]

[h:messages	= json.set(messages,msglabel,messageinfo)]

[h,if(isGM() && isNPC): setLibProperty("plothos.bot.messages",messages,target); setProperty("Messages",messages,target)]
[macro("notes@this"):""]

@@Open Text Frame
@PROPS@ fontColor=black ; autoExecute=false ; fontSize=11pt ; sortBy=20 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Plothos Message Manager ; tooltip= ; minWidth=90 ; 
[h:msgpass	= macro.args]
[h:varsFromStrProp(json.toStrProp(msgpass))]
[h:colors	= "black, gray, maroon, red, yellow, green, blue, navy, purple"]

[frame(title):{
	<font size='+2'><b>[r:title]</b></font><br><br>
	[r,if(picPos == 1)	: strformat("<img width=%{picSize} height=%{picSize} src='%{picID}'></img><br>")]
	[r,if(italic)	: "<i>"]
	[r,if(bold)		: "<b>"]
	[r,if(underline): "<u>"]
	[r,if(color)	: "<font color="+listGet(colors, color)+">"]
	[r:text]
	[r,if(italic)	: "</i>"]
	[r,if(bold)		: "</b>"]
	[r,if(underline): "</u>"]
	[r,if(color)	: "</font>"]
	[r,if(picPos == 0)	: strformat("<br><img width=%{picSize} height=%{picSize} src='%{picID}'></img>")]
}]

@@Reset Messages
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=11pt ; sortBy=20 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Plothos Message Manager ; tooltip= ; minWidth=90 ; 
[h,if(currentToken() == "" && getSelected() != ""): switchToken(getSelected())]
[h,if(currentToken() == ""): isNPC	= 1; isNPC	= isNPC()]
[h,if(isGM() && isNPC): target	= "Lib:EventMacros"; target	= currentToken()]
[h,if(isGM() && isNPC): setLibProperty("plothos.bot.messages","{}",target); setProperty("Messages","{}",target)]

@@Send Prepped Text Starter
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=11pt ; sortBy=20 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Plothos Message Manager ; tooltip= ; minWidth=193 ; 
[h:playernames=listSort(getAllPlayerNames(),"A")]
[h,if(currentToken() == "" && getSelected() != ""): switchToken(getSelected())]
[h,if(currentToken() == ""): isNPC	= 1; isNPC	= isNPC()]
[h,if(isGM() && isNPC): target	= "Lib:EventMacros"; target	= currentToken()]
[h,if(isGM() && isNPC): messageinfo	= getLibProperty("plothos.bot.messages",target); messageinfo	= getProperty("Messages",target)]
[h,if(string(messageinfo)==""): messageinfo	= "{}"]
[h:usedlabels	= json.fields(messageinfo)]

[h:inptext="junkvar|Send text frame to whom?|Text can be sent to any player|label"]
[h,foreach(playername,playernames),CODE:{
	[inptext	= listAppend(inptext, "Player"+roll.count+"|0|"+playername+"|check", "##")]
	[num		= roll.count]
}]

[h:abort(input(
	inptext,
	"msgpick|"+usedlabels+"|Which message do you want to send?|list|select=0 value=string"
))]

[h:varvar=0]
[c(num+1,""), CODE: {
	[if(eval("Player"+varvar) == 1),CODE:{
		[h:playername	= listGet(playernames,varvar)]
		[macro("Send Prepped Text Wrap@this"):playername+","+msgpick]
	}; {}]
	[h:varvar	= varvar + 1]
}]

@@Send Prepped Text Wrap
@PROPS@ fontColor=black ; autoExecute=false ; fontSize=11pt ; sortBy=20 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Plothos Message Manager ; tooltip= ; minWidth=193 ; 
[h:passed		= macro.args]
[h:playername	= listGet(passed,0)]
[h:msgpick		= listGet(passed,1)]

[h,if(currentToken() == "" && getSelected() != ""): switchToken(getSelected())]
[h,if(currentToken() == ""): isNPC	= 1; isNPC	= isNPC()]
[h,if(isGM() && isNPC): target	= "Lib:EventMacros"; target	= currentToken()]
[h,if(isGM() && isNPC): messageinfo	= getLibProperty("plothos.bot.messages",target); messageinfo	= getProperty("Messages",target)]
[h:indivmsginfo	= json.get(messageinfo,msgpick)]

[r,w(playername): "The GM has info for you. Click "+macroLink("here","Open Text Frame@this","none",indivmsginfo,target)+" to review it."]

@@View Messages Text
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=11pt ; sortBy=20 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Plothos Message Manager ; tooltip= ; minWidth=193 ; 
[h:fullview	= macro.args]
[h,if(currentToken() == "" && getSelected() != ""): switchToken(getSelected())]
[h,if(currentToken() == ""): isNPC	= 1; isNPC	= isNPC()]
[h,if(isGM() && isNPC): target	= "Lib:EventMacros"; target	= currentToken()]
[h,if(isGM() && isNPC): messageinfo	= getLibProperty("plothos.bot.messages",target); messageinfo	= getProperty("Messages",target)]
[h,if(target == currentToken()): tokenImg	= getTokenImage(); tokenImg	= getImage(target)]
[h:output	= strformat(
	"<table><tr valign=top><td><img src='%{tokenImg}-50' /></td><td><font size='+2'><b>Message Manager</b></font><br>%s -- %s</td></tr></table><br>",
	 macroLink("Add Message","Create New Message@this","none","",target),
	 macroLink("Delete All","Clear Messages@this","none","",target)
)]

[h,if(string(messageinfo) == ""): messageinfo	= "{}"]
[h:messagelabels	= json.fields(messageinfo)]
[h,if(messagelabels == ""): output	= output + "(No messages saved)"]
[h:messagelabels	= listSort(messagelabels, "A")]

[h:messages	= ""]
[h,foreach(label,messagelabels),CODE:{
	 [indivmsginfo	= json.get(messageinfo,label)]
	 [msgtext		= json.get(indivmsginfo, "text")]
	 [messages		= listAppend(messages,
			"<b>("+label+"):</b><font size='-2'> -- "
			+macrolink("Send This","Send Prepped Text From Menu@this","all",label,target)						+" -- "
			+macroLink("Edit This", "Edit Message@this","none",strformat("msglabel=%{label};addPic=0"),target)	+" -- "
			+macroLink("Delete This","Delete Message@this","none",label,target)									+" -- "
			+macroLink("Add Selected Picture","Edit Message@this","none",strformat("msglabel=%{label};addPic=1"),target)	+"</font><br>"
			+"<b>"+json.get(indivmsginfo, "title")+":</b> ","<br><br>")
	]
	[if(label != fullview), CODE: { 
			[h,if(length(msgtext) >150): 
				messages	= messages + substring(msgtext,0,100)+"... <font size='-2'>"+macroLink("View Full","notes@this","none",label,target)+"</font>"
			; 
				messages	= messages + msgtext
			]
	 }; {
			[h:messages		= messages + msgtext + "<font size='-2'>" + macroLink("Shorten","notes@this","none","",target) + "</font>"]
	 }]
}]
[R: output + messages]

@@notes
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=11pt ; sortBy=0 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Plothos Message Manager ; tooltip=<html> This macro allows you to store prepared messages and manage these.<br> For GM's these will be store on lib:EventMacros, for players these will <br> be stored on the token that they own (and is selected). <br> To add a picture to a message: <br> - create the message (and save it). <br> - select the token that contains the image (can be token,portrait or handout).<br> - click 'add selected image' for that message. The rest should be simple.<br> </html> ; minWidth=90 ; 
[h:'<!-- -------------------------------- NOTES ------------------------------------------- -->']
<!-- 
<html>
This macro allows you to store prepared messages and manage these.<br>
For GM's these will be store on lib:EventMacros, for players these will <br>
be stored on the token that they own (and is selected). <br>
To add a picture to a message: <br>
- create the message (and save it). <br>
- select the token that contains the image (can be token,portrait or handout).<br>
- click 'add selected image' for that message. The rest should be simple.<br>
</html>
-->
[h:fullview	= macro.args]

[frame("Messages"):{
	[macro("View Messages Text@this"):fullview]
}]

@@HTMLMacroButton
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=11pt ; sortBy=3 ; color=default ; playerEditable=false ; applyToSelected=false ; group=1. Macro Frame ; tooltip= ; minWidth=193 ; 
[h:bgColor	= arg(1)]
[h,if(argCount() > 5): shadow = arg(5); shadow = "")]
[h,if(argCount() > 6): toolTip = arg(6); toolTip = "")]
[h,if(argCount() > 7): args = arg(7); args = "[]")]
[h,if(argCount() > 8): libType = arg(8); libType = "@this")]
[h,if(argCount() > 9): output = arg(9); output = "none")]

[h:btnformat	= strformat("padding:1px; border-width:1pt; border-style:solid; border-color:black; text-align:center; white-space:nowrap; background-image:url(%{shadow}); background-color:%{bgColor};")]
 
<td width='[r:arg(0)]%'>
	<table width="100%" cellpadding='0' cellspacing='0'>
		<tr>
			<td style='[r:btnformat]'>
				<span title='[r:toolTip]' style='text-decoration:none; color:[r:arg(2)]'>
					[r:macroLink(arg(3),arg(4)+libType,output,args)]
				</span>
			</td>
		</tr>
	</table>
</td>

@@HTMLMacroButton BCK
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=11pt ; sortBy=99 ; color=silver ; playerEditable=false ; applyToSelected=false ; group=1. Macro Frame ; tooltip= ; minWidth=193 ; 
[h,if(argCount() > 5): shadow = arg(5); shadow = "")]
[h,if(argCount() > 6): toolTip = arg(6); toolTip = "")]
[h,if(argCount() > 7): args = arg(7); args = "[]")]
[h,if(argCount() > 8): libType = arg(8); libType = "@this")]
[h,if(argCount() > 9): output = arg(9); output = "none")]

<td width='[r:arg(0)]%'><table width=100% bgcolor='black' cellpadding='1' cellspacing='0'><table width=100% bgcolor='[r:arg(1)]'><td align='center' style="background-image:url([r:shadow]); " ><span title='[r:toolTip]' style='text-decoration:none; color:[r:arg(2)]'>[r:macroLink(arg(3),arg(4)+libType,output,args)]</span></td></table></table></td>

@@HTMLMacroImageButton
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=11pt ; sortBy=3 ; color=default ; playerEditable=false ; applyToSelected=false ; group=1. Macro Frame ; tooltip= ; minWidth=193 ; 
[h,if(argCount() > 5): shadow = arg(5); shadow = "")]
[h,if(argCount() > 6): toolTip = arg(6); toolTip = "")]
[h,if(argCount() > 7): args = arg(7); args = "[]")]
[h,if(argCount() > 8): libType = arg(8); libType = "@this")]
[h,if(argCount() > 9): output = arg(9); output = "none")]
[h:shownImage = strformat("<img src='%s' border='0' height='30' width='30' alt='%{toolTip}'/>",arg(3))]

<td width='[r:arg(0)]%'>
		<table bgcolor='[r:arg(1)]'>
			<td align='center' style="background-image:url([r:shadow]); " >
				<span title='[r:toolTip]' style='text-decoration:none; color:[r:arg(2)]'>[r:macroLink(shownImage,arg(4)+libType,output,args)]</span>
			</td>
		</table>
</td>

@@MacroButtonsGroupMove
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=11pt ; sortBy=2 ; color=maroon ; playerEditable=false ; applyToSelected=false ; group=1. Macro Frame ; tooltip= ; minWidth=193 ; 
[h:'<!-- MacroButtonsGroupMove  -->']

[if(bot_isFullScreen()), CODE:{
	[dialog("Group Move Macros", "width=100; height=310; temporary=1; input=1"): {
		[r:bot_createMacroButtonsGroupMove()]
	}]
};{
	[frame("Group Move Macros", "width=100; height=310; temporary=1"): {
		[r:bot_createMacroButtonsGroupMove()]
	}]
}]

@@MacroButtonsOTMSetup
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=11pt ; sortBy=0 ; color=black ; playerEditable=false ; applyToSelected=false ; group=1. Macro Frame ; tooltip= ; minWidth=193 ; 
[h:'<!-- MacroButtonsOTMSetup  -->']

[if(bot_isFullScreen()), CODE:{
	[dialog("Bag Of Tricks Macros", "width=215; height=700; temporary=0; input=1"): {
		[r:bot_createMacroButtonsOTMSetup()]
	}]
};{
	[frame("Bag Of Tricks Macros", "width=215; height=700; temporary=0"): {
		[r:bot_createMacroButtonsOTMSetup()]
	}]
}]

@@MacroButtonsOTMUtils
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=11pt ; sortBy=0 ; color=black ; playerEditable=false ; applyToSelected=false ; group=1. Macro Frame ; tooltip= ; minWidth=193 ; 
[h:'<!-- MacroButtonsOTMUtils  -->']

[if(bot_isFullScreen()), CODE:{
	[dialog("Bag Of Tricks Macros", "width=215; height=700; temporary=0; input=1"): {
		[r:bot_createMacroButtonsOTMUtils()]
	}]
};{
	[frame("Bag Of Tricks Macros", "width=215; height=700; temporary=0"): {
		[r:bot_createMacroButtonsOTMUtils()]
	}]
}]

@@createMacroButtonsGroupMove
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=11pt ; sortBy=3 ; color=maroon ; playerEditable=false ; applyToSelected=false ; group=1. Macro Frame ; tooltip= ; minWidth=193 ; 
[h:'<!-- createMacroButtonsGroupMove -->']

[h:'<!-- bot_HTMLMacroImageButton(cellWidth, cellColor, textColor, text, macroName, shadow, toolTip, arguments, macro location, output to) -->']

[h:bColor		='#e5e5cc']

[h: out 		= '#BDBDFF']
[h: in 			= '#9595FF']
[h: inner 		= '#0000FF']
[h: innerOFF	= '#8888FF']
[h: font 		= 'Yellow']

[h:assert(if(listContains(json.toList(json.get(getInfo("campaign"),"tables")), "tbl_Image"),1,0), "You will need to install the Bag of Tricks Image Tables first before you can use this option. See the how to install on the the forum",0)]
[h: shadow = tblImage("tbl_Image",2)]

[h: macroGroup	=	"<table width=100% cellpadding=0 cellspacing='0' color='white' bgcolor='black'><td align=center><b>%{groupTitle}</b></td></table>" + 
					"<table width=100% cellpadding=1 cellspacing='0' bgcolor='black'>" +
					"<table width=100% cellpadding=2 cellspacing='0' bgcolor='%{bColor}'>" +
					"<table width=100%><tr>"
]
[h: macroNewLine  = "</tr></table><table width=100%><tr>"]
[h: macroGroupEnd = "</tr></table></table></table></tr></td><tr></tr><tr><td>"]

<html><body bgcolor='[r:bColor]' style='font-size:8.5px; text-align:center'>
<table width='100%' cellpadding='1' cellspacing='0'><tr><td>

[h:groupTitle = "Group Move"]
[r:strformat(macroGroup)]
		[r:bot_HTMLMacroImageButton(50,"maroon","white",tblImage("tbl_Image",3), "rotateCW", 		shadow, "<html><bgcolor=red color=yellow><b>Rotate Group Clockwise</b>Select a <i>group</i> token and rotate the other corresponding group tokens around it</html>")]
		[r:bot_HTMLMacroImageButton(50,"maroon","white",tblImage("tbl_Image",4), "rotateCCW", 		shadow, "<html><bgcolor=red color=yellow><b>Rotate Group Counter Clockwise</b>Select a <i>group</i> token and rotate the other corresponding group tokens around it</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroImageButton(50,"maroon","white",tblImage("tbl_Image",5), "spreadGroup", 	shadow, "<html><bgcolor=red color=yellow><b>Spread Group</b>Select one token of a group and spread the other tokens with an offset of X=1 and Y=1</html>")]
		[r:bot_HTMLMacroImageButton(50,"maroon","white",tblImage("tbl_Image",6), "contractGroup", 	shadow, "<html><bgcolor=red color=yellow><b>Contract Group</b>Select one token of a group and contract the other tokens with an offset of X=-1 and Y=-1</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroImageButton(50,"maroon","white",tblImage("tbl_Image",7), "formationWedge", 	shadow, "<html><bgcolor=red color=yellow><b>Wedge formation</b> Select one token of a group and put them in this formation</html>")]
		[r:bot_HTMLMacroImageButton(50,"maroon","white",tblImage("tbl_Image",8), "formationPWedge",	shadow, "<html><bgcolor=red color=yellow><b>Packed Wedge formation</b> Select one token of a group and put them in this formation</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroImageButton(50,"maroon","white",tblImage("tbl_Image",9), "formationLine",	shadow, "<html><bgcolor=red color=yellow><b>Line formation</b> Select one token of a group and put them in this formation</html>")]
		[r:bot_HTMLMacroImageButton(50,"maroon","white",tblImage("tbl_Image",10), "formationEchelon",shadow, "<html><bgcolor=red color=yellow><b>Echelon formation</b> Select one token of a group and put them in this formation</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroImageButton(50,"maroon","white",tblImage("tbl_Image",11), "formationStagger",shadow, "<html><bgcolor=red color=yellow><b>Stagger formation</b> Select one token of a group and put them in this formation</html>")]
		[r:bot_HTMLMacroImageButton(50,"maroon","white",tblImage("tbl_Image",12), "formationSquare",shadow, "<html><bgcolor=red color=yellow><b>Square formation</b> Select one token of a group and put them in this formation</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroImageButton(50,"maroon","white",tblImage("tbl_Image",13), "setGroup", 		shadow, "<html><bgcolor=red color=yellow><b>Set Group</b> Select a group of tokens to group them for group move.<br>Note that any previous set groups for any of the tokens will be<br>cleared if you run this macro.<br>Also note that this macro makes use of the label field of the<br>token and any current value will get overwritten!!. Changing<br>this value after a group has been set will de-activate group-<br>movement when you move THAT token. The token will still be<br>part of the group and will be moved if another token of the<br>group is moved</html>")]
		[r:bot_HTMLMacroImageButton(50,"maroon","white",tblImage("tbl_Image",14), "clearGroup", 	shadow, "<html><bgcolor=red color=yellow><b>Clear Group</b> Select one token from a group and use this macro to clear the ENTIRE group</html>")]
[r:macroGroupEnd]

@@createMacroButtonsOTMSetup
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=11pt ; sortBy=1 ; color=black ; playerEditable=false ; applyToSelected=false ; group=1. Macro Frame ; tooltip= ; minWidth=193 ; 
[h:'<!-- --------------------------------------------- createMacroButtonsOTMSetup --------------------------------------------------- -->']
[h:'<!-- bot_HTMLMacroButton(cellWidth, cellColor, textColor, text, macroName, shadow, toolTip, arguments, macro location, output to) -->']

[h:tableExists	= if(listContains(json.toList(json.get(getInfo("campaign"),"tables")), "tbl_Image"),1,0)]
[h, if(tableExists): shadow = tblImage("tbl_Image",2) ; shadow = ""]

[h: macroGroup	=	"<table width=100% cellpadding=0 cellspacing='1' color='white' bgcolor='black'><td align=center><b>%{groupTitle}</b></td></table>" + 
					"<table width=100% cellpadding=0 cellspacing='1' bgcolor='black'>" +
					"<table width=100% cellpadding=1 cellspacing='1' bgcolor='#e5e5cc'>" +
					"<table width=100%><tr>"
]
[h: macroNewLine	= "</tr></table><table width=100%><tr>"]
[h: macroGroupEnd	= "</tr></table></table></table></tr></td><tr></tr><tr><td>"]

<html><body bgcolor="#e5e5cc" style="font-size:8.5px; text-align:center">
<table width="100%" cellpadding="1" cellspacing="1"><tr><td>
	<table width="100%"><tr><td bgColor = "#e5e5cc" align="center">
		<span color="black"	style="text-decoration:none">[r:macroLink("<b>Setup</b>" ,"MacroButtonsOTMSetup@this","none")]</span>
		</td><td bgColor = "#c5c5ac" align="center">
		<span color="gray"	style="text-decoration:none">[r:macroLink("<b>Utils</b>" ,"MacroButtonsOTMUtils@this","none")]</span>
	</td></tr></table>
	</td></tr><tr><td>

[h:groupTitle	= "Basics"]
[r:strformat(macroGroup)]
		[r:bot_HTMLMacroButton(50,"blue","yellow","Manual", "manualText", shadow, "<html>This pops up a user manual of this tool</html>")]
		[r:bot_HTMLMacroButton(50,"red","yellow","Initialize Pads", "initializePads", shadow, "<html>This macro cycles through all maps in the campaign file<br>looking for special pads. It will initialize any special pad it<br>encounters and report any errors  on the way</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"purple","yellow","Alt. Init. Pads", "altInitMap", shadow, "<html>In contrast to initialize Pads, this macro does ONLY initialize the CURRENT map.<br> It uses a completely different and more time consuming method for this.<br>Resulting in a map where the movement of tokens is less snappy in general<br> But will be (a lot) faster when there are a lot (>100) special tokens on a map.</html>", "", "@this", "all")]
		[r:bot_HTMLMacroButton(50,"yellow","black","Settings", "settings", shadow, "<html>Here you can set stuff as a different name for BASE map.</html>", "", "@this", "all")]
[r:macroGroupEnd]

[h:groupTitle	= "Animation"]
[r:strformat(macroGroup)]
		[r:bot_HTMLMacroButton(50,"green","yellow","Set Door", "setDoor", shadow, "<html>To use the <i>Toggle Door(s)</i> macro, select a door and click this button to set it up</html>")]
		[r:bot_HTMLMacroButton(50,"green","yellow","Set Roof", "setRoof", shadow, "<html>Here you can give a list of <i>entry doors</i> through which a token can<br>enter the building. Note that these doors MUST be on the edge of the<br>roof (like real doors). If you leave this list empty, a token can move<br>anywhere on or over the <i>roof</i> token</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"#FFA500","black","Activate Switches", "openFrame", shadow, "<html>This macro activates a frame. As long as that frame is open the following functions are active:<br>- Door Switches (user can click them to open doors) <br>- Event Buttons (user can click them to activate linked macro) <br>- Full screen mode (if turned on in the settings, frames are automatically turned into Dialogs) <br>- Group select tokens (user can select one token and the rest is auto-selected)<br>- Force token selection (token that gm selects on his client is also selected on a player client)<br></html>")]
[r:macroGroupEnd]

[h:groupTitle	= "Scatter & Canopy"]
[r:strformat(macroGroup)]
		[r:bot_HTMLMacroButton(50,"blue","yellow","Build Forest", "buildForest", shadow, "<html>Select a one ore more images of a Tree top (Canopy) and click this button to randomly spread them over an area</html>")]
		[r:bot_HTMLMacroButton(50,"green","white","Choose Trunks", "chooseTrunks", shadow, "<html>This will show a form where you can select or deselect tree trunk images<br>which are on the BASE map. The checked images will be (randomly) used for the <i>Canopy</i> pads</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"blue","yellow","Create Crowd", "createCrowd", shadow, "<html>Use this macro to create a square filled with tokens (a crowd),<br>that can later be dispersed by using the <i>move crowd</i> macro</html></html>")]
		[r:bot_HTMLMacroButton(50,"green","white","Choose Crowd", "chooseCrowd", shadow, "<html>This will show a form where you can select or deselect crowd tokens images<br>which are on the BASE map. The checked images will be (randomly) used for<br>the <i>Create Crowd</i> macro.</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"blue","yellow","Scatter Tokens", "scatter", shadow, "<html>This macro will <i>scatter</i> selected tokens over the map, according to the set parameters</html>")]
		[r:bot_HTMLMacroButton(50,"black","white","Mass VBL", "MassVBL", shadow, "<html>This function draws VBL crosses on all tokens that match a search string")]
[r:macroGroupEnd]

[h:groupTitle	= "Event Pads/<font color=#FFFF00>Areas</font> (Traps & Pits)"]
[r:strformat(macroGroup)]
		[r:bot_HTMLMacroButton(50,"green","yellow","0. Draw Area", "toggleAreaDraw", shadow, "<html>This macro fills up an area with tokens. You can either select ONE token and run it, or run it without selection.<br>If you select one token before you run this then that token will be added to the dropdown.</html>")]
		[r:bot_HTMLMacroButton(50,"green","white","Set Event Pad", "setEventPad", shadow, "<html>This macro can be used to link an Event Macro to an EventPad<br><br>1. Create a macro on the lib:EventMacros token in the group:<br>&#39;Event Pad Macros&#39;, containing the code that is activated when the<br>Event is triggered. For example &#39;Spear Trap<br>2. Select an &#39;Event token&#39;. This is a token which name starts with<br>&#39;EventPad &#39; e.g. &#39;EventPad 1&#39; or &#39;EventPad Pit Trap&#39;.<br>This token can be placed on any layer<br>3. Run the macro &#39;Set Event Pad&#39;<br>4. Pick an Event macro from the list, e.g. &#39;Standard Pit&#39;<br>5. Then select the events on which this macro is triggered<br>7. Click OK <br>8. Run &#39;Initialize Maps&#39;<br><br>The Event Pad is now set")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"green","yellow","1. Fill Area", "fillArea", shadow, "<html>This macro fills a predefined area with tokens</html>")]
		[r:bot_HTMLMacroButton(50,"green","white","Reset Pit", "resetPit", shadow, "<html>This will show a pop-up with all the initialized doors. Here you can select which to open/close</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"green","yellow","2. Define Area", "defineArea", shadow, "<html>With this macro you can define an Event Area which you then can link to an event macro, to be triggered when a token moves over this area.</html>")]
		[r:bot_HTMLMacroButton(50,"green","white","Set Event Button", "setEventButton", shadow, "<html>This macro can be used to link an Event Macro to a Event Button.<br><br>1. Create a macro on the lib:EventMacros token in the group: &#39;Event Button Macros&#39;, containing the<br>code that is activated when the button, e.g. &#39;Switch To Map&#39;<br>2. Select the button (any token will do) to which that macro should apply e.g. &#39;Switch to Fair Haven&#39;<br>3. Run this macro<br>4. Select &#39;Switch Map&#39; from the list<br>5. In the &#39;Give Arguments&#39; box enter the arguments as a stringproperty, e.g.&#39;toMap=Fair Haven&#39;<br><br>Here it is important that both the the arguments name (toMap) and the arguments (Fair Haven)<br>contains ONLY alphanumeric  characters!<br>Note that you can give multiple arguments! Just seperate them with a ;.<br>E.g. toMap=Fair Haven;message=Going to Fair Haven.<br><br>6. Click OK. Now everything is set up<br><br>To use the buttons you need to run the macro &#39;Activate Switches&#39;. This is used for door switches<br>but it will also work for the Event Buttons. Now when thats done you will notice a pop-up. You can<br>make this pop-up small, but you cannot close it (else the buttons will not work).<br><br>If you now click on the button &#39;Switch to Fair Haven&#39; the macro &#39;Switch Map&#39; is activated.</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"green","yellow","3. Assign Area", "assignArea", shadow, "<html>With this macro you can link predefined Areas to Event Macros and to the Limit Movement macro<br>The Event Macro will be triggered when a token moves over the Area. The handling of this is left<br>to the macro itself</html>")]
		[r:bot_HTMLMacroButton(50,"green","yellow","4. (Un)Show Area", "showArea", shadow, "<html>This macro shows predefined areas by putting token in the cells that are part of the Area.<br>When you run this macro again the tokens are removed again.<br><br>Hence this macro can be used to change pre defined area. To do this first run this macro<br>for the area you wish to change. The map will then be filled with tokens. Then move these<br>tokens around, delete them, copy them until youre happy. Then run <i>Define Area</i> and<br>enter a name for the new Area (can be the same as the original in which case it will be<br>overwritten) and click ok. A new Area is now defined. Finally you can run Show Area again<br>to remove the tokens. Note that is you created new tokens that these will NOT be removed by<br>this macro.</html>")]
	[r:macroGroupEnd]

[h:groupTitle	= "Assign Pads"]
[r:strformat(macroGroup)]
		[r:bot_HTMLMacroButton(50,"blue","yellow","Assign Tokens", "assignPads", shadow, "<html>With this macro you can assign token that are on the TOKEN or HIDDEN layer to Assignpads.<br>Tokens assigned to Assignpads will be moved onto their assigned pad when you run Execute<br>Assignpads<br></html>")]
		[r:bot_HTMLMacroButton(50,"blue","yellow","Execute", "execAssignPads", shadow, "<html>Before you can use this macro you first need to assign token to the special Assignpads.<br>Once that is done, you can run this macro and pick the Assignpads to be executed.<br>On execution the linked token will be moved to its assigned pad.<br></html>")]
[r:macroGroupEnd]

[h:groupTitle	= "Tables"]
[r:strformat(macroGroup)]
		[r:bot_HTMLMacroButton(50,"green","white","Create Table", "createTable", shadow, "<html>With this macro you can create a new BoT table by copy pasting a table from e.g. excel<br>into the text box. You can use bot_table(tableName, optional: column, row) to retrieve<br>an entry from that table.</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"green","white","Show Table", "showTable", shadow, "<html>This macro shows a list of all available BoT tables. The one you pick can be edited.</html>")]
		[r:bot_HTMLMacroButton(50,"red","white","Delete Table", "deleteTable", shadow, "<html>This macro shows a list of all available BoT tables. The one you pick will be deleted.</html>")]
[r:macroGroupEnd]

[h:groupTitle	= "Map Editor"]
[r:strformat(macroGroup)]
		[r:bot_HTMLMacroButton(50,"maroon","white","Map Editor", "mapEditor", shadow, "<html>Creates a filed where creating a token map becomes really easy. Hit this button for more info.</html>")]
		[r:bot_HTMLMacroButton(50,"maroon","white","Quit Map Editor", "quitEditor", shadow, "<html>Stops the Map editor (and removes the editor field)<html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"maroon","white","Move to Hidden", "moveToHidden", shadow, "<html>Belongs to the map editor. Moves all pasted tokens to the HIDDEN layer so theyre no longer visible.</html>")]
		[r:bot_HTMLMacroButton(50,"maroon","white","Move to Token", "moveToToken", shadow, "<html>Belongs to the map editor. Moves all hidden tokens back to the TOKEN layer.<html>")]
[r:macroGroupEnd]

[h:groupTitle	= "Utils"]
[r:strformat(macroGroup)]
		[r:bot_HTMLMacroButton(50,"green","white","Set Light Source", "setLightSource", shadow, "<html>The power of this button is that you can apply it to multiple tokens at once.<br>Select all tokens you want to set the light for before you hit this button.<br>You can set light sources to exclude in the settings.<br><b>Make sure that no lightsource in the campaign setting contains a comma: , </b></html>")]
		[r:bot_HTMLMacroButton(50,"green","white","Set Reference", "setReference", shadow, "<html>This macro is used to setup the <b>Shadow pads.</b><br> To sync the movement of the shadow token to the real token two reference tokens are required.<br> <br> To set this up do the following:<br> 1. create two tokens with the same name where one has the suffix &#39; Ground&#39; and the other &#39; Floor&#39;<br> 2. Make sure that the reference tokens are snapped to grid and medium sized.<br> 3. Place one of the tokens on the ground floor map and one on the first floor map.<br> 4. Then select one of the reference tokens and hit this macro. Select the shadow pads to which it<br> should be linked and hit ok.<br> <br> Read the manual for more detailed instructions.</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"green","white","Remove %20", "removeP20", shadow, "<html>This macro replaces %20 with spaces > < in the selected token names</html>")]
		[r:bot_HTMLMacroButton(50,"green","white","Set Draw Order", "setDrawOrder", shadow, "<html>This is just a handy macro where you can manually set the draw order of the token. <br>A high number means on top of all a low number means below all.<br>Then current number (draw order) is shown when you run this macro on a token</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"green","white","Renumber Tokens", "renumberToks", shadow, "<html>When you have used the scatter function<br> (especially icw Spread) then can<br>renumber the scattered tokens before you <br>hit the initialize pads. Assuming that you <br>have scattered special tokens onto the map.</html>")]
		[r:bot_HTMLMacroButton(50,"green","white","Toggle Special", "toggleSpecial", shadow, "<html>This macro toggles Canopy, <br>Foliage or Roofs on or off. <br>This also resets the tokens.</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"green","white","Set Token Size", "setTokSize", shadow, "<html>This macro is usefull if you want to use Alt Init Pads macro to initialize a map.<br>With this macro you can pre-set the size of a token. So you wont be asked <br>for it when you run alt. init. maps.<br>Note that you only need to do this for free size tokens")]
		[r:bot_HTMLMacroButton(50,"green","yellow","Copy/Del Macros", "cpyDelMacros", shadow, "<html> This macro allows you to select macros on the selected token. The selected macros you can copy or delete.<br> <br> In case of <b>copy</b>, they will be stored in a property on lib:EventMacros. When you select another token you can <br> click <i>Paste Macros</i>. This will open a similar frame where you can select the macros to paste on the selected<br> token.<br> In case of <b>delete</b> you have the option to <i>allow undo</i>. The selected macros will be deleted from the token<br> and if allow undo is turned on, they will be stored in a property on that token. So you can later choose to undo the<br> process. </html>  ")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"green","yellow","Paste Macros", "pasteMacros", shadow, "<html> This button you can use to paste macro on the selected token. Before you do this, you first need to run the <br> Copy/Del Macros button on another token. </html>")]
		[r:bot_HTMLMacroButton(50,"green","yellow","Undo Del. Macros", "undoDelMacros", shadow, "<html> If you deleted macros on the selected token using the Copy/Del Macros function<br> AND you had <i>allow undo</i> turned on, then you can use this function to undo<br> that process </html> ")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"green","white","Seek Token", "seekToken", shadow, "<html>This macro searches ALL maps and ALL tokens and<br>return those tokens of which the first part of <br>their name matches with the entered search string<br><b>Pop-ups on first use.</html>")]
		[r:bot_HTMLMacroButton(50,"green","white","Find Duplicates", "findDuplicates", shadow, "<html>Give a list of all tokens of all layers on current map that have the same name</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"green","white","Pad Explorer", "initializeMap", shadow, "<html>This macro shows all special pads on the current map.</html>")]
		[r:bot_HTMLMacroButton(50,"gray","white","Auto Disguise Bttn", "autoDisguiseButton", shadow, "<html>When you click this, a text box will appear with<br>a token property you can add to your Campaign<br>Property token properties to automatically<br>add the <i>Use Disguise</i> button to tokens.</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"black","white","Set VBL Stamp", "setVBLStamp", shadow, "<html>This function applies a VBL (Vision Blocking Layer) upon a token.<br>The VBL will move with the token as you move it.")]
		[r:bot_HTMLMacroButton(50,"black","white","Mass VBL", "MassVBL", shadow, "<html>This function draws VBL crosses on all tokens that match a search string")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"black","white","Toggle VBL", "toggleMassVBL", shadow, "<html>With this function you can toggle saved mass VBL structures (set with Mass VBL macro) on and off")]
		[r:bot_HTMLMacroButton(50,"red","white","DELETE props", "deleteProps", shadow, "<html>This macro resets ALL properties currently on the token. Effectively deleting all properties. Use carefully!!")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"purple","white","Benchmark", "benchmark", shadow, "<html>This macro runs each macro that is in the &#39;Benchmark Macros&#39; group on lib:Ontokenmove<br>and compares their individual times. It uses an empty loop (Default in that group) as<br> reference as deducts that resulting time from the added macros. <br><br>To make use of this, create one or more macros in that group with ONLY the code that you<br>wish to test. Then run this macro and give the number of times (1,10,100 or 1000) you wish<br>to test. The higer the number the more accurate the result, but obviously it will take more<br>time to run", "", "@this", "all")]
		[r:bot_HTMLMacroButton(50,"red","white","Diagnose Maps", "diagnose", shadow, "<html>Map Error Checks. This function checks ALL maps and ALL (lib)tokens for potential issues.<br>It checks whether token names contain non-alphanumerical characters and checks the libs for the<br>same and owner ship and visibility. Any errors are rendered in a frame with hyperlinks that lead<br>you to the token. </html> ", "", "@this", "all")]
[r:macroGroupEnd]
[h:'<!-- bot_HTMLMacroButton(cellWidth, cellColor, textColor, text, macroName, shadow, toolTip, arguments, macro location, output to) -->']

@@createMacroButtonsOTMUtils
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=11pt ; sortBy=1 ; color=black ; playerEditable=false ; applyToSelected=false ; group=1. Macro Frame ; tooltip= ; minWidth=193 ; 
[h:'<!-- createMacroButtonsOTMUtils (optional: lastMessage) -->']
[h:'<!-- bot_HTMLMacroButton(cellWidth, cellColor, textColor, text, macroName, shadow, toolTip, arguments, macro location, output to) -->']

[h, if(argCount() > 0): txtOutput	= arg(0) ; txtOutput	= ""]

[h:tableExists	= if(listContains(json.toList(json.get(getInfo("campaign"),"tables")), "tbl_Image"),1,0)]
[h, if(tableExists): shadow = tblImage("tbl_Image",2) ; shadow = ""]

[h: macroGroup	=	"<table width=100% cellpadding=0 cellspacing='1' color='white' bgcolor='black'><td align=center><b>%{groupTitle}</b></td></table>" + 
					"<table width=100% cellpadding=0 cellspacing='1' bgcolor='black'>" +
					"<table width=100% cellpadding=1 cellspacing='1' bgcolor='#e5e5cc'>" +
					"<table width=100%><tr>"
]
[h: macroNewLine	= "</tr></table><table width=100%><tr>"]
[h: macroGroupEnd	= "</tr></table></table></table></tr></td><tr></tr><tr><td>"]

<html><body bgcolor="#e5e5cc" style="font-size:8.5px; text-align:center">
<table width="100%" cellpadding="1" cellspacing="1"><tr><td>
	<table width="100%"><tr><td bgColor = "#c5c5ac" align="center">
		<span color="gray"	style="text-decoration:none">[r:macroLink("<b>Setup</b>" ,"MacroButtonsOTMSetup@this","none")]</span>
		</td><td bgColor = "#e5e5cc" align="center">
		<span color="black"	style="text-decoration:none">[r:macroLink("<b>Utils</b>" ,"MacroButtonsOTMUtils@this","none")]</span>
	</td></tr></table>
	</td></tr><tr><td>

[h:groupTitle	= "Animation & Events"]
[r:strformat(macroGroup)]
		<b>Toggle:</b>
		[r:bot_HTMLMacroButton(50,"blue","yellow","Door", "toggleDoor", shadow, "<html>Select a door (that has been initialized) and click this button to open or close it</html>","")]
		[r:bot_HTMLMacroButton(50,"black","yellow","Door<b>s</b>", "toggleDoors", shadow, "<html>This will show a pop-up with all the initialized doors<br>on the OBJECT LAYER. Here you can select which to open/close</html>")]
		[r:bot_HTMLMacroButton(50,"Blue","yellow","Lock", "toggleLock", shadow, "<html>This will toggle the Lock State of a door. Select the door first.</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"blue","yellow","Move Crowd", "moveCrowd", shadow, "<html>Disperses a crowd created by the <i>Create Crowd</i> macro.<br>Make sure the antagonist is on the map.</html>")]
		[r:bot_HTMLMacroButton(50,"blue","yellow","Move Crowd+", "moveCrowdPlus", shadow, "<html><html>Disperses a crowd created by the <i>Create Crowd</i> macro.<br> Make sure the antagonist is on the map.<br> <br> This macro uses more intelligence however and is more realistic<br> but MUCH slower (roughly 1 second per 10 tokens)</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"Blue","yellow","Move Token</b>", "animateMove", shadow, "<html>This macro will animate the movement of the selected token. An options panel will be shown first.</html>")]
		[r:bot_HTMLMacroButton(50,"blue","yellow","Animate Text", "animateTextInput", shadow, "<html>This will open an input screen where you can set-up animated text.<br>This text will be send and animated within a frame to every attached<br>client pc.</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"green","white","Reset Pit", "resetPit", shadow, "<html>This will show a pop-up with all the initialized doors. Here you can select which to open/close</html>")]
		[r:bot_HTMLMacroButton(50,"green","yellow","(Un)Show Area", "showArea", shadow, "<html>This macro shows predefined areas by putting token in the cells that are part of the Area.<br>When you run this macro again the tokens are removed again.<br><br>Hence this macro can be used to change pre defined area. To do this first run this macro<br>for the area you wish to change. The map will then be filled with tokens. Then move these<br>tokens around, delete them, copy them until youre happy. Then run <i>Define Area</i> and<br>enter a name for the new Area (can be the same as the original in which case it will be<br>overwritten) and click ok. A new Area is now defined. Finally you can run Show Area again<br>to remove the tokens. Note that is you created new tokens that these will NOT be removed by<br>this macro.</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"blue","yellow","Execute Event", "executeEvent", shadow, "<html>This macro generates a list of macros per group from the lib:Event token.<br>You can select one or more macros which then will be executed</html>")]
		[r:bot_HTMLMacroButton(50,"blue","yellow","Exec Assignpad", "execAssignPads", shadow, "<html>Before you can use this macro you first need to assign token to the special Assignpads.<br>Once that is done, you can run this macro and pick the Assignpads to be executed.<br>On execution the linked token will be moved to its assigned pad.<br></html>")]
[r:macroGroupEnd]

[h:groupTitle	= "Utils"]
[r:strformat(macroGroup)]
		[r:bot_HTMLMacroButton(50,"green","white","Dice Box", "Launch Dice Box", shadow, "<html>Opens a form with dices where you can set a group of dice to roll<br>The workings of the Dice box are pretty obvious. What might not be<br>obvious is that it supports 10 different dice boxes. You can click the<br>macro 10 times and set each frame individually.")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"green","white","Switch Map", "switchMap", shadow, "<html> Forces ALL clients to chosen map AND centres view on the token <i>centreOnMePad</i> <br><br>If you select tokens before you use this macro, then the option will be added to move<br>the selected tokens to the new map as well. These tokens will be placed near the <i>centreOnMePad</i><br><br>If there is no <i>centreOnMePad</i> then the coords (X,Y) 0,0 will be used instead.</html>","")]
		[r:bot_HTMLMacroButton(50,"green","white","Seek Token", "seekToken", shadow, "<html>This macro searches ALL maps and ALL tokens and<br>return those tokens of which the first part of <br>their name matches with the entered search string<br><b>Pop-ups on first use.</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"green","white","Set Light Srce", "setLightSource", shadow, "<html>The power of this button is that you can apply it to multiple tokens at once.<br>Select all tokens you want to set the light for before you hit this button.<br>You can set light sources to exclude in the settings.<br><b>Make sure that no lightsource in the campaign setting contains a comma: , </b></html>")]
		[r:bot_HTMLMacroButton(50,"green","white","Use Disguise", "useDisguise", shadow, "<html> - Clicking the <i>Use Disguise</i> button will add the current token image to your disguise list.<br> - Changing your image and clicking the button again will add a new image to list.<br> OR<br> - Selecting <i>image:tokens</i> together with the token will add those images to the disguise<br>list of the token<br><br>- A list will be shown for all the possible images you have loaded.<br> - You have the option to Change or Delete an image from your list.<br> - On the lib file, if you click <i>autoDisguiseButton</i> a text box will appear with a token<br>property you can add to your Campaign Property token properties to automatically add the<br> <i>Use Disguise</i> button to tokens.</html> ")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"green","white","Toggle Special", "toggleSpecial", shadow, "<html>This macro toggles Canopy, <br>Foliage or Roofs on or off. <br>This also resets the tokens.</html>")]
		[r:bot_HTMLMacroButton(50,"green","white","Show Handout", "showHandout", shadow, "<html> Pops up a dialog showing the handout of the selected token on all selected clients.</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"green","white","Whisper Frame", "whisperFrame", shadow, "<html>This opens a frame where you can send formatted text to specific players.<br> <u>Alternatively</u> you can send a message to <u>all</u> players as if you<br> impersonate the selected token, without actually needing to impersonate it.<br> <br> <b>Notes</b> <br> - you must either be the gm or own the selected token to do this.<br> - the impersonation ONLY works with <i>all players</i> check box <br>   selected. (So not when some or all the individual player checkboxes are<br>   selected!!).</html>")]
		[r:bot_HTMLMacroButton(50,"green","white","Message Mngr", "notes", shadow, "<html>This macro allows you to store prepared messages and manage these.<br>For GMs these will be store on lib:EventMacros, for players these will <br>be stored on the token that they own (and is selected). <br>To add a picture to a message: <br>- create the message (and save it). <br>- select the token that contains the image (can be token,portrait or handout).<br>- click add selected image for that message. The rest should be simple.<br></html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"maroon","white","Group (Move)", "setGroup", shadow, "<html>Select a group of tokens to group them for group move.<br>Note that any previous set groups for any of the tokens will be<br>cleared if you run this macro.<br>Also note that this macro makes use of the label field of the<br>token and any current value will get overwritten!!. Changing<br>this value after a group has been set will de-activate group-<br>movement when you move THAT token. The token will still be<br>part of the group and will be moved if another token of the<br>group is moved</html>")]
		[r:bot_HTMLMacroButton(50,"maroon","white","Ungroup (Move)", "clearGroup", shadow, "<html>Select one token from a <i>move</i> group and use this macro to clear the ENTIRE group</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"maroon","white","Formations", "MacroButtonsGroupMove", shadow, "<html>Open the group move macro frame</html>")]
		[r:bot_HTMLMacroButton(50,"blue","yellow","Summon Tokens", "summonToken", shadow, "<html>With this macro you can summon any token from the BASE map that is on the TOKEN layer.<br>If you select a token first before you click this button then the to-summon-token(s) will be<br>placed on the selected token. Else you can enter x and y coordinates of where you want to summon<br>the token. The types of tokens listed in the Dialog can be specified through the settings.</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"aqua","red","Draw Order", "openOrderFrame", shadow, "<html>This macro opens a panel where you can edit the draw order of the selected tokens</html>")]
		[r:bot_HTMLMacroButton(50,"aqua","black","Activate Group", "openGroupFrame", shadow, "<html>This opens a <i>group select</i> frame which is required for the <i>Select Group</i> to function.<br>When this panel is closed you can still group and ungroup, but the <i>auto select</i> will only<br>work when this frame is active.</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"aqua","black","Group (Select)", "setSelectGroup", shadow, "<html>This macro creates a <i>select group</i> of all currently selected tokens.<br>After a group is set (and the group select frame is active) when you<br>select one token of the group, all the other tokens of the group will be<br>automatically selected as well. This is particularly usefull when drawing<br>maps and you want to group a set of tokens into one object.</html>")]
		[r:bot_HTMLMacroButton(50,"aqua","black","Ungroup (Select)", "clearSelectGroup", shadow, "<html>This ungroups a <i>Select Group</i>. You only need to select one token of the group to ungroup the entire group </html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"black","white","Toggle VBL", "toggleMassVBL", shadow, "<html>With this function you can toggle saved mass VBL structures (set with Mass VBL macro) on and off.</html>")]
		[r:bot_HTMLMacroButton(50,"black","white","VBL Grenade", "VBLGrenade", shadow, "<html>Select one or more tokens, run macro, set radius (in grid cells) and ALL VBL in that radius around the selected tokens will be cleared.</html>")]
	[r:macroNewLine]
		[r:bot_HTMLMacroButton(50,"yellow","red","Lock Movement", "movementLock", shadow, "<html>When this is turned ON, no PLAYER can move a token, only the GM can.</html>")]
		[r:bot_HTMLMacroButton(50,"yellow","red","Lock Token", "tokenLock", shadow, "<html>When this is turned ON, no one (gm included) can move the selected token(s).<br>For this to work the toggle in the settings: <i>Lock Movement for Locked Tokens</i> needs to be turned on!</html>")]
	[r:macroNewLine]
		[h:OTME_comment = "<html>This will disable/enable the onTokenMoveEvent macros.<br>The onTokenMoveEvent can be demanding for every move<br>a token makes, especially when creating a map this can be<br>annoying. By clicking on this button you can temporarily<br>disable the event. Clicking it again will turn it on again.</html>"]
		[r, if(getLibProperty('onTokenMoveEvent', 'lib:onTokenMove')==1):
			bot_HTMLMacroButton(50,"red","yellow","Move Event is<br>Turned ON", "toggleOnTokenMove", shadow, OTME_comment, "", "@this", "all")
		; 
			bot_HTMLMacroButton(50,"gray","dark gray","Move Event is<br>turned OFF ", "toggleOnTokenMove", shadow, OTME_comment, "", "@this", "all")
		]
		[h:TFSM_comment = "<html>When toggled, the frames will be changed into dialogs,<br> which ARE allowed in full screen. This way when you<br> toggle this button you can have acces to chat and macros<br> in the form of dialogs.<br> In addition, when you have turned on the <i>redefine broadcast</i><br> setting in the settings, then when using the broadcast() function<br> a dialog will pop up showing the last message broadcasted.</html>"]
		[r, if( bot_isFullScreen() ):
			bot_HTMLMacroButton(50,"red","yellow","Full Screen<br>Mode is ON", "toggleFullScreen", shadow, TFSM_comment)
		; 
			bot_HTMLMacroButton(50,"gray","dark gray","Full Screen<gr>Mode is OFF", "toggleFullScreen", shadow, TFSM_comment)
		]
		
[r:macroGroupEnd]

[h:'<!-- bot_HTMLMacroButton(cellWidth, cellColor, textColor, text, macroName, shadow, toolTip, arguments, macro location, output to) -->']

[r,if(txtOutput != ""), CODE:{
	[h:'<!-- show last message output when in FS mode -->']
	[r:txtOutput]
};{}]

</td></tr></table></body></html>

@@toggleOnTokenMove
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=4 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=1. Macro Frame ; tooltip= ; minWidth=193 ; 
[h:assert(isGM(),"GM Only!!,0")]

<!-- make sure your on the basemap when changing the ontokenmove lib -->
[h:oldMap			= getCurrentMapName()]
[h:baseMapName		= getLibProperty('baseMapName', 'lib:EventMacros')]
[h:onTokenMoveEvent	= getLibProperty('onTokenMoveEvent', 'lib:onTokenMove')]
[h, if(oldMap != baseMapName):setCurrentMap(baseMapName)]

[h:macroList = getMacros(",","lib:OnTokenMove")]

[r,g,if(listContains(macroList, "onTokenMove")), CODE:{
	[h:setMacroProps("onTokenMove", "label=#onTokenMove", "; ", "lib:OnTokenMove")]
	[h:setMacroProps("onMultipleTokensMove", "label=#onMultipleTokensMove", "; ", "lib:OnTokenMove")]
	[h:setLibProperty('onTokenMoveEvent', 0, 'lib:onTokenMove')]
	The on token move event is turned <font color="red"><b>off
}; {
	[h:setMacroProps("#onTokenMove", "label=onTokenMove", "; ", "lib:OnTokenMove")]
	[h:setMacroProps("#onMultipleTokensMove", "label=onMultipleTokensMove", "; ", "lib:OnTokenMove")]
	[h:setLibProperty('onTokenMoveEvent', 1, 'lib:onTokenMove')]
	The on token move event is turned <font color="red"><b>on
}]

[h, if(oldMap != baseMapName):setCurrentMap(oldMap)]
[h, if(isFrameVisible("Bag Of Tricks Macros")): bot_MacroButtonsOTMUtils()]

@@Hover
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=0 ; color=aqua ; playerEditable=false ; applyToSelected=true ; group=Util ; tooltip= ; minWidth=90 ; 
[h:coords	= getLastPath(0)]
[h,macro("deferHover@Lib:OnTokenMove"): coords]

@@HoverAB
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=0 ; color=aqua ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip= ; minWidth=90 ; 
[h:toks		= getSelected()]
[h:tokA		= listGet(toks, 0)]
[h:tokB		= listGet(toks, 1)]
[h:Ax		= getTokenX(0, tokA)]
[h:Ay		= getTokenY(0, tokA)]
[h:Bx		= getTokenX(0, tokB)]
[h:By		= getTokenY(0, tokB)]

[h:dx		= Bx - Ax]
[h:dy		= By - Ay]

<!-- get direction either positive or negative -->
[h:dirX		= if(dx < 0, -1, 1)]
[h:dirY		= if(dy < 0, -1, 1)]

[h:coord	= json.set("{}","x", Ax, "y", Ay)]
[h:coords	= json.append("[]", coord)]

[h:assert(abs(dx) + abs(dy) < 1000, "The tokens are too far apart, this won't work",0)]

[h,while	(abs(dx) + abs(dy) > 0), CODE:{
	['if(roll.count > 10): abort(0)']
	[if(abs(dx) <= abs(dy)): Ay = Ay + dirY ; Ax = Ax + dirX]
	[dx		= Bx - Ax]
	[dy		= By - Ay]
	[coord	= json.set("{}","x", Ax, "y", Ay)]
	[coords	= json.append(coords, coord)]
	['pause("Ax","Ay","Bx","By","dirX","dirY","dx","dy","coord","coords")']
}]

[h:broadcast(coords)]
[h,macro("deferHover@Lib:OnTokenMove"): coords]

@@abortProcess
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=3 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip= ; minWidth=90 ; 
[setLibProperty("abortProcess", arg(0), "lib:EventMacros")]

@@applyLightSource
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=17 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip= ; minWidth=90 ; 
<!-- ----------------------------------- applyLIGHTSOURCE ------------------------------------------------>
[h: switchToken(tok)]
[h: setLight(lightSet,light,eval("Lamp"+i+"S"+j))]

@@benchmark
@PROPS@ fontColor=lime ; autoExecute=true ; fontSize=1.00em ; sortBy=42 ; color=fuchsia ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip=<html> This macro runs each macro that is in the 'Benchmark Macros' group on lib:Ontokenmove<br> and compares their individual times. It uses an empty loop (Default in that group) as<br>  reference as deducts that resulting time from the added macros. <br> <br> To make use of this, create one or more macros in that group with ONLY the code that you<br> wish to test. Then run this macro and give the number of times (1,10,100 or 1000) you wish<br> to test. The higer the number the more accurate the result, but obviously it will take more<br> time to run ; minWidth=90 ; 
[h:'<!-- ----------------------------------------------- BENCHMARK ------------------------------------------------------------------------------------ -->']
<!--
<html>
This macro runs each macro that is in the 'Benchmark Macros' group on lib:Ontokenmove<br>
and compares their individual times. It uses an empty loop (Default in that group) as<br> 
reference as deducts that resulting time from the added macros. <br>
<br>
To make use of this, create one or more macros in that group with ONLY the code that you<br>
wish to test. Then run this macro and give the number of times (1,10,100 or 1000) you wish<br>
to test. The higer the number the more accurate the result, but obviously it will take more<br>
time to run
-->

<!-- create list of all macros present in the benchmark group on lib:ontokenmove 
	exclusde the macro Default and any macro which name starts with @ -->
[h:macroIDList		= getMacroGroup("Benchmark Macros", ",", "lib:EventMacros")]
[h:macroNameList	= ""]
[h,foreach(id, macroIDList), CODE:{
	[macroName		= getStrProp(getMacroProps(id, "; ", "lib:EventMacros"),"label")]
	[if(macroName != "Default" && !startsWith(macroName, "@")):macroNameList	= listAppend(macroNameList, macroName)]
}]

<!-- create an indication of time it takes to run the loops -->
[h:timeResults	= ""]
[h:bot_startTime()]
[h,foreach(mac, macroNameList,""), CODE:{ [macro(mac+"@lib:EventMacros"):""] }]
[h:time	= bot_totalTime()]

[h:timeChoices	= "1,10,100,1000"]
[h:abort(input(
	"junk|<html><b>The following macros will be tested: </b><i><br>"+macroNameList+"</i><br>Choose the number of times you wish to run each macro.<br>The higer the number, the more accurate the result, but<br>that will take more time</html>|-|LABEL|SPAN=TRUE",
	"choice|1 (~"+bot_formatTime(time,0)+"),10 (~"+bot_formatTime(time*10,0)+"),100 (~"+bot_formatTime(time*100,0)+"),1000 (~"+bot_formatTime(time*1000,0)+")|Run how many times?|RADIO|SELECT=2"
))]
[h:numTimes		= listGet(timeChoices,choice)]

<!-- first run the empty reference macro  -->
[h:bot_startTime()]
[h,count(numTimes), CODE:{
	[macro("Default@lib:EventMacros"):""]
}]
[h:defaultTime	= bot_totalTime()]

[h:timeResults	= ""]
<b>BENCHMARK RESULTS:</b><br><br>
<table>
	<tr><td><b><u>Macro Name</u></b></td><td><b><u>Execution Time</u></b></td></tr><tr><td>
		[r,foreach(mac, macroNameList,"</td></tr><tr><td>"), CODE:{
			[h:bot_startTime()]
			[h,count(numTimes), CODE:{
				[macro(mac+"@lib:EventMacros"):""]
			}]
			[h:resultTime	= max(0,(bot_totalTime() - defaultTime))/numTimes]
			<i>{mac}</i></td><td>{resultTime}ms (= {bot_formatTime(resultTime)})
			[h:timeResults	= listAppend(timeResults, resultTime)]
		}]
	</td></tr>
</table>

[r,if(listCount(macroNameList) > 1), CODE:{
	[h:sortedResults	= listSort(timeResults,"N-")]
	[h:slowestTime		= listGet(sortedResults, 0)]
	[h:fastestTime		= listGet(sortedResults, listCount(timeResults)-1)]
	[h:slowestName		= listGet(macroNameList, listFind(timeResults, slowestTime))]
	[h:fastestName		= listGet(macroNameList, listFind(timeResults, fastestTime))]
	<br>
	<b><u>Conclusions:</u></b><br>
	<table>
		<tr><td>The <b>slowest</b> macro is:</td><td><b>{slowestName}</b> ({slowestTime} ms)</td></tr>
		<tr><td>The <b>fastest</b> macro is:</td><td><b>{fastestName}</b> ({fastestTime} ms)</td></tr>
	</table>
	<br>
	<b>Normalized</b> results using the fastest ({fastestName}) as base:<br>

	<table>
		<tr><td><b><u>Macro Name</u></b></td><td colspan='2'><b><u>Execution Time</u></b></td></tr><tr><td>
			[r,foreach(time,sortedResults,"</td></tr><tr><td>"), CODE:{
				[h:macroName	= listGet(macroNameList, listFind(timeResults, time))]
				[h,if(fastestTime != 0):normTime		= round(time/fastestTime,1)+"x" ; normTime = "infinate"]
				<i>[r:macroName]</i></td><td><b>[r:normTime]</b></td><td>slower then <i>[r:fastestName]</i>
			}]
		</td></tr>
	</table>
};{}]
<br>
<b>Remarks:</b><br>
The resulting execution times are the ACTUAL times it takes to execute the given macro once. Some time is lost by running the macro in a loop and the macro is also looped {numTimes}x.<br>
So the resulting times of these tests are processed as follows:<br>
- first the time it takes to run 'Default' (which is empty) is deducted from the total time. This takes care of the loop time.<br>
- that result is divided by {numTimes} (number of iterations).<br>
The result is thus a close approximation of the actual execution time.<br>
<br>
However its usually still usefull to run this test 2 or 3 times. There is usually quite some difference between the 1st and 2nd benchmark (probly a caching thing) which can be eliminated by running the benchmark  2 or three times.<br>

@@bot_broadcast
@PROPS@ fontColor=green ; autoExecute=true ; fontSize=1.00em ; sortBy=42 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip=returns 1 when its toggled else 0 ; minWidth=90 ; 
[h:'<!-- --------------------------------- bot_broadcast (message, userlist, use oldfunction) ---------------------------------------- -->']

[h,if(argCount()>1): arg1		= arg(1); arg1	= bot_all()]
[h,if(argCount()>2): oldFunc	= arg(2); oldFunc	= 0]

<!-- PARTIAL WORKAROUND: passing an empty array as argument results in bc to all, which should not happen -->
[h,if(json.isEmpty(arg1)):arg1 = "['']"]

[h,if(getLibProperty("fullScreenMode", "Lib:EventMacros") && !oldFunc), CODE:{
	[oldFunction(arg(0),arg1)]
	[bot_execAllPlayers ("deferBroadcast@this", arg(0), arg1)]
};{
	[oldFunction(arg(0),arg1)]
}]

[macro.return = arg(0)]

@@deferBroadcast
@PROPS@ fontColor=green ; autoExecute=true ; fontSize=1.00em ; sortBy=42 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip=returns 1 when its toggled else 0 ; minWidth=90 ; 
[h:'<!-- --------------------------------- bot_deferBroadcast ---------------------------------------- -->']
[dialog("Chat Window", "input=1"):{[r:arg(0)]}]

@@deferHover
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=0a ; color=aqua ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip= ; minWidth=90 ; 
[h:coords	= macro.args]
[h,if(json.length(coords)==0): abort(0)]

[h:coord	= arg(0)]
[h:x		= json.get(coord, "x")]
[h:y		= json.get(coord, "y")]

[h:goto(x, y)]

[h:coords	= json.remove(coords,0)]

[h:'bot_debugInfo("coords, coord,x,y")']
[h:link	= macroLinkText("deferHover@Lib:OnTokenMove", "none", coords)]
[h:execLink(link,1)]

@@deferMessage
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy=51 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip= ; minWidth=90 ; 
[h: link = macroLinkText("deferMessageLink@Lib:OnTokenMove", "self", arg(0))]
[h: execLink(link,1)]

@@deferMessageLink
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy=51 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip= ; minWidth=90 ; 
[h:broadcast(arg(0))]

@@deleteProps
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=31 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip=<html>This macro resets ALL properties currently on the token. Effectively deleting all properties. Use carefully!! ; minWidth=90 ; 
[h:'<!-- DELETE RPOPS -->']
<!-- <html>This macro resets ALL properties currently on the token. Effectively deleting all properties. Use carefully!! -->

[h:toks			= getSelectedNames()]
[h:allAtOnce	= 0]

[h:abort(input(
	"junk|<html><b><font color='red'>THIS WILL DELETE TOKEN PROPERTIES OF THE FOLLOWING SELECTED TOKENS</font><br><font color='blue'>"+toks+"</font></b><br></html>|-|LABEL|SPAN=TRUE",
	"sure|Quit, Choose properties to delete (NONE preselected), Choose properties to delete (ALL preselected), Delete all properties|Pre-select properties?|RADIO|SELECT=0",
	if(listCount(toks) > 1, "allAtOnce|Choose properties to delete per token, Choose once and delete for all selected tokens|All tokens at once?|RADIO|SELECT=1","")
))]

[h:assert(isGm()&&sure, "Reset ABORTED. Either you're not the GM or you're not sure",0)]

<!-- if all at once, make choice once and then do the rest seperately. Else create input per token -->
[h,if(allAtOnce): tmpToks = listGet(toks, 0) ; tmpToks = toks]

[r, foreach(tok, tmpToks,"<br><br>"), CODE:{
	[h:switchToken(tok)]
	[h:allProps = getPropertyNamesRaw()]
	The following properties of <b>[r:token.name]</b> have been deleted:

	[r,switch(sure),CODE:
		case 1: {
			[h:inputStr = "[]"]
			[h:inputStr = json.append(inputStr,"junk|<html><b>CHECK those properties you wish TO DELETE</b></html>|-|LABEL|SPAN=TRUE")]
			[h,foreach(prop, allProps): inputStr = json.append(inputStr, "prop"+roll.count+"|0|"+prop+"|CHECK")]
			[h:abort(input(json.toList(json.evaluate(inputStr),"##")))]
			
			[h:'<!-- delete selected props -->']
			[h,foreach(prop, allProps), if(eval("prop"+roll.count)):resetProperty(prop)]
			[r,foreach(prop, allProps, ""), if(eval("prop"+roll.count)):"<br>"+prop]
		};
		case 2: {
			[h:inputStr = "[]"]
			[h:inputStr = json.append(inputStr,"junk|<html><b>CHECK those properties you wish TO DELETE</b></html>|-|LABEL|SPAN=TRUE")]
			[h,foreach(prop, allProps): inputStr = json.append(inputStr, "prop"+roll.count+"|1|"+prop+"|CHECK")]
			[h:abort(input(json.toList(json.evaluate(inputStr),"##")))]
			
			[h:'<!-- delete selected props -->']
			[h,foreach(prop, allProps), if(eval("prop"+roll.count)):resetProperty(prop)]
			[r,foreach(prop, allProps, ""), if(eval("prop"+roll.count)):"<br>"+prop]
		};
		case 3: {
			[h,foreach(prop, allProps):resetProperty(prop)]
			[r:allProps]
		};
		default: {[assert("0,"You made an impossible choice",0")]}
	]
}]

[r,if(allAtOnce), CODE:{
	[h:remToks	= listDelete(toks, 0)]
	<br><br>
	[r, foreach(tok, remToks,"<br><br>"), CODE:{
		[h:switchToken(tok)]
		[h,foreach(prop, allProps), if(eval("prop"+roll.count)):resetProperty(prop)]
		The following properties of <b>[r:token.name]</b> have been deleted:
		[r,foreach(prop, allProps, ""), if(eval("prop"+roll.count)):"<br>"+prop]
	}]
};{}]

@@diagnose
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=1a ; color=yellow ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip=<html>Maps diagnosis. This function checks ALL maps and ALL (lib)tokens for potential issues.<br> It checks whether token names contain non-alphanumerical characters and checks the libs for the<br> same and owner ship and visibility. Any errors are rendered in a frame with hyperlinks that lead<br> you to the token. </html> ; minWidth=90 ; 
[h:'<!-- ------------------------------------- diagnose (onCampaignLoad) ----------------------------------- -->']
<!-- 
<html>Map Diagnosis. This function checks ALL maps and ALL (lib)tokens for potential issues.<br>
It checks whether token names contain non-alphanumerical characters and checks the libs for the<br>
same and owner ship and visibility. Any errors are rendered in a frame with hyperlinks that lead<br>
you to the token. </html> 
-->

<!-- checks for BoT installation errors -->
<!-- NO NEW SCOPE !!! -->
<!-- THREE CODE LEVELS -->
<!-- only return the install checks during oncampaignload. Give full output when run outside of OCL -->
[h,if(argCount() > 0): onCampaignLoad	= arg(0)  ; onCampaignLoad = 0]

[h,if(!onCampaignLoad), CODE:{
	<!-- required background variables for processing -->
	[info		= getInfo("client")]
	[libs		= json.get(info, "library tokens")]
	[botVersion	= json.get(libs, "lib:OnTokenMove")]
	[baseMap	= getLibProperty("baseMapName", "lib:EventMacros")]
	[mapList	= getAllMapNames("json")]
	[oldMap		= getCurrentMapName()]
};{}]

[h:'<!-- --------------------- check if all BOT STATES are added to the campaign---------------------------- -->']
[h:allStates		= getTokenStates("json")]
[h:botStates		= '["isButton","Locked","pathFeet","Special Area","Prone","editFieldMarker"]']
[h:botStatesExp		= "the switch buttons to operate doors, doors so the gm can lock them (doors will NOT work without this state), path tracking (blue and red feet), creating special areas (like movement limitation), used for the Crowd utility, used for Map Editor Utility"]

[h:found			= json.intersection(allStates, botStates))]
[h:notFound			= json.difference(botStates, found)]

[h,if(!json.isEmpty(notFound)), CODE:{
	[output			= "&nbsp;x <u><font color='red'>The following states are currently <b>NOT</b> defined for this campaign:</font></u><br>"]
	[foreach(state, notFound): output	= output + "<b> - "+state+"</b>: used in the Bag of Tricks for "+listGet(botStatesExp, json.indexOf(botStates, state))+"<br>"]
	[stateOutput	= output + "If you're not planning to make use of any of these functions, you can ignore this message."]
};{
	[stateOutput	= "&nbsp;v All necessary Bag of Tricks states have been defined"]
}]

[h:'<!-- --------------------- check if all BOT TOKENS are added to the campaign---------------------------- -->']
[h:setCurrentMap(baseMap)]
[h:allToks			= getTokenNames("json", json.set("{}", "layer", json.append("[]","TOKEN","HIDDEN","OBJECT","BACKGROUND")))]
[h:setCurrentMap(oldMap)]
[h:botToks			= '["DoorLeverToken","blue feet","red feet","Area Marker","VBL-Brush","GridCoordMarker"]']
[h:botToksExp		= "the switch buttons to operate doors, path tracking (the PC track), path tracking (the NPC track), creating special areas (like movement limitation),creating and storing polygon VBL shapes (VBL Stamps) on tokens,the transparent field tokens required for the Map Editor"]
[h:found			= json.intersection(allToks, botToks))]
[h:notFound			= json.difference(botToks, found)]

[h,if(!json.isEmpty(notFound)), CODE:{
	[output			= "&nbsp;x <u><font color='red'>The following Tokens are currently <b>NOT</b> present in this campaign file:</font></u><br>"]
	[foreach(state, notFound): output	= output + "<b> - "+state+"</b>: used in the Bag of Tricks for "+listGet(botToksExp, json.indexOf(botToks, state))+"<br>"]
	[tokOutput		= output + "If you're not planning to make use of any of these functions, you can ignore this message."]
};{
	[tokOutput		= "&nbsp;v All necessary Bag of Tricks tokens have been found"]
}]

[h:'<!-- --------------------- check if all BOT TABLES are added to the campaign---------------------------- -->']
[h:tableJson		= json.get(getInfo("campaign"),"tables")]
[h:tableGroups		= json.toList(tableJson)]

[h:botTables		= '["tbl_Image"]']
[h:botTablesExp		= "The following things won't work without it: Roofs, Formations, Dicebox. <font color='blue'><a href='http://bit.ly/GGVCzN'>Here is a download link</a></font>"]

[h:found			= json.intersection(tableJson, botTables))]
[h:notFound			= json.difference(botTables, found)]

[h,if(!json.isEmpty(notFound)), CODE:{
	[output			= "X <u><font color='red'>The following table is currently <b>NOT</b> present in this campaign:</font></u><br>"]
	[foreach(table, notFound): output	= output + "<b> - "+table+"</b>: "+listGet(botTablesExp, json.indexOf(botTables, table))+"<br>"]
	[tableOutput	= output]
	[right			= ""]
	[wrong			= ""]
};{
	[tableOutput	= "&nbsp;v All necessary Bag of Tricks tables are installed"]
	[if(table("tbl_Image", 25) != "Wrong"), CODE:{
		[tableOutput	= tableOutput + "<br>&nbsp;x However 'tbl_Image' is not up to date. You can extract it from <font color='blue'><a href='http://bit.ly/GGVCzN'>here</a></font>"]
		[right			= ""]
		[wrong			= ""]
	};{
		[right			= "<image src='" + tableImage("tbl_Image", 24, 15) + "'></image>"]
		[wrong			= "<image src='" + tableImage("tbl_Image", 25, 15) + "'></image>"]
	}]
}]

[h:libList			= json.fields(json.get(info, "library tokens"))]
[h:hasOwner			= ""]
[h,if(onCampaignLoad), CODE:{
	<!-- --------------------- check if all lib:tokens are un-owned ---------------------------- -->
	[foreach(map, mapList), CODE:{
		[setCurrentMap(map)]
		[foreach(libTok, libList), if(findToken(libTok) != ""), CODE:{
			[if(isOwnedByAll(libTok) || getOwners(",",libTok) != ""):	hasOwner = listAppend(hasOwner, strformat("%{libTok} (%{map})"))]
		''
		}]
	''	
	}]
''
};{
	<!-- 
	- if mapname contains illegal chars
	- if mapname starts or is entirely a number
	- check for wrong characters in token names
	- check if all lib:tokens are un-owned 
	- check if lib:token on correct layer
	- check if lib:token is visible
	- optionally: check if the ID of tokens are numeric
	 -->
	[isHidden			= ""]
	[h:txtOutput		= "<b><u><font color='red'>ERRORS FOUND: </font></u></b><br>If any errors have been found in a token, a hyperlink is shown which will goto the corresponding map and select the token (if possible). Keep in mind however that the listed tokens likely have characters in their name that might break these hyperlinks, which will result in an error report. In this case just go to the map and search it manually<br><br>"]
	<!-- the following string is used to create clickable links to the tokens -->
	[h:result			= "<a href='macro://gotoToken@lib:OnTokenMove/none/impersonated?[&quot;%{map}&quot;, &quot;%s&quot;, &quot;3&quot;, &quot;0&quot;, &quot;0&quot;]'>%s</a>"]

	[foreach(map, mapList), CODE:{
		[txtOutput		= txtOutput + strformat("<b><u>%{map}</u></b><br>")]
		[setCurrentMap(map)]
		
		<!-- check if map name contains illegal characters -->
		[warningName	= if(getFindCount(strfind(map,"[^,\\w\\s\\-._]")) ||  getFindCount(strfind(map,",")),1,0)]
		[if(warningName):	txtOutput = txtOutput + strformat("<font color=red>This map contains non-alphanumerical characters, that can potentially break Bag of Tricks or Framework macros. After you fixed the name, run Diagnose again!!</font><br>")]
		<!-- check if map name either starts with a number or is a number entirely (both cause issues) -->
		[warningName	= if(isNumber(substring(map,0,1)), 1, 0)]
		[if(warningName):	txtOutput = txtOutput + strformat("<font color=red>Either the name of this map starts with a number or the map name IS a number. Both cases will lead to errors for the Bag of Tricks.</font><br>")]
		
		<!-- check if anything is wrong with the lib tokens on this map -->
		[foreach(libTok, libList), if(findToken(libTok) != ""), CODE:{
			[hasOwner = ""]
			[isHidden = ""]
			[if(isOwnedByAll(libTok) || getOwners(",",libTok) != ""):	hasOwner		= listAppend(hasOwner,		strformat("%{libTok} (%{map})"))]
			[if(!getVisible(libTok)):									isHidden		= listAppend(isHidden,		strformat("%{libTok} (%{map})"))]

			<!-- check for owners on libs -->
			[h,if(listCount(hasOwner)):		txtOutput	= txtOutput + strformat("The following lib(s) have a(n) owner(s) set. If the lib is for general use (all players) then you need to correct this (uncheck all owners): ")]
			[h:txtOutputL	= ""]
			[h,foreach(tok, hasOwner): 		txtOutputL	= listAppend(txtOutputL, strformat(result, tok, tok))]
			[h:txtOutput	= txtOutput + txtOutputL + if(txtOutputL != "", "<br><br>", "")]

			<!-- check if libs are hidden -->
			[h,if(listCount(isHidden)):		txtOutput	= txtOutput + strformat("The following lib(s) are NOT visible to players. Make sure they are: ")]
			[h:txtOutputL	= ""]
			[h,foreach(tok, isHidden):		txtOutputL	= listAppend(txtOutputL, strformat(result, tok, tok))]
			[h:txtOutput	= txtOutput + txtOutputL + if(txtOutputL != "", "<br><br>", "")]
		''
		}]
		
		<!-- check if theres any token on the map with a potential buggy name -->
		[H:tokListP	= getTokenNames("%", '{layer:["TOKEN","GM","OBJECT","BACKGROUND"]}')]
		[h:tokList	= getTokenNames("json", '{layer:["TOKEN","GM","OBJECT","BACKGROUND"]}')]

		[h:hasWrongTokName	= "[]"]

		<!-- check is any token contains a , in its name -->
		[h:regResult	= strfind(tokListP,"[^%]*(,+)[^%]*")]
		[h:numWrong		= min(1000,getFindCount(regResult))]
		[h,if(numWrong), CODE:{
			[count(numWrong): hasWrongTokName = json.append(hasWrongTokName, getGroup(regResult, roll.count+1,0))]
		''
		}]
				
		<!-- remove the token entries that contained a , in their name -->
		[h:tokListC	= json.difference(tokList, hasWrongTokName)]
		[h:tokListC	= json.toList(tokListC)]

		<!-- check the remaining tokens for any illegal character -->
		[h:regResult	= strfind(tokListC,"[^,]*([^,\\w\\s.\\-_]+)[^,]*")]
		[h:numWrong		= min(1000,getFindCount(regResult))]
		[h,if(numWrong), CODE:{
			[count(numWrong): hasWrongTokName = json.append(hasWrongTokName, getGroup(regResult, roll.count+1,0))]
		''
		}]
		

		<!-- check whether the ID of the tokens are NOT numerical -->
		<!-- code (for the most part) by lmarkus -->
		[hasWrongIdName	= "[]"]
		[idList	= getTokens("json", '{layer:["TOKEN","GM","OBJECT","BACKGROUND"]}')]
		[splices	= bot_createSplices(idList)]
		[foreach(splice, splices), CODE:{
			[foreach(id, splice), if(length(id) != 32): hasWrongIdName = json.append(hasWrongIdName, id)]
			
		''
		}]
		<!-- add the mapname to the tokens and create a clickable output -->
		[if(json.length(hasWrongIdName)):	txtOutput	= txtOutput + strformat("The following token <b>ID's</b> have been <b>fixed</b> (numerical token ids can lead to a lot of issues in maptool. By copy pasting the original they get a new ID. Run Diagnose again just to be sure that the new name is not a number):<b> ")]
		[txtOutputL	= ""]
		[foreach(id, hasWrongIdName), CODE:{
			[txtOutputL	= listAppend(txtOutputL, getName(strformat("%032d",id)))]
			[copyToken(strformat("%032d",id),1,"",json.set("{}","name",getName(strformat("%032d",id)),"delta",1,"x",0,"y",0)) ]
			[removeToken(strformat("%032d",id)) ]
		}]
		[txtOutput	= txtOutput + txtOutputL + if(txtOutputL != "", "</b><br><br>", "")]
		[txtOutput	= txtOutput + "<br>"]
	''
	}]
''
}]
[h:setCurrentMap(oldMap)]

[h,if(hasOwner != ""):
   libOwnerOutput   = "&nbsp;x <u><font color='red'>The following lib:Tokens have an owner set and trusted macros <b>WILL NOT WORK!</b>: </font></u><br>"+hasOwner+". If this is a lib:token of a player, then this is no issue. If this however is a lib:token belonging to the gm or Framework then it most likely will pose a problem. To fix this, double click on these lib:Tokens, goto the ownership tab and make sure ALL checkboxes are UNchecked"
;
   libOwnerOutput   = "&nbsp;v All lib:Tokens have no owners set (this is good!)."
]

[if(!onCampaignLoad), CODE:{
	[r,frame("Initialization result")				:{[r:txtOutPut]}]
};{}]

@@isFullScreen
@PROPS@ fontColor=green ; autoExecute=true ; fontSize=1.00em ; sortBy=41 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip=returns 1 when its toggled else 0 ; minWidth=90 ; 
[h:'<!-- --------------------------------- isFullScreen ---------------------------------------- -->']
[h:FSM = getLibProperty("fullScreenMode", "Lib:EventMacros")]
[h:macro.return = if(!isNumber(FSM), 0, FSM)]

@@manFunctionsTxt
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=2 ; color=darkgray ; playerEditable=true ; applyToSelected=false ; group=Util ; tooltip= ; minWidth=90 ; 
[h:output =  "<font color=red><b><u>BOT FUNCTION DOCUMENTATION</u></b><br></font>

	<p>
		<font color=red><b>bot_animateText</b></font><i>(text[, title, position, html-header, width, height, delay, upper])</i><br />
		These are two feature: one is a macro that you can call and use in your own FW or even in the chat: animateText (text[, title, position, html-header, width, height, delay, upper]). The input box can be found in the &#39;Bag of Tricks macro panel&#39;. When the text animation is activated a frame will pop-up on every attached client pc printing the text.<br />
		<b>- text</b>: The text you enter here will be animated in a frame<br />
		<b>- title</b>: The title of the frame<br />
		<b>- position</b>: The animated will start at the character number you enter here, e.g. 10 means that the first 10 character won&#39;t be animated<br />
		<b>- html-header</b>: Here you can set some basic make up for the frame itself. If you enter &#39;Default&#39; it will show a black-green frame with courier font<br />
		<b>- width &amp; height</b>: The dimensions of the Frame<br />
		<b>- delay</b>: Amount of delay per character printed in ms.<br />
		<b>- upper</b>: Print the animated text in UPPER CASE<br /></p>
	<p>
		<font color=red><b>bot_animateMove</b></font><i>(0. tokenID, 1. x, 2. y [, 3. relative, 4. onImpact(-1:bounce; 0=continue; 1=stop), 5. layer(json.object), 6. vbl(1; 0), 7 delay(ms),  8. distance, 9. macro (to run after 1 move), 10. rotation, 11. rotation step size])</i><br />
		With this function you can choose to use the input panel by selecting a token and clicking &#39;Animate Move&#39; in the &#39;Animation&#39; window. However this is a bit cumbersome for e.g. casting a fireball. The &#39;better&#39; way is by calling the macro directly.If you give at least the token Id and the x and y coordinates then this function will run automatically with the following &#39;default&#39; settings: relative=0, onImpact=0, layer=&#39;[]&#39;, vbl=0, delay=0.<br />
		<b>- X (#cells)</b>: The destination X coord of the token, either absolute or relative to its current position<br />
		<b>- Y (#cells)</b>: Dito X, but then Y<br />
		<b>- Relative (1/0)</b>: Unchecked: the actual map coordinates are taken for the x and y values and the token is moved to those coordinates. Checked: the relative position of the token is taken and the token is moved x steps in the X direction and y steps in the Y direction. E.g. Relative 3,2 will move the token 3 cells to the right and 2 down<br />
		<b>- onImpact - Bounce (-1)</b>: if the token encounters an obstacle it will change its course depending on the angle of impact. Note that there are only 3 trajectories supported: invert X, invert Y and invert Both. An &#39;obstacle&#39; is defined by the below settings.<br />
		<b>- onImpact - Continue (0)</b>: the token is moved to its destination no matter what<br />
		<b>- onImpact - Stop (1)</b>: the animation stop as soon as it meets an obstacle<br />
		<b>- Token (and the other) layer(s)</b>: &#39;The &#39;checked&#39; layers will be searched for obstacles&#39; where the token can run into while its moving<br />
		<b>- Vision Blocking Layer</b>: This will take the vision blocking layer into account as well for possible impact. Note however that this works on sight of the token, so if the token has no sight EVERYTING is blocked vision and it will thus not move (it might move backwards a bit due to the code). This also accounts for hardfog, no light, etc.<br />
		<b>- Delay (ms)</b>: The delay per movement made, this is in ms so a value of 1000 means wait 1 second before you move the token again.<br />
		<b>- Distance (#cells)</b>: Distance in cells to travel, regardless of end position<br />
		<b>- Macro </b>: A macro that will be run after every iteration/step/move (e.g. '[runme()]'), set to 0 or '' if unused<br />
		<b>- R (#degrees)</b>: How many degrees the token rotates<br />
		<b>- R-Stepsize (#degrees)</b>: The amount of degrees per step. The higher the number, the faster the rotation<br />
		<br />
		Note that if you have a Server - Client running, that the server must have <b><i>Strict Token Ownership</i></b> turned <b>ON</b>. If its turned off, then the players clients will see the &#39;ghosting&#39; effect as well (because this trick makes use of the &#39;visible to owners only&#39; setting, but if there is no &#39;strict ownership&#39;, everyone is the owner and thus everyone will see the copies as well.). In this case its better to turn off <i>Run animation per client</i> off in the settings. Also if you have two instances running on one pc (e.g. for laptop-beamer setup) it might be better to turn this setting off.	<br />
		<br />
		<i><b>Example use:</b><br />
		[bot_animateMove('Dragon', 12, 12, 1, -1, '[&quot;token&quot;,&quot;object&quot;]', 1, 0, 0, '[broadcast(&quot;One step for this Dragon...&quot;)]', 360, 10)]</i>
		</p>

	<p>
		<font color=red><b>bot_createSplices</b></font><i>(list or array)</i><br />
		This function can be used for foreach() loops where the entered list contains (potentially) more then 1000 items. This will normally create an error as maximum 1000 items are allowed. This function will return an array with lists, eacht list consisting out of exactly 1000 items so: &quot;1,2,..,1099&quot; will return [&quot;1,2,..1000&quot;, &quot;1001, 1002,..1099&quot;]. Then you can use two foreach loops to cycle through the list.</p>
	<p>
		<font color=red><b>bot_delay</b></font>(time)<br />
		delays the function with &#39;time&#39; ms<br />
		<b>- time: </b>milli seconds, so 1second is 1000.</p>
	<p>
		<font color=red><b>bot_debugInfo</b></font><i>(vars [, oneLine, showTok, pause, macroName, macroLocation])</i><br />
		broadcasts all the listed variables and their current values either on one line (1) or beneath eachother (0)<br />
		<b>- vars</b>:			list of variables you want to track while debuggin<br />
		<b><i>Optional Arguments</i></b><br />
		<b>- oneLine</b>:		(0) all variables in one column; (1) (default) all variables on one line<br />
		<b>- showTok</b>:		(0) show nothing; (1) (default) show current token and impersonated token<br />
		<b>- pause</b>:			(0) dont pause on debug line; (1) pause on debug line AND show a frame with the debug results<br />
		<b>- macroName</b>:		to make use of this you need to enter <i>getMacroName()</i> as argument<br />
		<b>- macroLocation</b>: to make use of this you need to enter <i>getMacroLocation()</i> as argument<br />
		<i><b>Example use:</b><br />
		[bot_debugInfo( &#39;X, Y, Name, Strength&#39;, 0, 1, 1, getMacroName(), getMacroLocation() )]</i>
		
	<p>
		<font color=red><b>bot_execAllPlayers </b></font><i>(macroNname, arguments[, players, output to])</i><br />
		This macro executes the macro &#39;macroName&#39; on ALL SELECTED clients.<br />
		<b>- macroName</b>: name of the macro to execute: e.g. runThisMacro@lib:token<br />
		<b>- arguments</b>: the arguments to pass on to that macro (in the form of an json array)<br />
		<b>- players</b>: a list of PLAYER names where to execute on (so not their token names). Defaults to &#39;all&#39;<br />
		<b>- output to</b>: Send resulting output of macro to whom (self, gm, all, none, gm-self, list). Defaults to &#39;none&#39;
		</p>
		
	<p>
		<font color=red><b>bot_findDuplicates</b></font>()<br />
		returns ALL duplicate token (names) from ALL layers on the current map.</p>

	<p>
		<font color=red><b>bot_getGridSize</b></font>()<br />
		returns current size of grid in pixels per cell.</p>
	<p>
		<font color=red><b>bot_getTokenFacing</b></font>(<i>[angle, type]</i>)<br />
		all settings are optional<br />
		<b>- angle:</b> angle in degrees<br />
		<b>- type:</b> (0) convert angle from (-180 to 180) to (0-360) ; (1) also inverts rotation to CW and gives an offset of +90 so &#39;no token facing&#39; ends up to be 0 instead of -90</p>
	<p>
		<font color=red><b>bot_getPath</b></font>(<i>[showPath, units, id]</i>)<br />
		all settings are optional<br />
		This function returns ALL points where the direction of the tokens' path changed. For an unsnapped token these are the way points, for a snapped token also the points will be added for non 45 degree angle diagonal movement. This function can also be used to show the entire path including the facing direction. In addition it can *show* the path by placing feet tokens on it path.<br />
		<b>- showPath: </b> (0) (default):do not show the path (just return the waypoint); (1) show the path (with feet token) and REMOVE the last shown path , (2)  show the path (with feet token) and DO NOT REMOVE the last shown path, (3) REMOVE the last path shown on the map</b> <br />
		<b>- units: </b> (0) return the coordinates in cells ; (1) (default) return the coordinates in pixels<br />
		<b>- id: </b>token id or name<br /></p>
	<p>
		<font color=red><b>bot_getTokensPath</b></font>(<i>token1, token2[, staircasing, units]</i>)<br />
		This function returns an json array containing the coordinates of all the cells (including the tokens positions) between the two given tokens.<br />
		<b>- token1: </b>starting token name or Id, its coordinates will be the first coord in the array<br />
		<b>- token2: </b>ending token name or Id, its coordinates will be the last coord in the array<br />
		<b>- staircasing:</b>(1) (default) no diagonal connection between cells so the 'next' cell will always be n/s/e/w of the current cell. (0) diagonal connection allowed, so ne/nw/se/sw are allowed as well. <br />
		<b>- units: </b>(1) return coordinates in pixels; (0) (default) return coordinates in cells<br /></p>
	<p>
		<font color=red><b>bot_getValidTokens</b></font><i>(useCurrentMap, conditions, use_none, startsWithTxt)</i><br />
		ALL arguments are optional<br />
		This function does not return anything but operates in the same scope and will create several types of lists of tokens from the BASE map. For every list there is also a &#39;graphic&#39; list accompanyin it giving it the option to use for the input LIST function. Have a look at &#39;summonToken&#39; function to better understand its workings.<br />
		<b>- useCurrentMap</b>: (0) use BASE map ; (1) use CURRENT map<br />
		<b>- conditions</b>: read the wiki conditions for getTokenNames(), defaults to &#39;{}&#39;<br />
		<b>- use_None</b>: will add &#39;None&#39; as first option for all lists, defaults to 1<br />
		<b>- startsWithTxt</b>: allows for a partial search string to return. Defaults to &quot;&quot;</p>
	<p>
		<font color=red><b>bot_ids2Names</b></font><i>(tokList)</i><br />
		This function returns a list of token names.<br />
		- <b>tokList</b>: a list of token ID&#39;s.</p>
	<p>
		<font color=red><b>bot_inStr</b></font><i>(string, searchStr)</i><br />
		This function returns 0 when searchStr is NOT found within string, ELSE it will return a number not 0.</p>
	<p>
		<font color=red><b>mod</b></font>(<i>number, modNumber</i>)<br />
		return the modNumber modulus of number</p>
	<p>
		<font color=red><b>odd</b></font><i>(number)</i><br />
		returns 1 is the number is odd else 0.</p>
	<p>
		<font color=red><b>pause</b></font><i>(variable1, variable2, etc.)</i><br />
		this stops the running code and shows the current value of the variable. Note the &quot;quotes&quot; which are required!</p>
	<p>
		<font color=red><b>bot_rotateGroup</b></font><i>(degrees [, tokens])</i><br />
		this rotates a group of tokens in respect of eachother, regardless of size. The one condition is that the tokens must NOT be set tofreesize.</p>
		<b>- degrees</b>: multiples of +/-90 degrees, where + is CCW and - CW<br />
		<b><i>Optional Argument</i></b><br />
		<b>- tokens</b>: List of tokens to rotate. Defaults to currently selected tokens</p>
	<p>
		<font color=red><b>bot_round2Grid</b></font><i>(coordinate [, gridsize])</i><br />
		this rounds a coordinate exactly to the current gridsize. E.g. in a 50 size grid, the argument 55, will return 50. 122 will return 100 etc.</p>
		<b>- coordinate</b>: any number, usually a coordinate to which a function is applied<br />
		<b><i>Optional Argument</i></b><br />
		<b>- gridsize</b>: this is the number it will be rounded to. If no argument is given the gridsize of the current map is taken.<br />
		<i><b>Example Use:</b><br>
		[bot_round2Grid(70)] - will return 50 for a 50 gridsize map, 75 for a 25 gridsize map and 100 for a 100 gridsize map.</i></p>
	<p>
		<font color=red><b>bot_ppc2GridCoord</b></font><i>(coordinate [, gridsize])</i><br />
		This will translate a 'pixel per cell' coordinate in a 'grid cell' coordinate. E.g. on a 50 pixel per grid size map (so ppC is 50) the coordinate 150 will return 3 (third grid cell)</p>
		<b>- coordinate</b>: a coordinate in pixels per cell, usually a multiple of the gridsize<br />
		<b><i>Optional Argument</i></b><br />
		<b>- gridsize</b>: this is the number it will be rounded to. If no argument is given the gridsize of the current map is taken.<br />
		<i><b>Example Use:</b><br>
		[bot_ppc2GridCoord(100)] - will return 2 for a 50 gridsize map, 4 for a 25 gridsize map and 1 for a 100 gridsize map.</i></p>
	<p>
		<font color=red><b>bot_seekToken</b></font><i> ([returnArg(0/1), findStr(string), layers(json object), maps(list), libTokens(0/1)])</i><br />
		This macro searches ALL maps and ALL tokens and returns a list of those tokens of which their name (partially) matches with the entered search string.<br />
		ALL arguments are optional. IF only one map then this function returns a list of found tokens, IF multiple maps, then this function will return a json object with the map as key.<br />
		- <b>returnArg</b>: (1) the given arguments are used and NO input screen will pop-up. Basically if you want to use this as a function you need to start it with &#39;1&#39;<br />
		- <b>findstr</b>: the string to look for in the token, default is &quot;&quot;<br />
		- <b>layers</b>: to look in, default is [&quot;TOKEN&quot;, &quot;HIDDEN&quot;, &quot;OBJECT&quot;, &quot;BACKGROUND&quot;],<br />
		- <b>maps</b>: the maps to look into, default is current map<br />
		- <b>libTok</b>: (0) (default) is do NOT return any found lib tokens; 1 is DO return any libtokens.</p>
	<p>
		<font color=red><b>bot_setTokenFacing</b></font>(angle [, token,type])<br />
		This function sets the token facing according to the &#39;normal&#39; polar coordinate system, instead of the rather convoluted MT system.<br />
		<b>- angle:</b> angle in degrees<br />
		<b>- token:</b> token id<br />
		<b>- type</b>: (0) (default) is use the default MT way; (1) is use the generally accepted Polar Coordinate system way (360-angle-90).</p>
	<p>
		<font color=red><b>bot_showHTML</b></font><i>(string)</i><br />
		This function will pop-up two forms, one with the &lt;html&gt; code and the other with the result. This is purely for debug purposes and works best when followed by a pause().</p>
	<p>
		<font color=red><b>bot_snapAngle</b></font><i>(token [,divider, align])</i><br />
		This function aligns the facing of a token to the closest angle given along a divider and returns the new angle<br />
		e.g a divider of 4 will face a token to either -90 0 90 or 180 depending on where its closest at<br />
		you can also turn off the align and just return the closest angle<br />
		token: id of the token<br />
		divider: the number of allowed facing angles<br />
		align: 1 is set the token facing to the closest divider angle, 0 is just return the closest angle. Defaults to 1</p>
	<p>
		<font color=red><b>bot_sortTokByProp</b></font><i>(propertyName[,sortOder, tokenList)</i><br />
		Returns an array token Ids or Names of given or selected tokens, sorted by given property.<br />
		<b>- propertyName:</b> name of the property, e.g. 'Strength'<br />
		<b>- sortOrder:</b> 'asc' or 'desc' (defaults to asc)<br />
		<b>- tokenList:</b> list or array of token names or ids (defaults to selected tokens)</p>
	<p>
		<font color=red><b>bot_switchMap</b></font><i>([mapName [,playerNames]])</i><br />
		Switches the users listed in playerNames to the map mapName.<br />
		<b>- mapName:</b> name of the map to switch to<br />
		<b>- playerNames</b> EITHER: a list of users that are logged in OR 1. The latter switches ALL connected users to the new map.
		<i><b>Example Use:</b><br>
		[bot_switchMap()] - gives pop-up where you can select map and the user(s) to switch<br>
		[bot_switchMap(&#39;Fair Haven&#39;)] - gives pop-up where you can select map (&#39;Fair Haven&#39; is pre selected) and the user(s) to switch<br>
		[bot_switchMap(&#39;Fair Haven&#39;, &#39;Carry, Tom, Burt&#39;)] - moves Carry, Tom and Burt to the new map<br>
		[bot_switchMap(&#39;Fair Haven&#39;, 1)] - moves ALL players to the new map<br>
		</i></p>
	<p>
		<font color=red><b>bot_travelAngle</b></font><i>(x1,y1,x2,y2)</i><br />
		Returns the angle (within a resolution of 45 degrees) in which the token is travelling.<br />
		<b>- x1,y1:</b> coordinate where the token starts<br />
		<b>- x2,y2:</b> coordinate where the token ends</p>
	<p>
		<br>
		<u><b>MESSAGE MACROS</b></u></p>
	<p>
		<font color=red><b>bot_message</b></font><i>(0:message [, 1:headertxt, 2:color (bgcolor-txtcolor), 3:userList, 4:token, 5:target, 6:broadcast])</i><br>
		Broadcasts a preformatted message to all users (default). The message consists out of a black (bg) and white (txt) header (default) and a delimited textbox below it, containing the message. When the message is left empty (&#39;&#39;) only the header will be displayed. bot_message contains the following optional parameters (only message is required):<br />
		<b>- message:</b> The message displayed<br />
		<b>- headerText:</b> This defaults to: &#39;&#39;. The text in the header, note that the &#39;token&#39; parameter is set in the header as well on the left side. E.g. when token=&#39;Wolf&#39; and headerTxt=&#39;Attacks&#39; the header will read &#39;Wolf Attacks&#39;<br />
		<b>- color:</b> This defaults to &#39;black-white&#39;. Here you can set the backgroundcolor-textcolor of the header. You can choose also to only set the backgroundcolor. Some examples: &#39;red&#39;, &#39;black-yellow&#39;, yellow-red&#39;.<br />
		<b>- userlist:</b> Defaults to all(). Here you can set to whom the message should be send. You can either fill in a user name yourself (NOT TOKEN NAME!) e.g. &#39;Frank&#39; or you can make use of one of the user functions defined here below, e.g. all(), gm(), ownergm().<br />
		<b>- token:</b> Defaults to &#39;&#39;. Here you can give the name of the token to which the message reflects. The effect is that the image and name of the token appears left in the header<br />
		<b>- target:</b> Defaults to &#39;&#39;. Here you can give the name of another token to which the message reflects. The effect is that the image of tha token appears right in the header<br />
		<b>- broadcast:</b>: (0) the message is NOT broadcasted but the entire structure is returned. This is usefull is you want to e.g. embed the result in another message; (1) (default) the message is immediately broadcasted<br>
		<i><b>Examples Use:</b><br>
		[resultMsg = bot_message(&#39;Hello world&#39;, &#39;Header&#39;, &#39;black-white&#39;, bot_all(), &#39;Wolf&#39;, &#39;&#39;, 0)]<br>
		[bot_message(&quot;Hellow world&quot;)]<br>
		[bot_message(&quot;this message is shown to gm only&quot;, &quot;GM Only&quot;, &quot;red-yellow&quot;, bot_gm())]<br>
		[bot_message(&quot;this message is shown to all but gm&quot;, &quot;The rest&quot;, &quot;yellow-red&quot;, bot_ngm())]<br>
		[bot_message(token.name+&quot; Takes damage&quot;, &quot;is attacked&quot;, &quot;black&quot;, all(), &quot;Troll&quot;, &quot;Elf&quot;)]<br>
		</i></p>
		<br>
		The following functions can be used in conjunction with bot_message() and return a JSON ARRAY (e.g. [&quot;Frank&quot;,&quot;Jim&quot;,&quot;Suzy&quot;])<br>
		<b>- <font color=red>bot_all</font>():</b> all users<br />
		<b>- <font color=red>bot_gm</font>():</b> gm(s) only<br />
		<b>- <font color=red>bot_ngm</font>():</b> all but NOT gm(s)<br />
		<b>- <font color=red>bot_self</font>():</b> initiator of the macro<br />
		<b>- <font color=red>bot_nself</font>():</b> all but NOT initiator of the macro<br />
		<b>- <font color=red>bot_selfgm</font>():</b> gm(s) and initiator of the macro<br />
		<b>- <font color=red>bot_nselfgm</font>():</b> all but NOT gm(s) and initiator of the macro<br />
		<b>- <font color=red>bot_ownergm</font>():</b> gm(s) and owners of the currentToken. So NOT the token that you might give as a parameter to the bot_message() function but the token that is currentToken() at that moment.<br />
		<b>- <font color=red>bot_nownergm</font>():</b> all but NOT gm(s) and owners of the current token</p>
		<br>
		<br>
		The 'bot_' prefixes in all these function are added as a precaution to make sure that there are no conflicts with a framework in which you use the BoT. If you however want to use these 'retrieve user' functions but without the 'bot_' prefix you need to create your own set of user defined functions. To do this paste the following piece of code in any onCampaignLoad macro in your framework:<br>
		<br><i>
		[H: &#39;&lt;!-- ONTOKENMOVE MACROS --&gt;&#39;]<br>
		[defineFunction(&quot;self&quot;, &quot;self@lib:OnTokenMove&quot;,1,1)]<br>
		[defineFunction(&quot;nself&quot;, &quot;nself@lib:OnTokenMove&quot;,1,1)]<br>
		[defineFunction(&quot;all&quot;, &quot;all@lib:OnTokenMove&quot;,1,1)]<br>
		[defineFunction(&quot;gm&quot;, &quot;gm@lib:OnTokenMove&quot;,1,1)]<br>
		[defineFunction(&quot;ngm&quot;, &quot;ngm@lib:OnTokenMove&quot;,1,1)]<br>
		[defineFunction(&quot;selfgm&quot;, &quot;selfgm@lib:OnTokenMove&quot;,1,1)]<br>
		[defineFunction(&quot;nselfgm&quot;, &quot;nselfgm@lib:OnTokenMove&quot;,1,1)]<br>
		[defineFunction(&quot;ownergm&quot;, &quot;ownergm@lib:OnTokenMove&quot;,1,1)]<br>
		[defineFunction(&quot;nownergm&quot;, &quot;nownergm@lib:OnTokenMove&quot;,1,1)]<br>
	</i></p>
	
	<p>
		<br>
		<u><b>GEOMETRIC MACROS</b></u></p>
	<p>
		The Geometric functions allow you to:<br>
		- create shapes on the map (<b>bot_show...</b>), <br>
		- check whether a point or token is on the shape (<b>bot_pointOn...</b>) and <br>
		- select all tokens within the shape (<b>bot_selectOn...</b>). <br>
		<br>
		for different types of shapes:<br>
		- <b>Circle</b>,<br>
		- <b>Cone</b>, <br>
		- <b>Triangle</b>, <br>
		- <b>Square</b> and<br>
		- <b>Line</b><br>
		<br>
		Some of these functions can be passed on different types of parameter, depending on what you want. For example bot_pointOnCircle can be passed a point (xp,yp) as parameter or a token (tok). The function checks in this case the number of parameters passed on and from that number derives which type of parameters you submitted. <br>
		<br>
		The following parameters are used<br>
		- <b>xp,yp</b>: these are GRID coordinates e.g. 0,0 is the origin of the map. These are coordinates that are checked whether they are on the shape. The function will thus return true (1) or false (0)<br>
		- <b>x1,y1,x2,y2,x3,y3</b>: these are also GRID coordinates e.g. 3,5 or 2,6. These form the edge or the shape. E.g. for a line x1,y1 is the beginning of the line and x2,y2 the end. x3,y3 is only used to define the triangle.<br>
		- <b>me</b>: this is the centre token, e.g. when drawing a circle, then the circle will be centered around me. When checking whether tok is on the circle, then me is again the centre of that circle<br>
		- <b>range</b>: this is the distance from the centre of the shape (e.g. me) to the edge. The distance is in CELLS (so not in distance per cell)<br>
		- <b>arc=angle</b>: this is the angle of the arc of the triangle or cone in degrees. Typical numbers are 30, 45, 60 and 90 degrees. Here 90 degrees is a quarter of a circle. <br>
		- <b>drawToken</b>: when the shapes are drawn on the map a token is used to draw the shape. This token is copied on the background and the ids of the copied token are returned (so you can easily delete them later on). drawToken is the NAME of the token. Note that this token has to be on the BASE map. E.g. 'Boom'.<br>
		<br>
			
		<font color=red><b>bot_pointOnCircle</b></font><i> (xp,yp, me, range)</i> OR <font color=red><b>bot_pointOnCircle</b></font><i> (tok, me, range) </i><br>
		Checks if a point (p) or token (tok) is on a circle centered on me with range r<br>
		<br>
		<font color=red><b>bot_selectOnCircle</b></font><i> (me, range)  </i><br>
		Selects all tokens inside of the shape <br>
		<br>
		<font color=red><b>bot_showCircle</b></font><i> (me, range, arc=angle, drawToken)  </i><br>
		This is a completely redundant functions as everything is done by bot_getCircleCoords, but for function name consistancy this is added. Returns coordinates of the circle and does NOT draw it when drawToken=='' ;  returns the ids of the copied tokens and DOES draw it, when drawToken !='' <br>
		<br>
		<font color=red><b>bot_pointOnCone</b></font><i> (xp,yp, me, range, arc=angle)  </i> OR <font color=red><b>bot_pointOnCone</b></font><i> (tok, me, range, arc=angle)  </i><br>
		Checks if a point is on a cone, DOES include boundary <br>
		<br>
		<font color=red><b>bot_selectOnCone</b></font><i> (me, range, arc=angle)  </i><br>
		Selects all tokens inside of the shape <br>
		<br>
		<font color=red><b>bot_showCone</b></font><i> (tok, range, arc=angle, drawToken)  </i><br>
		Returns an array with all coords of the cone. Draws the cone on grid if option set true<br>
		<br>
		<font color=red><b>bot_pointOnSquare</b></font><i> (xp,yp, me, range)  </i> OR <font color=red><b>bot_pointOnSquare</b></font><i> (tok, me, range)  </i><br>
		Checks if a point (p) is within range of me, assuming a square area with range (me, edge square) <br>
		<br>
		<font color=red><b>bot_selectOnSquare</b></font><i> (me, range)  </i><br>
		Selects all tokens inside of the shape <br>
		<br>
		<font color=red><b>bot_showSquare</b></font><i> (me, range, drawToken)  </i> OR <font color=red><b>bot_showSquare</b></font><i> (x1,y1, x2,y2, drawToken)  </i><br>
		Returns an array with all coords of the square draws the square on grid (if option set true)<br>
		<br>
		<font color=red><b>bot_pointOnLine</b></font><i> (xp,yp, x1,y1, x2,y2)  </i> OR <font color=red><b>bot_pointOnLine</b></font><i> (xp,yp, me, range)  </i> OR <font color=red><b>bot_pointOnLine</b></font><i> (tok, me, range)  </i><br>
		Checks if a point (p) or token (tok) is on a line between 2 points (1 and 2) or on a line casted from me, DOES include boundary <br>
		<br>
		<font color=red><b>bot_selectOnLine</b></font><i> (me, range)  </i><br>
		Selects all tokens inside of the shape <br>
		<br>
		<font color=red><b>bot_showLine</b></font><i> (x1,y1, x2,y2, drawToken)  </i> OR <font color=red><b>bot_showLine</b></font><i> (me, range, drawToken)  </i><br>
		Returns an array with all coords of the line. Draws the line on grid (if option set true)<br>
		<br>
		<font color=red><b>bot_pointOnTriangle</b></font><i> (xp,yp, x1,y1, x2,y2, x3,y3)  </i> OR <font color=red><b>bot_pointOnTriangle</b></font><i> (xp,yp, me, range, arc=angle)  </i> OR <font color=red><b>bot_pointOnTriangle</b></font><i> (tok, me, range, arc=angle)  </i><br>
		<br>
		Checks if a point is between three points, DOES include boundary <br>
		<br>
		<font color=red><b>bot_selectOnTriangle</b></font><i> (me, range)  </i><br>
		Selects all tokens inside of the shape <br>
		<br>
		<font color=red><b>bot_showTriangle</b></font><i> (x1,y1, x2,y2, x3,y3, drawToken)  </i> OR <font color=red><b>bot_showTriangle</b></font><i> (me, range, arc=angle, drawToken)  </i><br>
		Returns coordinates of the triangle and draws it on grid if options set true <br>
	</p>
	
	<p>
		<u><b>Some functions that are not of my hand but as there was a need for them I implemented them into the BoT</b></u></p>
	<p>
		<font color=red><b>bot_pi</b></font>()</p>
	<p>
		<font color=red><b>bot_cos</b></font>(radians)</p>
	<p>
		<font color=red><b>bot_sin</b></font>(radians)</p>
	<p>
		<font color=red><b>toRadians</b></font>(degrees)</p>

	"]

	[r, if(bot_isFullScreen()), CODE:{
		[r,dialog("BoT Functions Manual", "temp=0; closebutton=0; width=800; height=600; input=1"): {[r:output]}]
	};{
		[r,frame("BoT Functions Manual", "temp=0; closebutton=0; width=800; height=600"): {[r:output]}]
	}]

@@manualText
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=2 ; color=darkgray ; playerEditable=true ; applyToSelected=false ; group=Util ; tooltip= ; minWidth=90 ; 
[h:output = "
<font color=red><b><u>ON TOKEN MOVE MANUAL</u></b><br></font>
<br>
A first and foremost rule that applies to ALL SPECIAL PADS: DO NOT ROTATE THE TOKENS!! Of course if they're square or round it does not matter, but if they're rectangles you cannot rotate them as the 'footprint' will remain unrotated. So you CAN RESIZE but you CANNOT ROTATE<br>
<br>
<b><u>Big change between version 9 and 10: Pits and Traps have been replaces by EventPads.</u></b><br>
I've written a conversion tool (Convert Trap/Pits - ONLY on the lib:OnTokenMove, NOT in the BoT-macro panel) to convert campaign files created in version 9 or earlier, which make use of the Pits and Traps. 
You will only need to run this macro once for the whole campaign file. 
In addition you will need to rewrite the code for the Pit macros a bit, as the passed on arguments differ and the 'Trapped' state is no longer required. 
Finally you need to move ALL macros you created for pits and traps to the new lib:MacroEvents token. <br><br>

<font color=red><b><u>UPGRADING TO A NEW VERSION</u></b><br></font>
With the addition of the lib:EventMacros you no longer need to redo all your settings nor need to move or copy paste any personal event macros that you created on that lib. All *your* settings are stored on lib:Eventmacros. So when you upgrade a version you ONLY need to do 2 things:<br>
1. replace the lib:OntokenMove for the new one (delete first, then drag the new one on your map)<br>
2. run settings once!<br>
Note that when you run the settings that its possible that you get some *errors* in the form of input request for strange variables. These are the new settings that have been added but obviously not yet set on *your* lib:eventMacros. You only need to click 'ok' (depending on the update this can be many clicks) and then the settings menu will eventually pop-up. Always check the settings (they should not have changed) and then finally click ok. If you *did* get the input requests then very likely you will notice that there are more settings available. If you only only clicked 'ok' during the input requests, then they all should be turned off by default.<br>
THAT'S IT!<br>
<b>If you upgrade from version 13x or lower</b> then you will also need to update the table (see implementation section). It is also prudent to update the lib:EventMacros (for the latter its enough to update the macros, but if you have none of you own I would advise to simply update the entire lib).<br>
<br>
<font color=red><b><u>IMPLEMENTATION</u></b><br></font>
Below you can find a general and rough guide for implementing the BoT. A more detailed and up to date version can be found <a href = 'http://forums.rptools.net/viewtopic.php?f=46&t=16066'>here</a>.<br>
The necessary bare actions needed to get this thing on the road, I've put in <b>(parenthesis)</b> for which feature this step is required:<br>
- If you just dropped the .rptok file onto a map, run onCampaignLoad first (though if you're reading this you likely did<br>
- <b>(Summon Tokens) (=macro):</b> Drag the image_none.png to the base map.<br>
- <b>(Roof & Foliage):</b> Load .mttable file from the special tokens into the tables panel<br>
- <b>(Canopy):</b> Make sure there is a map called 'BASE' (either rename the map or change this in the Settings)<br>
- <b>(Alt. Init. Token):</b> Drag the lib:Coords.rptok token onto (BASE) map<br>
- <b>(EventPads):</b> Requires a lib:EventMacros token with at least one macro on it. <br>
- <b>(Token Door Switches):</b> Create 'isButton' state:<br>
&nbsp; &nbsp; * Click on an existing state first (you can only add a state if you select one first ?!?)<br>
&nbsp; &nbsp; * Change name to 'isButton'<br>
&nbsp; &nbsp; * Change type to Image, you can load the 'State.isButton.png' as state image.<br>
&nbsp; &nbsp; * Click add and close<br>
&nbsp; &nbsp; * Also Create 'Locked' state. Show To: GM Only, Type: Image, you can load the 'State.Locked.png' as state image.<br>
&nbsp; &nbsp; * Drag the Lever.rptok file onto the 'BASE' map. MAKE SURE YOU HAVE CREATED THE ISBUTTON STATE <B>BEFORE</B> YOU DRAG THIS TOKEN ONTO THE MAP<br>
- <b>(Path Tracking):</b> Create 'pathFeet' state (image State.pathFeet.png)<br>
- <b>(Event Areas):</b> Create 'Special Area' state (image State.Special Area.png)<br>
- Select the lib:onTokenMove and Drag the '(drag to) Campaign Macros' which you want to use to the Campaign panel (though its enough to only drag the 'Bag of Tricks Macro' macro).<br>
- Run the 'Settings' macro, here you can exclude maps from the initialization (checked) check if these are set right.<br>
Off you go.<br>
<br>
<font color=red><b><u>REPORTED MISHAPS</u></b><br></font>
<b>GENERAL REMARK:</b> note that YOU CAN ONLY HAVE ONE <font color=#FF0000><b>'ONTOKENMOVE' MACRO</b></font> IN YOUR CAMPAIGN. So if you e.g. create a backup of the old lib token, you will have 2!! One on the backup lib and one on the new one. Stuff will go haywire!! (actually you *can* have two ontokenmove macros within a campaign, but they will both be activated on the event, which very likely will have unpredictable results. In short: its bad practice)<br>
<b>THE PADS DON'T WORK:</b> There can be several reasons: <br>
1. the onTokenMove event is turned off. This can be checked by checking te name in group 2. on the lib:OntokenMove: if it says #onTokenMove its turned off. Hit the 'Turn On Token Move Event On/Off' macro. <br>
2. you just dragged the libs onto your map and you forgot to run onCampaignLoad (or save and reload the campaign file)<br>
3. you forgot to run the settings. <br>
4. 'visible to players' is turned off. Double click on token --> config --> check the checkbox on the right 'visible to players' <br>
 <b>ERROR:</b> if you get an error '<b><font color=#FF0000>Error executing movedOverToken: the token name or id {1} is unknown.</font></b>' this means that the code is looking for a token that is not on the map. Run the 'Initialize Pads' again from the camapaign panel and look through the report.<br>
 <b>ERROR:</b> if you use a interteleport and on destination you're asked for coordX and coordY then you the two paired interteleports do NOT have the same name/number. Run the 'Initialize Pads' again from the camapaign panel and look through the report.<br>
<b>ISSUE:</b> when snap to grid is turned of and you try to teleport more than 2 tokens that overlap, the teleport MIGHT not work.<br>
<b>ERROR: Can't find map '1' (or any other number).</b> If you name your maps 01, 02 or 001, 002, etc. then in the code MT script will transform these 'numbers' into real numbers: 1,2,etc and those maps do not exist. So make sure that the map name cannot be recognized as a number OR be making it an actual number. So 1,2,3 would work and 01m, 02m, etc. also.<br>
5. there is a lib:Coords token on the map (white token with blue cross hairs). This appears when using alt.init.map. When you change the map you'll need to run both this macro on that map AND Initialize Pads. If you no longer wish to make use of the alternative method, you'll need to delete the lib:Coords from that map. Note that there is also a lib:Coords on the BASE map. This one is not used. Only the ones where the map name is after the 'lib:coords ' are in use. <br>
<br>
<font color=red><b><u>INITIALIZE MAPS AND ALT.INIT.MAPS</u></b><br></font>
When you start using the special pads (described here below). You'll need to initialize the campaign file so the BoT 'knows' that they're there. To do this you need to run Initialize Maps. <b><u>Everytime you add, delete or rename a special pad, you will need to run this again</u></b>. You can however move the tokens (on the same map) anywhere you like. The only thing that initialize maps does is seek and log all the special pads so the on token move event can quickly access them.<br>
There is an alternative to this: alt.init.map. This macro works fundamentally different. It actually maps the coordinates of all the special pads on the map. Then when moving over the map the on token move event can check whether you intersected with an area where a special pad is situated. This means that you'll need to run this macro everytime you create, delete, rename AND move a special pad!! 
The advantage of this method is the fact that when you have a LOT (> 100) special pads e.g. a forest with 'Canopy' tokens then its faster then the traditional method. However it IS slow to initialize (can take 10's of minutes) and it IS generally slower then the initialize maps method.<br>
When using this method you'll notice that a 'lib:Coords <mapname>' is created on the map. On this lib all the spec. pads coords for that map are stored. AS LONG AS THAT TOKEN IS ON THAT MAP IT TAKES PRECEDENCE OVER THE GENERAL INITALIZE MAPS METHOD. As soon as you delete it, then the 'normal' method will be used again. <br>
Notes:<br>
- When using interPads (teleport between maps) on a lib:coords map you need to run both initalize maps and alt.init.maps. As alt.init.maps only works for that map and does not check to which other interPad the interPad is linked. <br>
- In the settings there is a tab to turn off 'initialize maps' for certain maps (again e.g. a forest) this will speed up the initailize method method when you exclude maps which make use of alt.init.maps. Do however keep in mind that when you turn it off, interPads to and from that map won't work!<br>
<br>
<font color=red><b><u>SPECIAL TOKENS</u></b><br></font>
This drop-in runs different macros whenever a token moves over a 'special' pad. The following special pads are supported:<br>
- InterPad n<br>
- PadStart n<br>
- PadEnd n<br>
<br>
- InterPadBorder n<br>
- PadStartBorder n<br>
- PadEndBorder n<br>
<br>
- InterJump n<br>
- InterDrop n<br>
- PadJump n<br>
- PadDrop n<br>
<br>
- InterJumpBorder n<br>
- InterDropBorder n<br>
- PadJumpBorder n<br>
- PadDropBorder n<br>
<br>
- AssignPad [group] [index]<br>
- EventPad n<br>
- Canopy n<br>
- Foliage n<br>
- Roof n<br>
- Linked n1 [Special Pad] n2<br>
- Linked n1 Bridge n2 (i.c.w. Roof, Foliage or Canopy)<br>
- MappedPad n<br>
- ShadowPad n Ground & ShadowPad n Floor<br>
- Ward n<br>
<br>
Where 'n' is a identifier (1,2,3, etc. but with version 26 anything is allowed, so 'Sea', 'Yet another level', 'are you sure' etc. is also possible). This means that these token names are reserved. Should you use such a token nonetheless than this likely will show up in the error report from the 'initialize pads' macro. <br>
[group] and [index] will be explained later with Assignpads<br>
As mentioned, ANY identifier is allowed as long as its unique for that token. Originally this was restricted to numbers only. If you want this back then there is a setting: 'settings > general > Numeric Id for special pads only' that you can check. This way only special pads with a numeric identifier are initialized. Do note however that 'Linked' pads (see below) will not work!! <br>
<br>
<b><u>The rules:</b></u><br>
<b>In general</b>: If you want to use special pads just name a token e.g. 'Ward 1' (without the ''). Name the next 'Ward 2' etc (the numbers do not need to be contiguous). The Initialize map macro will check for duplicates and these will show up in the error report.<br>
<br>
<b>PadStart and Padend</b>: these are used to teleport a token from one to another a token on 'PadStart 1' will be teleported to 'PadEnd 1' and vice versa. So to pair two teleports (start and end) they need to have the same number.<br>
<br>
<b>PadJump and PadDrop</b>: these work exactly the same as PadStart and PadEnd, save the fact that it only works one way: PadJump --> PadDrop, not the other way round. These you can typically use for doors where the interior map of e.g. a house is situated somewhere else, this way a token can step through a door and appear on the interior map, similar the other way round, to exit a building you are teleported back to the 'outside' map<br>
<br>
<b>InterPad</b>: Note that for earlier users that the name has changed, it now starts with a capital letter!<br> These work the same as PadStart and PadEnd only they have the same name and are on different maps. So InterPad 1 on 'Grasslands' and Interpad 1 on 'Plains' are connected to eachother.<br>
<br>
<b>InterJump and InterDrop</b>: these work exactly the same as PadJump and PadDrop only these you use to teleport between maps, just like the interPad<br>
<br>
<b>PadStartBorder, PadEndBorder, InterPadBorder</b>: These work exactly the same as the ones without 'Border' at the end with the subtle difference that these are also activated when you move OVER the token, where with the other teleports you need to step ONTO the token. These can typically be used to make certain that players are teleported to another section when they move over/into a certain section. Note that these work two way, so if tokens keep moving on them they get send to and back. The Jump/Drop versions below can be used to prevent that.<br>
<br>
<b>PadJumpBorder, PadDropBorder, InterJumpBorder and InterDropBorder</b>: These work exactly the same as the ones without 'Border' at the end with the subtle difference that these are also activated when you move OVER the token, where with the other teleports you need to step ONTO the token. These can typically be used to divide larger maps into pieces and divide them over several maps then when a token walk over the 'border' its automatically transferred to the next map. By splitting these up into one way tokens you won't have the issue that when a token walk ONTO the border (and is thus transported) and then moves OVER the border its transported back again. The token actually will need to take a step 'back' (onto another one way telport back, if you put it there) before its transported.
<br><br>

<b>AssignPad</b>: AssignPad: These are teleport tokens to which you can assign ONE token. This token will be teleported as soon as the assign pad event is executed. Hence there are two supporting macros:<br>
-  'Assign Tokens to Pads' and <br>
- 'Execute AssignPads'. <br>
<br>
To set these up you need tokens called 'AssignedPad Group Index'. Where 'Group' and 'Index' can by anything alphanumeric (so 1,2,3, etc and a,b,c,d, etc. and NOT ',<>?! etc. ) Some examples AssignedPad Red 1, AssignedPad Red 2, AssignedPad Alpha Jim, AssignedPad Alpha Tom. You can also leave out the group: AssignedPad 1, AssignedPad 2. <br>
<br>
The advantage of groups is that the assign and execute macro menus will have a tab per group so you can more easily assign tokens and you can choose more easily to execute certain groups instead of all the pads.<br>
If you want to execute the teleportation without any interface, e.g. as part of an event then you can use the following line of code to do this:<br>
[h:bot_execAssignPads(1)]<br>
Its also possible to execute only one group (e.g. 'Red') as follows:<br>
[h:bot_execAssignPads(1, 'Red')]<br>
<br>
<i><u>Notes:</u></i><br>
- You do NOT need to run 'initialize pads' for these tokens to work<br>
- You DO need to run 'assign tokens to pads' before these tokens work<br>
- Make sure that there are no double or trailing spaces in the name e.g. 'AsssignPad..Attack.5.' (replaced ' ' with '.' for illustration) will generate an error.<br>
- When you execute, you can turn off entire groups in the first tab, you do NOT need to turn of the checks for those pads individually in there corresponding tab.<br>
- ALL the tokens need to be on the same map. Interteleport is NOT possible.<br>
<br>

<b>EventPad</b>: These tokens are triggered on certain events, which you can set prior to using them. To set an EventPad simply select one (or more) and click on the 'Set Event Pad'. This will pop up an input screen where you can link any macro that is placed on the lib:EventsMacros token and in addition you can set the token to trigger this macro for one or more of the following events:<br>
- When a token is moved onto the EventPad<br>
- When a token is moved off the EventPad<br>
- When a token is moved over the EventPad<br>
- When a token on the EventPad is moved but then placed back at its original spot (zero move). Note that Zero move event is turned off per default in the settings, so to make use of this event you will first need to turn it on globally in the settings. <br>
- When a token on the EventPad is moved, waypoints are used, but the move ends back on the EventPad<br>
- When a token on the EventPad is moved but remains on the EventPad (e.g. one step left on a big pad)<br>
I have left the original Pit and Trap pad on the map (but converted) so you can still check out how these macros work. The 'reset Pit' (to reset the picture for the opened pit) macro still works.<br>
<br>

<b>Roof</b>: Any token called Roof n,will disappear and leave a red outline (halo) when a token moves over it and reappear when moved away from it.<br>
You can also choose to 'set' a roof with the corresponding button. When you do this you will get a list of doors (if any) which you can check. When you do this the token can only move in or out of the building (roof) through an OPEN door. It is thus vital that its actually an entry (so a door that is on the edge of the roof) and it will only work for doors that have been 'set'. This because you need to open the door before you can enter and an 'open' door can only be detected when its actually 'set'.<br>
<b>Note that the 'warded roofs' only ward players, not gm's!!</b><br>
<br>
An additional feature available from b90+ is 'apply VBL'. When this is checked the current VBL of the building beneath the roof is stored (on the roof token) and the VBL is replaced with a VBL Cross. This VBL Cross will be swapped with the building VBL as soon as a token moves onto the roof. 
<br>Note that this only works AFTER the maps has been 'initialized'<br>
<br>

<b>Foliage</b>: Same function as roof, only without the red outline (halo).<br>
<br>
<b>Canopy</b>: Same function as Foliage, only a tree trunk will appear in its place (see below for more info).<br>
<br>
<b>Linked</b>: Linked pads work for Foliage, Canopy and Roofs (you can mix them). When they are linked all are activated if one is activated (see below for more info). Additionally they can be used for bridges.<br>
<br>
<b>Linked Bridge</b>: Linked Bridge pads are linked pads but the when a token first moves over the bridge token and then over the e.g. linked Roof, the roof is NOT activated (<a href = 'http://bit.ly/1f5wn6X'>see video tutorial</a>).<br>
<br>
<b>ShadowPad</b>: Typically used for two floor maps on one MT map where the upper floor can look out to the ground floor, e.g. loft in a barn. When token on seperate levels step onto these pads a 'shadow token' is created on the other floor.<br>See below for more info.<br>
<br>
<b>MappedPad</b>: These are teleport tokens which you can map. When creating these pads, after initializing you'll get a pop-up where you can map the start destinations<br>
<br>
<b>Ward</b>: Any token called Ward n will prevent a token to be moved on. It will simply return the token to the original spot<br>

<br>
<b><u>THE TELEPORT TOKENS NAME SYNTAX EXPLAINED</u></b><br>
Here a short description of where to think of for which names:<br>
- 'start'/'end' means TWO WAY teleport<br>
- 'jump'/'drop' means ONE WAY teleport, where 'jump' teleports and 'drop' not<br>
- 'inter' means between maps, these tokens are linked by having the SAME name, while e.g. 'start'/'end' (always on the same map) are linked by DIFFERENT names.<br>
- 'border' means that the teleport is activated not only when you step ONTO but also when you MOVE OVER the pad. Withouth the 'Border' they are ONLY activated when THE MOVE ENDS ON THE PAD.<br>
All the pads are linked by their number!! so a 'PadStart 3' will be linked with 'Padend 3' and an 'InterJump 2' on one map will be linked to a 'InterJump 2' on another map. <br>
<br>
<b><u>ADVANCED STUFF ROOF AND FOLIAGE</u></b><br>
First let me explain how the roof and foliage work: in the tables there is an image stored that is completely transparent. When a token moves over either a roof or foliage token the 'roof' or 'foliage' image is removed and stored somewhere else on the token and the transparent image is placed instead of it. This way it looks like the foliage or roof dissapears. The advantage of the table is that that image can be retrieved always, no matter on which map you are. You can however also choose to do this differently by retrieving the image not from the table but from the handout section of the token itself. This has two advantages:<br>
1. You don't need to load the tabel <br>
2. You can use ANY picture. <br>
To show this I've prepped the two trees.<br>
The left tree (Foliage 1) has a seperate token beneath it of a trunk, when you move over it, the foliage will dissapear and you'll see the trunk token. <br>
The right tree (Foliage 2) is a single token (so no trunk beneath it), so when you move over that tree you'll see nothing. However if you look at the token properties you'll notice an image with a trunk in the token handout section.<br>
<br>
Now in the settings you can choose the setting 'Use alternative transparent iamge for foliage', checking this option, will first check the token handout of a token and if it finds an image it will swap it for the foliage image. If not, then it will take the picture from the table. <br>
What you'll see happening now is that the left tree still dissapears, but the right tree will grow semi transparent and a trunk will appear. <br> This method will allow you to create 'special' tokens if you like. <br>
<br>
<b><u>CANOPY</u></b><br>
<b>Requirements</b><br>
- A Map in the campaign file called 'BASE' (you can change this required map name in the settings.)<br>
- Images of tree trunks on that map on the OBJECT layer, which start their name with 'Trunk...'<br>
- Note that the images replace the whole image of the canopy, this means that just an image of a tree trunk will be stretched over the full area of the Canopy image. Therefore you need to edit the trunk image so that a lot of transparent space surrounds it. Have a look in the example campaign to see what I mean. Typically the canopy is 20x the size (diameter) of the trunk, so if e.g. the trunk is 10px wide then the total span of the image must be 200x200 px. (with at the centre a 10x10px trunk image).,
<b>Usage:</b><br>
The tree trunk images need to 'set' first. To do this run the 'choose trunks' macro, this macro will check the 'BASE' (or another map if you changed the settings) map for tokens on the object layer that start their name with 'Trunk...' and will provide a check list from which you can choose which trunks should be used and whic not<br>
Canopy works in the same way as 'Foliage' with one important difference. When you initialize Canopy, the Canopy token handout is checked and when its empty an image of a tree trunk is put there. When you a pc or npc token moves over the canopy token, the canopy image is swapped for a tree trunk image.The tree trunk is randomly selected from the 'set' trunks from the 'choose trunk' macro.<br>
<br>
<b>Draw VBL</b><br>
This operation will only work when you have the 'Support VBL' setting turned on in the general settings. When you click on it, it wil automatically draw a Vision Blocking Layer cross over all trunks of the Canopy pads. The cross will have the size of 1 square. <br>
<br>
<b>Useful Stuff to Know about Canopy, Trunks and Trees</b><br>
- Trunks are usually between 10 and 70 cm (that is 4 inch upto 2ft 4 inch)<br>
- Canopy is typically 20x the size of the trunk so a 10cm trunk has a canopy of 2m (=+/- 2yards) and one of 70cm is 14m. <br>
- The height of the tree = the width of the canopy (roughly)<br>
- Typical spreading of trees in a forest is 5m (so on average 5 meters/yards between trees). The variance is actually very small but if you take into account thin or thick forest this can range between 3 and 7m<br>
<br>

<b><u>LINKED SPECIAL PADS (Roof, Canopy, Foliage & Bridge)</u></b><br>
<b>Requirements</b><br>
The following setting: 'settings > general > Numeric Id for special pads only' must be UNCHECKED!.<br>
<br>
The special pads Roof, Canopy and Foliage can be linked. When linked, they are ALL triggered when a token moves onto one of them. They will remain 'triggered' until no token is positioned on any of them.<br>
To link 2 or more tokens is very simple. Just add 'Linked n' to the front of the token name. 'n' here is the indentifier for the linked tokens. E.g. 'Linked 1' or 'Linked Forest' can be used as identifier. Just make sure that the entire identifier is ONE word (so no spaces), e.g. 'Linked A Forest' will generate an error.<br>
<br>
A special type in de linked tokens are 'bridges'. When a bridge is linked in the set of roofs then the roofs are NOT activated when the token ALSO moves over the bridge token.  <a href = 'http://bit.ly/1f5wn6X'>There is a video tutorial that better shows this.</a>
<br>
<b>Example:</b> lets take a map with the following tokens<br>
- 'Linked 1 Canopy 1' <br>
- 'Linked 1 Canopy 2'<br>
- 'Linked Houses Roof 1'<br>
- 'Linked Houses Foliage 3'<br>
- 'Linked Houses Canopy NextToHouse'<br>
- 'Linked 2 Roof 1' <br>
- 'Linked 2 Bridge 1'<br>

After initialization you will have three linked groups. The 'Linked 1' and 'Linked Houses' group. Now when a token moves over 'Linked 1 Canopy 1' (L1C1) then that image of that pad will be swapped for a tree trunk. At the same time the same will be done for 'Linked 1 Canopy 2' (L1C2). Should you now also move a token on L1C2 and then remove the first token from L1C1, then both pads remain 'activated'. Only after all tokens have moved off both L1C1 and L1C2 will they be de-activated.<br>
As you can see from the second linked group 'Linked Houses', you can use ANY identifier you like as long as it does not contain any spaces (' '). <br>
Finally the Linked 2 group. If you drag a token over Bridge 1 and drop it onto roof 1, then the roof does NOT disappear!. If however you drag a token onto roof 1 WITHOUT moving it first over Bridge 1, then the roof DOES disappear!<br>
<br>

<b><u>SHADOWPADS </u></b><br>
<b>Requirements</b><br>
- Two ShadowPads with the same identifier and one with the ' Ground' suffix and the other with the ' Floor' suffix.<br>
- Two Reference tokens with equal names and the the suffixes ' Ground and ' Floor'.<br>
Shadow pads link two floors of a building to eachother. When a token moves over a ShadowPad on one floor it will 'cast a shadow' on the ShadowPad on the other floor.<br>
The reference tokens are use to align the position of the real and shadow token. The ShadowPads are used to create or remove the shadow tokens. ShadowPads will be activated as soon as one or more tokens are standing on BOTH pads.<br>
Typically you will put the ShadowPads on the background layer and set the size to freesize then size and place them as you wish. You check off 'visible' so the players won't see the pad.<br>
<br>
For the reference tokens you need to do the following:<br>
1. create two tokens with the same name where one has the suffix ' Ground' and the other ' Floor'<br>
e.g. 'Stairs to Ground' and 'Stairs to Floor' or 'Reference Ground' and 'Reference Floor' etc. Only use alphanumerical characters and do NOT use the words 'Floor' or 'Ground' inside the name of the token. So do NOT do e.g.: 'The &quot;Grounds&quot; Ground' 'The &quot;Grounds&quot; Floor'<br>
2. Make sure that the reference tokens are snapped to grid and medium sized.<br>
3. Place one of the tokens on the ground floor and one on the first floor. Make sure that their position is aligned e.g. place both in the upper left corner of the room or in the exact centre etc. Just keep in mind that if you e.g. place the real token just below the reference token, that the shadow token will also be just below the (other) reference token.<br>
You can place them on any layer (so also the hidden) and you can set them to Visible to players or not.<br>
4. Then select one of the reference tokens and hit the 'Set Reference' macro. Select the shadow pads to which it should be linked and hit ok.<br>
<br>
The tricky part here is that the shadow pads will check to which reference token the real token is closest to<br>
and assume it belongs to THAT reference token. So make sure that the real token is always closest to one<br>
reference token on one of the maps. The safest method is by placing the reference tokens in the centre of both<br>
maps.<br>
<br>
To clarify: envision two floors created in maptool adjacent to eachother. So on the left you have the ground <br>
floor and on the right you have the first floor. Now place both reference tokens in the upper LEFT corner of<br>
both floors. Then place the Player token in the upper RIGHT corner of the GROUND floor (left map). In that case <br>
the player token will be closer to the reference token on the FIRST floor (right map). In this case the shadow<br>
pads will thus assume that the player token is on the FIRST floor (e.g. apparently floating outside).<br>
<br>
<font color=red><b><u>EVENT BUTTONS</u></b><br></font>
Event buttons are tokens that, when selected by a user, activate a macro. Here you can think of simply posting a message in the chat, to moving all user to another map. <br>
<br>
<b><u>CREATING EVENT BUTTONS</u></b><br>
<br>
1. Create a macro on the lib:EventMacros token in the group: 'Event Button Macros', containing the code that is activated when the button, e.g. 'Switch To Map' (This is something you will need to do yourself, but I have added two example macro on the lib.)<br>
2. Select the button (any token on the token layer will do) to which that macro should apply e.g. 'Move to Fair Haven'<br>
3. Run the macro 'Set Event Button'<br>
4. Select 'Switch Map' from the list<br>
5. In the 'Give Arguments' box enter the arguments as a stringproperty, e.g.'toMap=Fair Haven'<br>
<br>
Here it is important that both the the arguments name (toMap) and the arguments (Fair Haven)<br>
contain ONLY alphanumeric  characters!<br>
Note that you can give multiple arguments! Just seperate them with a ;.<br>
E.g. toMap=Fair Haven;message=Going to Fair Haven;<br>
<br>
6. Click OK. Now everything is set up<br>
<br>
To use the buttons you need to run the macro 'Activate Switches'. This is used for door switches<br>
but it will also work for the Event Buttons. Now when thats done you will notice a pop-up. You can<br>
make this pop-up small, but you cannot close it (else the buttons will not work).<br>
<br>
If you now click on the button 'Switch to Fair Haven' the macro 'Switch Map' is activated.<br>
<br>
<font color=red><b><u>EVENT PADS</u></b><br></font>
Event pads are tokens that, when a user moves a token on/off/over it, it will activate a macro. Typical use for this is a trap.<br>
These pads are quite similar to Event Buttons, with the difference that here you need to make a move action to activate the pad instead of simply selecting the button.<br>
<br>
<b><u>CREATING EVENT PADS</u></b><br>
<br>
1. Create a macro on the lib:EventMacros token in the group: 'Event Pad Macros', containing the code that is activated when Event is triggered. For example 'Spear Trap<br>
2. Select an 'Event token'. This is a token which name starts with 'EventPad ' e.g. 'EventPad 1' or 'EventPad Pit Trap'. This token can be placed on any layer<br>
3. Run the macro 'Set Event Pad'<br>
4. Pick an Event macro from the list, e.g. 'Standard Pit'.<br>
5. Then select the events on which this macro is triggered. (they have tooltips)<br>
7. Click OK. <br>
8. Run 'Initialize Maps'<br>
Now everything is set up<br>
<br>
To activate the pad you must move a token e.g. onto the pad. The macro will be activated if one of the selected events is triggered.<br>
<br>
<font color=red><b><u>EVENT AREAS</u></b><br></font>
Event areas work roughly the same as Event Tokens. Depending on the movement of the token in respect to the area they trigger a macro. This macro can be a trap a pit or difficult terrain. The difference with the event-tokens is:<br>
- Event tokens can be moved around (on the same map) without the need to reinitialize<br>
- Event tokens are images and as images can be influenced more easily, e.g the crack that turns into a pit when you walk over it.<br>
- Event Areas can be ANY size you like (with a resolution of the grid cells), they can also have holes in them, be seperated all over the map, but they still remain ONE area. <br>
- Event Areas are significantly faster when going for multiple event areas vs event tokens.<br> 
<a href = 'http://bit.ly/YEhS4a'>also see this video tutorial</a><br>
<br>
<b><u>CREATING EVENT AREAS</u></b><br>
<br>
To create an event area you need to do the following:<br>
1. Define the area (the coordinates it covers)<br>
2. Assign the area (to an event macro like the pit)<br>
<br>
<b>Step 1: Define Area</b><br>
What needs to be done is to get cell coordinates inside a json array. To do this there are 2 methods: lastPath and getTokens.<br>
<i>LastPath method</i>: Grab any token with an unique name and (literally) drag it over the map to create a path. You can use the space bar to create waypoint. You can have overlapping paths as the coordinate will only be saved once, BUT you need to do it in ONE go. Once you have the path complete you drop the token:<br>
- start 'Define Token'<br>
- select the 'last path' method<br>
- fill in the name of the token and give a name to the area and click ok. <br>
Now the area is created. This is a pretty simple and easy way to create an area, but you cannot create two seperate parts.<br>
<br>
<i>GetTokens method</i>: Again grab any token, but this time with a unique state. (It has to be the ONLY token on THAT map with THAT state). Copy paste this token over the areas you wish to define. If you have e.g. 5 pits that all 5 use the same event macro then you can create these 5 pit areas in one go (effectively they are thus ONE Defined area, covering 5 parts of the map). Once done:<br>
- start 'Define Token'<br>
- select the 'Use coords...' method<br>
- fill in the name of the STATE <br>
- select the LAYER you put those tokens on <br>
- give a name to the area and click ok. <br>
Now the area is created. This is a bit more work, but note that you can first copy paste 5 tokens, then select all 5 and start copy-pasting with that group, rinse and repeat and you can build pretty large areas in no time using this method. <br>
<br>
Note that there is a 'Reset Show Area Tokens' option at the bottom, I'll get to this later with the 'Show Area' macro.<br>
<br>
<b>Step 2: Assign Area</b><br>
Run the Assign Area macro. Per Area that you created there will be an input section, sorted per map. One input section contains a dropdown box with ALL the macro on the lib:EventMacros, so you will also find e.g. onCampaignLoad, which is not very useful to link. Pick the macro from the list that you created for that area and then select the triggers that actually trigger the macro to be run. Note that all 6 triggers are mutually exclusive (you can NEVER trigger 2 of them in one move). Click ok and you're golden. <br>
<b>Important Note</b> that in order to 'redefine' an area its very useful if the AreaToken has a unique State set to it on the BASE map! For the example campaign I've given it the state 'Special Area'.<br> 
<br>
<b>Step 3: Show Area (optional)</b><br>
This will fill the defined area with the overlay tokens which should be located on the BASE map. This servers two purposes.<br>
1. You can quickly show an overlay using one of the overlay tokens. You can choose e.g. the hidden layer to show it to GM(s) only, or background layer to show to all<br>
2. If you pick the <i>Area Marker</i> token as overlay (if it exists it will be the default choice) then you can rearrange the area (delete, add, move overlay tokens) and then redefine the area.(define and use the same name, this will overwrite the old one). <br>
Additionaly this macro can be used to delete areas from the map. Simply check the areas you wish to have removed, check the 'delete' checkbox and click ok.<br>
More info about this macro you can find in the tooltips when you run this macro. <br>
<br>
<b><u>SPECIAL EVENT AREA: <i>Limit Movement</i></u></b><br>
When assigning and Area to an even macro, there is one macro 'Limit Movement' that differs from the rest. If you Assign the area to THAT macro then it will be run BEFORE ALL THE OTHER CHECKS. The reason is that IF you work with limited movement e.g. 10 steps AND someone walks over difficult terrain (double move cost), but does not realise it and moves her token with 10 steps (actually 20) straight onto a teleport or a trap. Then you would FIRST like to check whether the token could have reached that and THEN trigger that pad. You could probly use it for other ends as well, but this is what its intended for. 
Because every system is unique, the current macro show you how it works when you move around, you need to adjust the macro to fit your needs. 
Note that the 'Limit Movement' is turned OFF per default in the settings. By setting the value to any numeric value other then 0 you will turn it on. <br>
<br>
<font color=red><b><u>ANIMATED DOORS, DOOR SWITCHES AND VBL AUTOMATION</u></b><br></font>
<b>Parameters</b><br>
To make use of this functionality you need to create special 'door' tokens, with the following parameters.<br>
- For rotating doors the length of these tokens needs to be twice the length of the door (for sliding doors this is not necessary). The width is irrelevant. Select a couple of doors in the campaign file to get an idea. <br>
- The name of the token needs to start with 'Door ' followed by an identifier, usually a number, but can also be a string. <br>
- In case of a double door, there needs to be a mirrored copy of the 'main' door with the same name ending with 'a'. E.g. if the main door is 'Door 5' then the mirrored copy must be called 'Door 5a'. You only need to setup the main copy.<br>
- When using the animation feature (that is youve set a timer) make sure that 'snap to grid' is turned off for the door token. <br>
<br>
Note that if you have a Server - Client running, that the server must have <b><i>Strict Token Ownership</i></b> turned <b>ON</b>. If its turned off, then the players clients will see the 'ghosting' effect as well (because this trick makes use of the 'visible to owners only' setting, but if there is no 'strict ownership', everyone is the owner and thus everyone will see the copies as well.). In this case its better to turn off <i>Run animation per client</i> off in the settings. Also if you have two instances running on one pc (e.g. for laptop-beamer setup) it might be better to turn this setting off.<br>
<br>
<b>Setup</b><br>
To create a single animated door you simply need to select the door and click 'Set Door' and enter the parameters for that door:<br>
<u>angle closed door</u>: When you set the door for the first time, the current angle of the door is automatically picked. Its thus best to put the door in the closed position and then run the setup. If you copy paste a door that has already been set, the set value will be taken. To reset it, make sure this field is empty, click save and run setup again. You will now get the current angle of the door.<br>
<u>degrees open door</u>: The is the amount of degrees the door turns when you open it. Half open would be 45, open would be 90 and wide open is 160 (default)<br>
<u>open clockwise</u>: The way the door turns<br>
<u>double door</u>: If there is another door with the same name as the door you set, but with 'a' at the end (e.g. 'Door 5a') then you can check this. When you open the door, then 'Door 5a' will also open in a mirrored direction<br>
<u>Description</u>: This text will appear in the 'toggle doors' macro<br>
<u>time (ms)</u>: The amount of time it takes for the door to open. 1000 = 1 second. The default is 2000 (2 seconds). If you set the time to 0 then a seperate routine is run instead which simply changes the angle of the door WITHOUT any animation<br>
<u>Switch</u>: When you check this then a Switch Token will appear close to the door, when you click on this token the door will automatically open/close. You can change the image if you like, resize it, move it and even copy paste it if you want multiple switches that correspond with that door (e.g. one on each side). Do keep the switch on the TOKEN layer though (else you can't select it)<br>
<u>Locked</u>: (works only icw Switches) This will set a 'Locked' State on the door. When a player clicks on the switch a message will be send to the chat explaining that the door is locked. To unlock the door simply remove the state (or run 'set door' once again and decheck 'locked')<br>
<u>Proximity</u>: This will check the proximity of player owned tokens close to the switch. The proximity is counted in number of cells. If no player owned tokens are close enough, the door won't open. You can set this to '0' to turn this off. GM's won't be checked, so they can always open the door.<br>
<br>
<b>Setup VBL Options (Vision Blocking Layer)</b><br>
This TAB is only available if you check 'VBL support' in the general settings. And you should only check that if you have a MT version that supports VBL macro's<br>
<u>Use VBL for door</u>: this is the overall setting if you turn this on then toggling the door will also change the VBL of the door. Uncheck will NOT do ANY VBL operations<br>
<u>Peek ... and Open...</u>: when you check none of these options but you have checked the use VBL on doors then toggling the door will default to open the door fully AND do the VBL operation. If you check one of the boxes then it will ALWAYS default to that operation, if you check more then one, you will get a pop-up request when you toggle the door, asking you which of the options you wish to execute. <br>
<br>
<b>Note</b>: When you have set the door, the name of the door will appear in the GM Notes. So when the door is on the object layer and you click on it while on the token layer, the name of the door will appear!<br>
<br>
<b>Rules for Door Image when using VBL !!</b><br>
When using VBL the image of the door has to comply to 3 rules!<br>
1. The ORIGINAL image (so when viewing it in e.g. an image editor and NOT in maptools) has to have the HINGES LEFT and the DOOR KNOB RIGHT<br>
2. The LENGTH of the entire image has to be TWICE the size of the picture of the door. So when the door covers 1 square, the entire image covers 2 squares. The empty space has to be on the hinges side. So: |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o---^-| (where 'o' is the hinge, '^' is the door knob and '|' are the image boundaries.) Check out the VBL map in the BoT campaign file to see what I mean. <br>
3. If you don't use VBL your door can cover any amount of squares. However the current VBL ONLY works for 1 square door images (thus 2 square image when taking rule 2 into account)<br>
<br>
<b>Operating doors</b><br>
There are several ways to operate a door:<br>
1. Select the door and run the 'Toggle Door' macro from the campaign panel.<br>
2. Impersonate the door and enter '&#91; r:toggleDoor()]' in the chat<br>
3. Enter '&#91; r:toggleDoor(5)]' in the chat to operate 'Door 5'<br>
4. Create a macro on the campaign panel with: '&#91; r:toggleDoor(5)]' to specifically operate 'Door 5' with a one click button<br>
5. Run 'Toggle Door<b>s</b>' macro from the campaign panel, this will give you a list of doors that have been set up AND are on the OBJECT layer. The ones you select will be animated.<br>
6. Use a Switch (see above on how to add one). To operate a switch, you must make certain that you have the 'Switch Frame' active! Click on 'Activate Switches' on the campaign panel or the BoT macro panel.<br>
<br>

<font color=red><b><u>UTILITY MACROS</u></b><br></font>
<br>
<b><u>ANIMATE MOVEMENT</u></b><br>
With this function you can choose to use the input panel by selecting a token and clicking 'Animate Move' in the 'Animation' window. However this is a bit cumbersome for e.g. casting a fireball. The 'better' way is by calling the macro directly:<br>
<br>
<b>bot_animateToken</b><i>(tokenID [,x,y,relative,onImpact(-1:bounce; 0=continue; 1=stop),layer(json.object),vbl(1; 0),delay(ms)])<br></i>
<br>
If you give at least the token Id and the x and y coordinates then this function will run automatically with the following 'default' settings: relative=0, onImpact=0, layer='[]', vbl=0, delay=0.<br>
<br>
<u>What do these settings mean:</u><br>
<b>- X (#cells)</b>: The destination X coord of the token, either absolute or relative to its current position<br>
<b>- Y (#cells)</b>: Dito X, but then Y<br>
<b>- Delay (ms)</b>: The delay per movement made, this is in ms so a value of 1000 means wait 1 second before you move the token again.<br>
<b>- Relative (1/0)</b>: Unchecked: the actual map coordinates are taken for the x and y values and the token is moved to those coordinates. Checked: the relative position of the token is taken and the token is moved x steps in the X direction and y steps in the Y direction. E.g. Relative 3,2 will move the token 3 cells to the right and 2 down<br>
<b>- onImpact - Bounce (-1)</b>: if the token encounters an obstacle it will change its course depending on the angle of impact. Note that there are only 3 trajectories supported: invert X, invert Y and invert Both. An 'obstacle' is defined by the below settings. <br>
<b>- onImpact - Continue (0)</b>: the token is moved to its destination no matter what<br>
<b>- onImpact - Stop (1)</b>: the animation stop as soon as it meets an obstacle<br>
<b>- Token (and the other) layer(s)</b>: 'The 'checked' layers will be searched for obstacles' where the token can run into while its moving<br>
<b>- Vision Blocking Layer</b>: This will take the vision blocking layer into account as well for possible impact. Note however that this works on sight of the token, so if the token has no sight EVERYTING is blocked vision and it will thus not move (it might move backwards a bit due to the code). This also accounts for hardfog, no light, etc. <br>
<br>
Note that if you have a Server - Client running, that the server must have <b><i>Strict Token Ownership</i></b> turned <b>ON</b>. If its turned off, then the players clients will see the 'ghosting' effect as well (because this trick makes use of the 'visible to owners only' setting, but if there is no 'strict ownership', everyone is the owner and thus everyone will see the copies as well.). In this case its better to turn off <i>Run animation per client</i> off in the settings. Also if you have two instances running on one pc (e.g. for laptop-beamer setup) it might be better to turn this setting off.<br>
<br>
<b><u>ANIMATED TEXT</u></b><br>
These are two feature: one is a macro that you can call and use in your own FW or even in the chat: animateText (text[, title, position, html-header, width, height, delay, upper]). The input box can be found in the 'Bag of Tricks macro panel'. When the text animation is activated a frame will pop-up on every attached client pc printing the text. <br>
<b>- text</b>: The text you enter here will be animated in a frame<br>
<b>- title</b>: The title of the frame<br>
<b>- position</b>: The animated will start at the character number you enter here, e.g. 10 means that the first 10 character won't be animated<br>
<b>- html-header</b>: Here you can set some basic make up for the frame itself. If you enter 'Default' it will show a black-green frame with courier font<br>
<b>- width & height</b>: The dimensions of the Frame<br>
<b>- delay</b>: Amount of delay per character printed in ms.<br>
<b>- upper</b>: Print the animated text in UPPER CASE<br>
<br>
<b><u>BENCHMARK</u></b><br>
This tool is specifically developed for Maptool macro developers and can be used to test the execution time of several different macro to see which method is the fastests<br>
Simply create one or more macro in the group 'Benchmark Macros' on lib:EventMacros (there has to be one empty macro called 'Default' in that group as well.). Then hit the Benchmark button on the menu. A form pops-up asking you the amount of iterations including an indication of how long each iteration set roughly takes. <br>
E.g. 100 (~2 seconds) means that each macro will run 100 times and then the total time is divided by 100 and the time it takes to run Default is deducted from that result. The resulting time is thus the execution time it takes to run that macro one time. <br>
When more then 1 macro is tested, then a comparison result is given with a normalization overview with the fastest as base. This means that if e.g. macro1 takes 2 seconds and macro2 takes 4 seconds that the normalization will show that macro2 takes 2x as much time as to run macro1.<br>
Note that macro in the 'Benchmark Macros' group which name starts with '@' will be skipped by the benchmark test. This way you can swiftly turn off certain macros for non-testing.<br>
<br>
<b><u>FORCE SELECTION</u></b><br>
(This is an alternative to the full screen toggle but much more demanding. Force selection and Toggle Full Screen mode are NOT related)
This is a very specific add-on that most of you likely won't be using, but it can be quite useful. You can run two instances of MT on your pc, connected and both set to gm. When you combine this with 'Always on Top' (a free aplplication with which you can force windows application to remain always 'on top' even if another window is active. This way you can have e.g. your campaign macros and chat window visible while using the full screen modus. The issue however is is that if you use macro's that are set for 'apply to selected token', that the token you happen to have selected on you 'full screen' client (Master), is not necessary selected on your 'show chat and campaign button' client (Slave). Specifically for this reason I've created an extra option into the Bag of Tricks. IF you login to the Master with a slave that has the gm-name <b>forceButtons</b> (the Slave must also be GM !!) then when you select a token on the Master it will also be automatically selected on the Slave. This way you ensure that the macros always work as intended. To activate the 'syncing' you will need to first run the <b>Activate Switches</b> macro. To summarize:<br>
- Start GM server (Master)<br>
- Start another instance of MT and login to the GM Server with username: forceButtons (Slave)<br>
- on the Master run 'activate switches', a frame should appear, this is used for the onTokenSelectionEvent<br>
- Start 'Always on Top' (google it and download it)<br>
- Undock the panels from the slave that you wish to use, including the 'toolbar' <br>
- Make the Slave map window very small (don't minimize)<br>
- Lock the Slave's toolbar so its always on top<br>
- Switch to the Master and set it to full screen. <br>
- IF you did everything alright then the toolbar should remain on top, when you select that then the undocked windows like campaign and chat will pop up over the full screen map. <br>
- When you select a token on the Master, it should now also be selected on the Slave. <br>
<br>
<b><u>GROUP MOVE & GROUP SELECT</u></b><br>
These are two distinct functions that have nothing to do with eachother. 'Group Move' will move the entire group when one token of that group is moved. 'Group Select' will select all the other tokens of the group when one token is selected. 'Group Move' is useful for e.g. battles with grouped units. 'Group Move' has for this reason also several formation and rotation buttons. These will NOT work for 'Group Select' groups. 'Group Select' is useful when creating maps and you want to group several tokens into one selectable object. <br>
Both grouping methods work as follows: select a group of tokens and click on the 'Group (...)' macro. In addition for the 'Group Move' you are asked to enter a name for the group. Don't use any funky characters for the group name like: ,; . 'space' etc. It might break. Another additional option for 'Group Move' will become available if you turn on 'Show group panel on select' in the bot-settings: when you have the 'activate switch' panel turned on (see 'token buttons') then every time you select a token of a 'move group' the 'group macro panel' will pop up, giving you the extra options like rotate clockwise, counterclockwise (both in steps of Free, 45 or 90, see below), spread and contract. To clear a group, simply select one or all the tokens and click 'clear group'.<br>
<br>
<b><u>RENUMBER TOKENS</u></b><br>
Slightly obsolete macro, this renumbers all the tokens with the same name so there are NO double names and NO gaps in the counting. <br>
<br>
<b>ROTATING GROUPS (Group Move only):</b>
Groups can be rotated by selecting one token of the group and then click CW (Clockwise) or CCW (Counter clockwise) after which the group will be rotated. <br>
The rotation process knows three different methods:<br>
- snapped to grid: group will be rotated in increments of 90 degrees<br>
- unsnapped to grid: group will be rotated in increments of 45 degrees<br>
- use facing of token (unsnapped only!): when the selected token has a facing set the rest of the tokens will be rotated around that token along the facing angle. This effectively will allow free rotation of the group. <br>
<br>
Some notes:<br>
- This macro makes use of the label field of the token and any current value will get overwritten!!. Changing this value after a group has been set will de-activate group- movement when you move THAT token. The token will still be part of the group and will be moved if another token of the group is moved<br>
- When you set a group with tokens that already belong to another group, then that ENTIRE other group will be cleared!!. <br>
- The onTokenMove pads like teleports, events, canopy, etc. will ONLY work for the token that you actually move. <br>
- Group move will ONLY work when you move ONE token. <br>
- You can temporarily turn off group movement by togglinh the 'Turn On Token Move Event Macor On/Off'<br>
- When using the tokenfacing rotation method; the resolution isn't infinite which will result in the tokens formation to become slighly irregular when a lot of this type of rotation is used. Also the CW and CCW buttons will have the same result as the tokens are rotated according to the set facing and not anymore CW or CCW<br>
- <b>The formation macros (rotate, square, wedge etc.) will also work if you select more then one token which do not belong to a group.</b><br>
<br>
<b><u>SET VBL STAMP</u></b><br>
With this function you can apply a Vision Blocking Layer (VBL) stamp upon a token. With this stamp you can move, rotate and copy the token and the applied VBL will 'move' with the token. Note that one of the options is 'Current VBL' that means that ALL VBL that is ON the token (so not outside of it) will be stored on the token and set as the VBL 'stamp'. There however a few tricky things which Ill explain here:<br>
<u>Core thing to know:</u> The stamp function fully relies on the onTokenMove event! And that event is ONLY triggered on the TOKEN layer. Also the save VBL function is NOT 100% perfect. A mathematical model will be made of the VBL which most likely will be slightly different then what you applied. <br>
<br>
So what does this mean...:<br>
1. This 'stamp' function ONLY WORKS ON THE TOKEN LAYER. If you thus want to use if for buildings, do all that what you want to do on the token layer and then when finished, send the token to the background layer.<br>
2. The first time you store custom VBL on a token, move the token outside the VBL area. Then switch to VBL modus and you'll notice that the 'former' vbl is still there. You can leave or remove that VBL. When I created the code I chose to not remove the former VBL automatically for complex reasons I'm not gonna explain here. After this the VBL will move with your token AND it will remove the VBL where it was. <br>
3. If you rotate a VBL stamped token, the VBL will rotate AFTER you have moved it a bit. Wiggling the token a bit is enough (to trigger onTokenMove event). <br>
4a. If you move the VBL stamped token on top of an existing VBL layer: the VBL stamp will be applied on top of the existing VBL.<br>
4b. If you then move that token outside of the VBL area, the former VBL will be restored!!<br>
HOWEVER: same rule as above applies: it won't be 100% perfect!<br>
5. Copy pasting will make the function cry a bit as it gets confused by formerly stored VBL, so things will go a bit weird when you do this. Here a breakdown:<br>
5a. Make sure that you operate in a VBL free environment (so that you don't accidentily use of overwrite background VBL)<br>
5b. Create and apply VBL stamp to token as explained<br>
5c. Copy the token and paste it somewhere away from the original<br>
5d. Move the copy, again make sure that you move it OUTSIDE the original position. You will notice 2 things: 1. the VBL will be applied to the copy; 2. the VBL will be removed from the original. <br>
5e. Move the original to restore the VBL. <br>
Rinse and repeat. <br>
6. When using lots of stamps and you move these around in a complex VBL environment its possible that pieces of VBL are left behind. Theres not much I can do about this as its a limitation of the 'not a 100% perfect copy of the original VBL'. Just keep an eye out for it!
<br>
<b><u>SCATTER</u></b><br>
This macro was originally created by Craig (one of the MT ancients) and is further developed by me. <br>
With this macro you can scatter a couple of tokens within a predefined area. E.g. a token of a tree, scattered 100x in an area of 100x100 cells. <br>
To use the scatter macro, just select a couple of tokens you wish to scatter, run the macro, set the parameters and hit the ok button. After a couple of seconds youll find the token scattered over the pre-defined area<br>
<br><b>Parameters</b><br>
<b>- 'Select a token or object': </b>On the map on any layer you can select a number of token  <br>
<b>- Number of Copies:	</b> The total number of copies of the selected token copied into the designated area<br>
<b>- Distance (N,W,S,E): </b>The distance in cells counting from the selected token (if you have mult. tokens selected, the cells are counted from that each seperate token. So if you have e.g. a Tree and a Bush token selected and north: 100. Then trees are copied upto 100 cells north from the original Tree token and bush tokens are copied upto 100 cells north from the Bush token<br>
<b>- Spreading:			</b> The minimal distance between two tokens within the designated area within the designated layer. 0 = No spreading. How does it work exactly: When you set this value to 1 or higher, all the Id's of the tokens that are copied are stored into a list. Then randomly one is picked from that list (lets call it token X. From token X ANY token on the DESIGNATED LAYER withing 'SPREAD' RANGE WILL BE DELETED. The deleted tokens and token X is then removed from the list and another token is randomly selected from the list until the list is empty. Thus: if there are already tokens within the designated area and you don't want them deleted, make sure that the DESIGNATED LAYER is an empty layer (e.g. Hidden). When done you can select all the tokens on the Hidden layer (from the explorer panel) and move them with one click to the layer where you want them.<br>
<b>- Rotation:			</b>Here you can choose different rotation settings, depending   <br>
<b>- Range of Size:		</b>If the original tokens are of Medium size then a size range of e.g. 2 will randomly copy new tokens from 2 sizes smaller upto 2 sizes bigger. If you want to work with free size, then select e.g. 5 similar tokens of different sizes and set the 'Range of size' to 'keep original size'<br>
<b>- Layer:				</b>The designated layer where upon the tokens are copied.<br>
<b>NOTE:</b> When SPREAD is used, the 'weeding' of trees closer in distance then the spread value is done by a defered macro call. This means that you can interact with the map while the process runs. In this case wait for the 'Spread Calculations Done' message. DO NOT CHANGE MAPS (or your pc might explode) also refrain from adding or removing any token from that map until then.<br>
<i>When multiple tokens are selected:</i><br>
<b>- Number of Tokens (of each / Randomly selected: </b>If you select e.g. 2 tokens e.g. a Tree and a Bush and number of copies is set to 10: then 'each' = 10 copies of the Tree and 10 copies of Bush. 'Randomly Selected' = A total of 10 copies randomly selected from the tree and bush, e.g. 3 Trees and 7 Bushes. <br> 
<br>
<b><u>SEEK TOKEN</u></b><br>
Simply enter the first part of the name of a token that you seek and ALL maps will be checked and if the string matches then the token name will be listed for that map. It will also list all the lib:tokens!!<br>
<br>
<b><u>SET TOKEN SIZE</u></b><br>
This macro you will need if you want to use alt.init token (so you have > 100 special pads on one map) AND some of these pads are free size. For alt init map to work it needs to know the size of a token, and this is indeterminable when using free size tokens. With this macro you can select all tokens of the same size and set their size in one go.<br>
<br>
<b><u>SUMMON TOKEN(S)</u></b><br>
This macro summons a token onto a selected token. For this macro to work you will need to select a token first.<br>
When you start using this macro, make sure you have set it up correctly in the settings. It wil show 5 types of Drop down boxes (DDB): NPC, PC, (N)PC, Property Type and Special. <br>
- <b>(N)PC</b> These three will show (N)PCs, however you need to set the Property types for PCs and NPCs first in the settings<br>
- <b>Property Type</b> For every property type that you list in the settings one DDB will be shown.<br>
- <b>Special</b> Here you can simply give a list of token names that will show up in the last DDB<br><br>
<br>
<b><u>SWITCH MAP & centreOnMePad</u></b><br>
This macro shows a list of ALL maps (including hidden). The map you choose will force ALL clients to that map and centre the view on the 'centreOnMePad' if its there. <br>
<br>
<b><u>TABLES</u></b><br>
These utilities consits out of several macros:<br>
<br>
<u>In the macro menu:</u><br>
- <b>Create Table</b>: this macro opens a form in which you can copy paste a table straight from excel. Beneath it you can set the title of the table. The checkbox enables you to view the table afterwards and edit it. This is NOT a maptool table but a Bag of Tricks table. It will be stored on lib:EventMacros. The advantage is that its dynamic and it allows multiple columns.<br>
- <b>Show Table</b>: this macro shows you a list of available tables. The one you pick is shown in a form in which you can edit the values. When you create a table using the above function, you can about feed it anything you like. However when you starte editing it you can no longer use quotes neither single (will be removed) nor double (render an error)<br>
- <b>Delete Table</b>: this macro shows you a list of available 'Bag of Tricks' tables that you created using 'Create Table'. The one you pick is will be deleted from lib:EventMacros<br>
<br>
<u>Script/Code functions (these only work for the 'Bag of Tricks' Tables, stored on lib:EventMacros, i.o.w. created by using the above macros):</u><br>
- <b>bot_table()</b>: with this function you can retrieve a value from the stored BoT Tables.<br>Usage: bot_table('name of table', optional: 'column', 'row'). Here 'row' can either be an index number or the actual name of the row. Column must always refer to the column name. Leaving them empty will result in a random choice for row and the 1st column for column.<br>
- <b>bot_listBoTtables()</b>: returns a list with the stored BoT Tables.<br>
- <b>bot_listMTtables()</b>: returns a list with the stored Maptool Tables.<br>
- <b>bot_getRows('table name')</b>: returns the row names of the given BoT table<br>
- <b>bot_getColumns('table name')</b>: returns the column names of the given BoT table<br>
<br>
<u>In addition the following functions have been added, originally created by Craig, updated by LMarkus001 and slightly tinkered by me.</u><br>
- <b>json.path()</b>: returns the nested keys from a json object<br>
- <b>json.pget()</b>: returns the requested value. Usage: json.pget(jsonObject, 'key1/key2/etc')<br>
- <b>json.pset()</b>: sets a value for the given key. Usage: json.pset(jsonObject, 'key1/key2/etc', value)<br>
<br>
<b><u>TOGGLE FULL SCREEN MODE</u></b><br>
Currently this mode needs to be toggled (Shortcut key is F2) as there is no way to check whether you are in Full Screen or not (in the next MT build this should be solved). How it works is simple: if you are in full screen (ctrl+alt+enter) you can press F2 to toggle to full screen mode. The BoT menu will also pop in screen. All the relevant screens will show up in dialog, even the last chat message IF you make use of the message function implemented in this FW. To do that you will need to check the 'redefine broadcast' setting in the settings. This results in the broadcast function not only porting to chat but also to a chat dialog. In that case you will always see the last broadcasted message in full screen.<br>
One remark: when you click somewhere on the MT map then the dialogs will 'dissapear' (as they are moved to the background). To get them back use alt+tab. <br>
<br>

<font color=red><b><u>SETTINGS</u></b><br></font>
<br>
<b><u>TOGGLES</u></b><br>
In the toggles you can turn certain ontokenmove related features on or off. Turning them on will generally result in (slightly) reduced response time when moving a token.<br>
All these settings contain tooltips explaining you what to do<br>
<br>
<b><u>VISION BLOCKING TOKEN STAMPS (VBL Stamps)</u></b><br>
In the general settings, after you turn on VBL support you will find in the 'Toggles' tab a 'VBL Stamps' setting. If you check this then ANY token with the LABEL: <i>VBLStamp</i> will get a VBL cross drawn over it when you move the token. This VBL cross will move along with the token. <br>
<br>
<b><u>GENERAL EVENTS</u></b><br>
In the settings you will find a new tab with a list of events to which you can link your own events. E.g. if you wish to post a message to the screen every time someone teleports saying from where and to where they are teleported: this is the place to do this. <br>
To make this work you first need to create an event macro on lib:EventMacro in the group 'Event List Macros'. This can be as simple as a chat message saying: 'You are being teleported'. <br>
Once you have created this event you will find it back in the dropdownlists you see in the tab 'General Events'. Simply pick the one at the event and you're done!<br>
<br>
<b>Event List Macros</b><br>
When creating an event list macro please limit the characters you use in the name of the macro to alphanumeric characters ONLY!!! <br>
<br>
For the onTokenMove and onMultipleTokensMove (both before and after) there is one arguments available, which you can call with: [h:arg(0)]. Depending on which event this will return the following:<br>
- For onTokenMove both before and after: The token name<br>
- For onMultipleTokensMove BEFORE: list of moved token ID's. This linked macro will run ONCE<br>
- For onMultipleTokensMove AFTER: NAME of current token. This linked macro will run FOR EVERY TOKEN INDIVIDUALLY!<br>
<br>
For the teleports there are also a bunch of useful variables locally available. To acces these you need to start your macro with: [h:varsFromStrProp(arg(0))]<br>
Depending on the even type the following variables will be defined locally:<br>
<b>teleport</b>: tok, padName, teleportEndName, CurrentX, CurrentY, NewX, NewY<br>
<b>inter map teleport</b>: tok, padName, CurrentX, CurrentY, NewX, NewY, oldMap, newMap<br>
<b>where:</b><br>
<u>tok</u>: The name of the token<br>
<u>padName</u>: Then name of the pad you are teleported from (in case of inter map transport that is also the name of the Pad you are transporte to)<br>
<u>teleportEndName</u>: The name of the pad you are transported to (local map only)<br>
<u>CurrentX/Y</u>: X/Y coord of where the token is transported from<br>
<u>NewX/Y</u>: X/Y coord of where the token is transported to<br>
<u>oldMap</u>: Name of map of where the token is transported from<br>
<u>newMap</u>: Name of map of where the token is transported to<br>
<br>
<b>Example Event List Macro:</b><br>
[h:varsFromStrProp(arg(0))]<br>
[h:bot_animateText(tok+' is being teleported from '+oldMap+' to '+newMap,'Inter map teleport', 0,'default','300','50')]

"]

<!-- run the function documentation frame as well -->
[r:bot_manFunctionsTxt()]

<!-- start manual frame (in this order the manual frame ends on top -->
[r, if(bot_isFullScreen()), CODE:{
	[r,dialog("Manual", "temp=0; closebutton=0; width=800; height=600; input=1"): {[r:output]}]
};{
	[r,frame("Manual", "temp=0; closebutton=0; width=800; height=600"): {[r:output]}]
}]

@@movementLock
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=20 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------- movementLock ------------------------------------------------>']
[h:assert(isGM(),"This macro may only be executed by the GM",0)]

[h:toggles	= getLibProperty("toggles", "lib:EventMacros")]
[h:varsFromStrProp(toggles)]

[H: movementLock = 1 - movementLock]

[h:toggles = setStrProp(toggles, "movementLock", movementLock)]
[h:setLibProperty("toggles", toggles,"lib:EventMacros")]
	
[H: broadcast("<b>Server Movement Lock is <font color=blue>"+if(movementLock,"ON","OFF")+"</font></b>")]

@@popUpHandout
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy=23 ; color=default ; playerEditable=false ; applyToSelected=true ; group=Util ; tooltip= ; minWidth=90 ; 
[id	= arg(0)]
[w	= arg(1) + 40]
[h	= w]
[text	= arg(2)]

[dialog("Token Handout", "width="+w+"; height="+h+"; temporary=1; input=0; noframe=1"): {
	<table align='center' valign='center'>
		<tr><td>
			<img src='[r:id]'></img>
		</td></tr><tr><td>
hello			[r:text]
		</td></tr>
	</table>
}]

@@remTrunkImages
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=16 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------- remTrunkImages ------------------------------------------------>']

[h:tokenList = getTokenNames(",", '{layer:["TOKEN","GM","OBJECT","BACKGROUND"]}')]
[h:canopyList = ""]
[h: allTokensJson = json.fromList(tokenList)]
[h: maxCount = json.length(allTokensJson)]

[h:'<!-- create json splices to prevent the 1000 loop limit -->']
[h: splices = ""]
[h: from = 0]
[h: to = from + 499]
[h, while(to >= 0), code: {
    [if(to >= maxCount): to = -1]
    [thisSplice = json.get(allTokensJson, from, to)]
    [splices = json.append(splices, thisSplice)]
    [from = from + 500]
    [if(to != -1):to = from + 499]
}]

[h:'<!-- loop through them and create a tokenlist consisting out of special pads only-->']
[h: cleanTokenList = ""]
[h, foreach(splice, splices, ""), code: {
    [foreach(tok, splice, ""):  cleanTokenList = if(startsWith(tok, "Canopy"), listAppend(cleanTokenList, tok), cleanTokenList)]
    }]
}]

[h:'pause("cleanTokenList","numTokens","mainCount","restCount")']
[h:tokenList = cleanTokenList]

[h,foreach(token,tokenList,""): setTokenHandout()]

@@removeP20
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=15 ; color=darkgray ; playerEditable=false ; applyToSelected=true ; group=Util ; tooltip=This macro replaces %20 with spaces " " in the selected token names ; minWidth=90 ; 
[h:tokList = getSelected()]
[h, foreach(tok,tokList), CODE:{
	[token(tok): token.name = replace(token.name,"%20", " ")]
}]

@@removeTokens
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=63 ; color=default ; playerEditable=true ; applyToSelected=true ; group=Util ; tooltip= ; minWidth=90 ; 
[h:'<!-- --------------------------------------- removeTokens ---------------------------------------- -->']

[if(argCount() < 1): toks	= ""	; toks = arg(0)]
[splices	= bot_createSplices(toks)]
<!-- loop through the splices and create an array of the coords of all the tokens -->
[foreach(splice, splices, ""), code: {
	[foreach(tok, splice, ""):  removeToken(tok)]
}]

@@renumberToks
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=61 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip= ; minWidth=90 ; 
[h:'<!-- renumberToks -->']
[h:'<!-- THREE CODE LEVELS METHOD USED -->']
[h,if(argCount()>0): tokenName = arg(0); tokenName = ""]
[h,if(argCount()>1): allToks = arg(1); allToks = ""]

[h:specNameList = "Canopy, Foliage, Roof, Ward, EventPad, MappedPad, PadStart, PadEnd, InterPad, PadStartBorder, PadEndBorder, InterPadBorder, PadJumpBorder, PadDropBorder, InterJumpBorder, InterDropBorder, PadJump, PadDrop, InterJump, InterDrop"]

[h, if(tokenName == ""): abort(input("tokenName|"+specNameList+"|Choose the special tokens on this map to renumber?|LIST|VALUE=STRING"))]
[h, if(allToks == ""): allToks = json.toList(getTokenNames(",", json.set("{}", "layer", json.append("","TOKEN", "OBJECT", "HIDDEN","BACKGROUND"))))]

old Names<br>
[r:allToks]
[h:allToks = listSort(allToks, "N-")]

[h:'<!-- loop through the splices and create an array of the coords of all the tokens -->']
[h:splices = bot_createSplices(allToks)]
[h:i=1]
[h, foreach(splice, splices, ""), CODE:{
	[foreach(tok, splice, ""), CODE:{
		[if(startsWith(tok, tokenName + " ")), CODE:{
			[token(tok):token.name = tokenName + " " + i]
			[i = i + 1]
		''
		}; {}]
	''
	}]
''
}]

[h:allToks = json.sort(getTokenNames(",", json.set("{}", "layer", json.append("","TOKEN", "OBJECT", "HIDDEN","BACKGROUND"))))]

<br><br>
New Names<br>
[r:allToks]

@@setDrawOrder
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=12 ; color=darkgray ; playerEditable=false ; applyToSelected=true ; group=Util ; tooltip=<html>This is just a handy macro where you can manually set the draw order of the token. <br>A high number means on top of all a low number means below all.<br>Then current number (draw order) is shown when you run this macro on a token ; minWidth=90 ; 
[h:assert(listCount(getSelected()), "make sure (only) one token is selected",0)]
[h:switchToken(getSelected())]
[h:drawOrder = getTokenDrawOrder()]
[h:input("drawOrder|"+drawOrder+"|Set Draw Order")]
[h:setTokenDrawOrder(DrawOrder)]

@@setLightSource
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=16 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip= ; minWidth=90 ; 
[h:'<!-- ----------------------------------- SETLIGHTSOURCE ------------------------------------------------>']

<!-- Check if at least one token is selected -->
[h: selToks				= getSelectedNames()]
[h: assert(listCount(selToks),"Please make sure at least one token is selected",0)]
[h: me					= listGet(selToks, 0)]
[h: switchToken(me)]

<!-- get lightsources from campaignproperties -->
[h:source				= getInfo("campaign")]
[h:lightSource			= json.get(source, "light sources")]
[h:lightTypeList		= listSort(json.fields(lightSource),"A+")]

<!-- remove light types not wanted, can be set through the settings -->
[h:excludeLightTypes	= getLibProperty('excludeLightTypes', 'lib:EventMacros')]
[h,foreach(light,excludeLightTypes): lightTypeList = listDelete(lightTypeList, listFind(lightTypeList, light))]

<!-- construct lists of light -->
[h:i					= 0]
[h:inputStr				= ""]

[h, foreach(lightType, lightTypeList), CODE:{
	[inputStr			= listAppend(inputStr,"tab"+i+" | "+lightType+" || TAB")]
	[H, if(!i): inputStr = listAppend(inputStr, "divider | | <html><b>The Wolph42 Light Editor</b></html>| LABEL | text=none")]
	[lights				= json.get(lightSource,lightType)]
	[lightSet			= lightType]
	[lightList			= ""]		
	[foreach(light, lights):lightList	= listappend(lightList, json.get(light, "name"))]
	[lightSetList		= listSort(lightList,"N+")]
	[nlightSetList		= listCount(lightSetList)]
	[h,count(nlightSetList),CODE:{
		[light			= listGet(lightSetList,roll.count)]
		[newStr			= "Lamp"+i+"S"+roll.count+"|"+hasLightSource(lightSet, light)+"| "+light+" | CHECK"]
		[inputStr		= listAppend(inputStr, newStr)]
	}]
	[H, if(!i): inputStr = listAppend(inputStr, "divider2 | ------ | ------------------------------ | LABEL")]
	[H, if(!i): inputStr = listAppend(inputStr, "removeAll | 0 | REMOVE ALL LIGHTS? | CHECK")]
	[i					= i + 1]
}]

<!-- ask for input -->
[H: inputStr			= listFormat(inputStr, "input( %list )", " ' %item ' ", ",")]

<!-- create the dialog -->
[H: status				= eval(inputStr)]
[H: abort(status)]

<!-- set the the lights -->
[h: i					= 0]
[h, foreach(lightType, lightTypeList), CODE:{
	[lights				= json.get(lightSource,lightType)]
	[lightSet			= lightType]
	[lightList			= ""]		
	[foreach(light, lights):lightList	= listappend(lightList, json.get(light, "name"))]
	[lightSetList		= listSort(lightList,"N+")]
	[nlightSetList		= listCount(lightSetList)]
	[h,COUNT(nlightSetList),CODE:{
		[j				= roll.count]
		[light			= listGet(lightSetList,j)]
		[foreach(tok, selToks): bot_applyLightSource()]
	}]
	[i					= i + 1]
}]

<!-- if removeAll was checked, clear all lights -->
[H, if(removeAll), CODE:{
			[foreach(tok, selToks), CODE:{[token(tok): clearLights()]}]
}; {}]

@@setTokSize
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=11 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip=<html>This macro is usefull if you want to use Alt Init Pads macro to initialize a map.<br>With this macro you can pre-set the size of a token. So you won't be asked <br>for it when you run alt. init. maps.<br>Note that you only need to do this for free size tokens ; minWidth=90 ; 
[h:'<!-- setTokSize -->']

[h:tok = getSelectedNames()]
[h:assert(listCount(tok)==1, "Make sure (only) one token is selected",0)]
[h:switchToken(tok)]
[h:bot_determineTokSize()]

@@settings
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=11pt ; sortBy=10 ; color=yellow ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip= ; minWidth=90 ; 
[H: '<!------------------------------------SETTINGS-------------------------------------------------------->']
[h:assert(isGM(), "Only a GM can modify the settings",0)]

<!-- Settings -->
[h:useAltImage			= getLibProperty('useAltImage','lib:EventMacros')]
[h:checkMapsOCL			= getLibProperty('checkMapsOCL','lib:EventMacros')]
[h:showGroupPanelOnSelect= getLibProperty('showGroupPanelOnSelect','lib:EventMacros')]
[h:fullScreenBroadcast	= getLibProperty('fullScreenBroadcast','lib:EventMacros')]
[h:oldFSB				= fullScreenBroadcast]
[h:numericIdOnly		= getLibProperty('numericIdOnly', 'lib:EventMacros')]
[h:baseMapName			= getLibProperty('baseMapName','lib:EventMacros')]
[h:excludeLightTypes	= getLibProperty('excludeLightTypes','lib:EventMacros')]
[h:haloColors			= 'red,dark gray, yellow, blue, black, white,light gray,teal,none']
[h:onLineClients		= listInsert(json.toList(bot_nself()),0,"")]

<!-- animations -->
[h:animationPerClient	= getLibProperty('animationPerClient','lib:EventMacros')]
[h:timeLockDelay		= getLibProperty('timeLockDelay','lib:EventMacros')]

<!-- summon token macro -->
[h:summonPcPropType		= getLibProperty('summonPcPropType','lib:EventMacros')]
[h:summonNpcPropType	= getLibProperty('summonNpcPropType','lib:EventMacros')]
[h:summonPropTypesList	= getLibProperty('summonPropTypesList','lib:EventMacros')]
[h:summonSpecialList	= getLibProperty('summonSpecialList','lib:EventMacros')]

<!-- set vars for Toggles -->
[h:vblSupport			= getLibProperty('vblSupport','lib:EventMacros')]
[h:varsFromStrProp(getLibProperty('toggles','lib:EventMacros'))]
<!-- halo colors is stored as string, so convert to number -->
[h:roofHaloColor		= max(0,listFind(haloColors, roofHaloColor))]
[h:forceSelectClient	= max(0,listFind(onLineClients, forceSelectClient))]

<!-- OCL -->
[h:useStartUpMap		= getLibProperty('useStartUpMap','lib:EventMacros')]
[h:startUpMap			= getLibProperty('startUpMap','lib:EventMacros')]
[h:startUpCoords		= getLibProperty('startUpCoords','lib:EventMacros')]
[h:useCentreOnMePad		= getLibProperty('useCentreOnMePad','lib:EventMacros')]
[h:runSwitchForm		= getLibProperty('runSwitchForm','lib:EventMacros')]
[h:disableOCLCheck		= getLibProperty('disableOCLCheck','lib:EventMacros')]

<!-- SYSTEM -->
[h:libCoordSize			= getLibProperty('libCoordSize', 'lib:EventMacros')]
[h:maxPadsPerRun		= getLibProperty('maxPadsPerRun','lib:EventMacros')]
[h:maxGroupSelect		= getLibProperty('maxGroupSelect','lib:EventMacros')]
[h:maxOrderSelect		= getLibProperty('maxOrderSelect','lib:EventMacros')]
[h:padNameList 			= getLibProperty('padNameList', 'lib:EventMacros')]

<!-- start up map -->
[h:startUpMapList		= getAllMapNames()]
[h:startUpMapNum		= listFind(startUpMapList,startUpMap)]
[h:baseMapNum			= listFind(startUpMapList,baseMapName)]

<!-- create list of event macros from the group "Event List Macros" used for "General Events" tab -->
[h:oldMap				= getCurrentMapName()]
<!-- check if the map where lib:Eventmacros is situated, still exists -->
[h,if(baseMapNum == -1), CODE:{
	[input('baseMapNum|'+startUpMapList+'|The map with lib:EventMacros does not exist. Pls select the correct one|LIST')]
	[baseMapName = listGet(startUpMapList, baseMapNum)]
}]
[h:setCurrentMap(baseMapName)]
<!-- check if lib:Eventmacros is on the map -->
[h,if(findToken("lib:EventMacros") == ""), CODE:{
	[input('baseMapNum|'+startUpMapList+'|<html>Lib:EventMacros is NOT on map: <b>'+baseMapName+'</b>. Please select the map where Lib:EventMacros is on|LIST')]
	[baseMapName = listGet(startUpMapList, baseMapNum)]
	[setCurrentMap(baseMapName)]
}]
[h:assert(findToken("lib:EventMacros") != "", "<font color=red>No Lib:EventMacro found on map <b>"+baseMapName+"</b> please correct this.",0)]
[h:macroIDList		= getMacroGroup("Event list macros", ",", "lib:EventMacros")]
[h:macroNameList	= "<none>"]
[h,foreach(id, macroIDList): macroNameList = listAppend(macroNameList, getStrProp(getMacroProps(id, "; ", "lib:EventMacros"),"label"))]
[h:setCurrentMap(oldMap)]

<!-- convert the macro names into macro index for the list -->
[h:triggerEventList = "eventMacroPreTokenMove, eventMacroPreMultipleTokenMove, eventMacroOnTokenMove, eventMacroOnMultipleTokensMove, eventMacroPostTokenMove, eventMacroPostMultipleTokensMove, eventPreMacroTeleport, eventPostMacroTeleport, eventMacroPreInterTeleport, eventMacroPostInterTeleport"]
[h,foreach(trigger, triggerEventList): set(trigger, listFind(macroNameList, eval(trigger)))]

[h:inputStr	= json.append("", "tab1|<html><b>General</html>||TAB")]
[h:inputStr = json.append(inputStr, "junk|<html><b>Settings</b></html>|-|LABEL|SPAN=TRUE")]
[h:inputStr = json.append(inputStr, 'useAltImage|'+useAltImage+'|<html><span title="<html>When checked, the system will first check whether there is a token handout image on the foliage token. <br>If so it will swap the original image for that one, if not it will grab the table image. <br>Unchecked, the system will automatically grab the tbl image</html>">Use alternative transparent image for foliage</html></span></html>|CHECK')]
[h:inputStr = json.append(inputStr, 'checkMapsOCL|'+checkMapsOCL+'|<html><span title="<html><b>When checked:</b> the system will check all the maps when you load the campaign,<br>to see if they appear in the pad database. This is not a full initialization but it will<br>prevent bug reports after you load the campaign and if any inconsistancies are<br>found it will initialize the campaign file. What you will notice is that MT will<br>quickly flick through all the maps when you load the campaign.<br><b>When unchecked:</b> no checks are made so nothing will happend when you load the<br>campaign file.</html>">Check all maps on start up</html></span></html>|CHECK')]
[h:inputStr = json.append(inputStr, "doSwitchInterMap|Change to other map, don't change to other map, don't change AND store coords|<html><span title='<html><b>Change to other map</b>: When using inter map teleport, switch to the map after teleportation<br><b>do not change to other map</b>: do NOT switch to destination map after teleportation<br><b>do not change AND store coords</b>: when using the do NOT switch map option, the system needs to<br>check the destination pad for the correct coords before sending the token there and then return to<br>the current map. This causes maptool to reload the current map. To prevent this you can use this third<br>option, which will store the coords of both pads on eachother during the <i>initialize pads</i> process.<br><b>BUT</b> that means that you CANNOT move the interPads without running <i>initialize maps</i> again.</html>'>Automatically swap to map for interpads</html></span></html>|RADIO|SELECT="+doSwitchInterMap)]
[h:inputStr	= json.append(inputStr, 'doScaleTeleport|'+doScaleTeleport+'|<html><span title="<html><b>When checked:</b> teleportation will keep track of different size teleports<br>This means that if you move to the lower right corner of a small pad you and up<br>on the lower right corner of a larger pad. <br><b>When unchecked:</b>teleportation will be relative to the upper left corner<br>of the teleport. So if you move from the lower right corner of a 4x4 to a 2x2<br>pad, then you will end up 2 squares down and 2 squares right OUTSIDE the 2x2 pad.<br>Mb<NOTE:</b> turning this on is tricky! E.g. if you make one of 2 vertical border pads<br>twice as thick as the other, and you move 6 squares over the pad, then you will<br>end up 12 (or 3 depending on the direction) beyond the other teleport!<br></html>">Scale Teleportation</html></span></html>|CHECK')]

[h:inputStr = json.append(inputStr, 'showGroupPanelOnSelect|'+showGroupPanelOnSelect+'|<html><span title="<html>When you select a <i>group</i> AND the <i>activate switch panel</i> is active<br>automatically show the group macro panel</html>">Show group panel on select</html></span></html>|CHECK')]
[h:inputStr = json.append(inputStr, 'fullScreenBroadcast|'+fullScreenBroadcast+'|<html><span title="<html>When you check this then the broadcast function will be redefined. Next to its<br>usual function it will ALSO broadcast to a dialog window called <i>Last Chat</i><br>but ONLY when the full screen mode is toggled (see campaign macros or F2). This<br>will result in a dialog popping up in full screen mode showing the last message<br>send to chat, using the broadcast function.<br><b>Important note:</b> currently its not possible to check whether a client is in<br>full screen or not, this means that this toggle is set for ALL clients.</html>">Redefine <i>Broadcast</i> for full screen mode</html></span></html>|CHECK')]
[h:inputStr = json.append(inputStr, 'numericIdOnly|'+numericIdOnly+'|<html><span title="<html>When you check this then ONLY special pads like Roof, Ward, PadStart, etc.<br>followed by a number (e.g. 1,2,3) will be identified as a special pad. E.g. <u>Roof 1</u><br>is recognized as a special pad and <u>Roof Red Barn</u> not. If you UNCHECK this<br>then <u>Roof Barn Red</u> WILL be identified as a special pad. As usual <i>linked</i> pads<br>require the SAME identifier. So <u>PadStart Sea Level</u> will be connected to<br><u>PadEnd Sea Level</u> (IF the box is unchecked!)<br><b>Note that Linked Pads will NOT work when this is checked</b></html>">Numeric Id for special pads only (disable Links!)</html></span></html>|CHECK')]

[h:inputStr = json.append(inputStr, 'baseMapName|'+startUpMapList+'|<html><span title="<html>The use of the Canopty option requires a BASE map where the treetrunks are situated. per default this Map is called BASE, here you can give it a different name.</html>">Name of BASE Map</html></span></html>|LIST|VALUE=STRING SELECT='+baseMapNum)]
[h:inputStr = json.append(inputStr, 'excludeLightTypes|'+excludeLightTypes+'|<html><span title="<html>Here you can enter one or more light <u>types</u> seperated by a comma (,) (e.g.: Generic, D20) that you dont want to show up as a tab in the Set Light Source macro</html>">Exclude Light Types</html></span></html>')]
[h:inputStr = json.append(inputStr, 'roofHaloColor|'+haloColors+'|<html><span title="<html>Here you can set the color of the halo for the Roof special pad</html>">Set Roof halo color</html></span></html>|LIST|VALUE=STRING SELECT='+roofHaloColor)]
[h:inputStr = json.append(inputStr, 'forceSelectClient|'+onLineClients+'|<html><span title="<html>If you select a client (player pc) from this list then when a gm selects a token<br>on a map that same token will also be selected on the chosen clients side. This <br>is particularly usefull in a laptop beamer setup where you have one single GM <br>client and one single players client to show the map. <br><br>Note that if a previously set (player) client does not exist when this campaign<br>is loaded then this value will be reset to empty and you need to run settings <br>again to select the client.</html>">Force Token Selection on Client</html></span></html>|LIST|VALUE=STRING SELECT='+forceSelectClient)]

[h:inputStr	= json.append(inputStr,"junk|<html><b>Animations<br></html>|-|LABEL|SPAN=TRUE")]
[h:inputStr = json.append(inputStr, 'animationPerClient|'+animationPerClient+'|<html><span title="<html>Animations like for the doors and the token movement will have an instance running<br>on eacht seperate client. This because the network connection of the server is<br>usually not fast enough to send updates of the animated object to the clients. This<br>requires a copy of the animated token on each client which is visible to the owner only.<br>This copy is removed from the client as soon as the animation is over.<br><i>Visible to owner only</i> will only work if <i>strict token ownership</i> is checked<br>for the running server. If its not set, then all the copies of all the clients are<br>visible on all the other clients as well. This will look messy. Hence this option to<br>run the animation on the server only.<br><b>When checked:</b> Animations will be played on each client<br><b>When unchecked:</b> Animations will be played on the server only<br></html>">Run animations per client</html></span></html>|CHECK')]
[h:inputStr = json.append(inputStr, 'timeLockDelay|'+timeLockDelay+'|<html><span title="<html>When using the token buttons to open or close doors then the onTokenSelectionEvent is<br>triggered. Unfortunately its triggered more than once. With the effect that the door<br>opens, closes, opens etc. To prevent this Ive created a time-out in which the event is<br>ignored. If this time is too short you will notice the door open-close event triggering<br>multiple times. If you set if to slow then you have to wait that time before you can<br>use the button again. The time is in ms meaning that 1000 = 1 second. If you encounter<br>the problem of the door animation triggering multiple times when you click the door<br>button then you should set this timer higher, e.g. to 1000. </html>">Time lock delay for token buttons (ms)</html></span></html>')]

[h:inputStr	= json.append(inputStr,"junk|<html><b>Summon Token Macro<br></html>|-|LABEL|SPAN=TRUE")]
[h:inputStr = json.append(inputStr, 'summonPcPropType|'+summonPcPropType+'|<html><span title="<html>The Summon token macro will show dropdowns of PCs and NPCs, <br>here you can set the the property type of PCs. Usually this <br>type is called Basic. </html>">Set Property Type of PCs</html></span></html>')]
[h:inputStr = json.append(inputStr, 'summonNpcPropType|'+summonNpcPropType+'|<html><span title="<html>The Summon token macro will show dropdowns of PCs and NPCs, <br>here you can set the the property type of NPCs. Usually this <br>type is called Basic. </html>">Set Property Type of NPCs</html></span></html>')]
[h:inputStr = json.append(inputStr, 'summonPropTypesList|'+summonPropTypesList+'|<html><span title="<html>Here you can setup the Summon Token macro. Summon token will show dropdowns of <br>(n)pcs and will also generate a dropdownbox for any tokenproperty<b><u>type</b></u> that <br>is listed here</html>">List of Summon Token Property Types</html></span></html>')]
[h:inputStr = json.append(inputStr, 'summonSpecialList|'+summonSpecialList+'|<html><span title="<html>Here you can setup the Summon Token macro. Summon token will show dropdowns of <br>(n)pcs and will generate a dropdownbox for listed tokenproperties. In addition <br>here you can set Token Names which you want to let appear in a seperate Dropdownbox. <br>Here its used for the special pad names, but it can be used for other purposes</html>">List of Summon Token Special</html></span></html>')]

<!-- ONCAMPAIGNLOAD -->
<!-- stuff that happens when the campaign is loaded -->
[h:inputStr = json.append(inputStr, "tab1|<html><b>On Campaign Load</html>||TAB")]
[h:inputStr	= json.append(inputStr, "junk|<html><b>Stuff that happens when you load the campaign</b></html>|-|LABEL|SPAN=TRUE")]
[h:inputStr = json.append(inputStr, 'useStartUpMap|'+useStartUpMap+'|<html><span title="<html><b>When checked:</b> the below two settings (load map on start up and go to coordinates) will be used.</html>">Use Start Up map and coordinates</html></span></html>|CHECK')]
[h:inputStr = json.append(inputStr, 'startUpMap|'+startUpMapList+'|<html><span title="<html>Pick here the name that should be loaded on campaign load or when players log in.</html>">Set map to open at start up</html></span></html>|LIST|VALUE=STRING SELECT='+startUpMapNum)]
[h:inputStr = json.append(inputStr, 'startUpCoords|'+startUpCoords+'|<html><span title="<html>Set here the coordinates which the map will be centred on campaign load<br>or when players log in. You can see the coordinates of your cursor on the<br>map in the lower right corner of Maptool. Example (X,Y): <b>5,4</b>.<br><br>Alternatively you can also enter a <b>token name</b>, however when you do that<br>make sure that the name does not contain any comma(s): <i>,</i></html>">Set coordinates to centre map on start up.</html></span></html>')]
[h:inputStr = json.append(inputStr, 'useCentreOnMePad|'+useCentreOnMePad+'|<html><span title="<html>This setting will override the coordinates unless the CentreOnMePad<br>is not found on the map. When you check this setting then on start up<br>the map will be centred onto this token for all clients.</html>">Centre on CentreOnMePad on start up.</html></span></html>|CHECK')]
[h:inputStr = json.append(inputStr, 'runSwitchForm|'+runSwitchForm+'|<html><span title="<html><b>When checked: </b>the form that you need to start so door switches work, <br>will start automatically on campaign load .</html>">Start door switches form</html></span></html>|CHECK')]
[h:inputStr = json.append(inputStr, 'disableOCLCheck|'+disableOCLCheck+'|<html><span title="<html><b>When checked: </b>The boT check result* shown in the chat<br>after you have loaded the campaign, will be turned OFF.<br><br>*Thats the red-yellow colored bar called:<br><i>Bag of Tricks - OnCampaignLoad checks</i></html>">Disable OCL Checks</html></span></html>|CHECK')]

<!-- EXCLUSIONS -->
<!-- map exclusion -->
[h:inputStr = json.append(inputStr, "tab1|<html><b>Exclusions</html>||TAB")]
[h:inputStr = json.append(inputStr, "junk|<html><b>Which maps should be excluded from the Initialization<br></html>|-|LABEL|SPAN=TRUE")]
[h:allMaps	= listSort(getAllMapNames(),"N+")]
[H:excludedMaps	= getLibProperty("excludedMaps","lib:EventMacros")]
[H, if(json.isEmpty(excludedMaps)): excludedMaps = "[]"]
[h,foreach(map, allMaps), CODE:{
	[H: isExcluded	= json.contains(excludedMaps,map)]
	[H: inputStr	= json.append(inputStr,strformat("map%{roll.count}|%{isExcluded}|%{map}|CHECK"))]
}]

<!-- Property type exclusion -->
[h:inputStr = json.append(inputStr, "junk|<html><b>Which propertyTYPES should NOT trigger the onTokenMoveEvent<br></html>|-|LABEL|SPAN=TRUE")]
[h:inputStr = json.append(inputStr, 'excludePropertyTypes|'+excludePropertyTypes+'|<html><span title="<html>Here you can enter one or more property types that will NOT trigger the onTokenMoveEvent.<br>Token property types can be set in menu-->edit-->campaign properties-->Token Properties.<br>There you find a list of the token properties for your campaign. Per default you will find the<br> Basic property type there. A property type for a token you can set by double clicking on<br>a token-->config tab-->Properties. That field contains a dropdown menu where you can choose <br>the property type for that token. All the Property Types you list in this field will NOT trigger<br>the event when moved. E.g. if you list SpecialPads here and your drag a token with the SpecialPad<br>property type onto a teleport token, then that token will NOT be teleported.</html>">Exclude Property Types</html></span></html>|TEXT|WIDTH=30')]

<!-- Toggles -->
[h:inputStr = json.append(inputStr, "tab1|<html><b>Toggles</html>||TAB")]
[h:inputStr = json.append(inputStr, "junk|<html><b>Here you can turn off certain checks to speed thing up<br></html>|-|LABEL|SPAN=TRUE")]
[h:inputStr = json.append(inputStr, 'doGroups|'+doGroups+						'|<html><span title="<html>Uncheck to turn off group movement</html>">Group movement</html></span></html>|CHECK')]
[h:inputStr = json.append(inputStr, 'doSnap2Grid|'+doSnap2Grid+					'|<html><span title="<html>Uncheck to turn off Snap To Grid. This is mainly<br>interesting for token move animation where you <br>want the tokens to move smoothly, but also have<br>them snapped to grid. When checked this option<br>will snap the last moved token to grid. This only<br>works when Maptools its Snap To Grid is turn off.</html>">Snap To Grid</html></span></html>|CHECK')]
[h, if(vblSupport == 1):inputStr 	= json.append(inputStr, 'doVBLStamp|'+doVBLStamp+	'|<html><span title="<html>Uncheck to turn off VBL stamps.<br>VBL Stamps are Vision Blocking Layer stamps that work on tokens<br>that have a label set to <i>VBLStamp</i>. When a tokens has this<br> word in its label a VBL cross will be drawn over it when it is moved.<br> And that VBL cross will move with the token.</html>">VBL Stamps</html></span></html>|CHECK') ; doVBLStamp = 0]
[h:inputStr = json.append(inputStr, 'doResetFoW|'+doResetFoW+					'|<html><span title="<html>Check to restore ALL Fog of War on every move</html>">Restore FoW</html></span></html>|CHECK')]
[h:inputStr = json.append(inputStr, 'doVBLCheck|'+doVBLCheck+					'|<html><span title="<html><i>This feature is developed by Aliasmask.</i><br>It does two things:<br><b>1.</b> If a token <i>cuts a corner</i> of a vision blocking area,<br>then a warning is given and the token is moved to the spot<br>BEFORE the corner was cut.<br> <b>2.</b> Because of the path that the token was dragged along<br>would be cleared of the fog of war (FoW) its movement is<br>reset and the macro clears the FoW.<br> The latter has the HUGE advantage that it also is a work<br>around for the (b87) FoW lag issue! If you have individual<br>FoW turned on for tokens then after a while dragging tokens<br>around can become very laggy. This option solves that issue.<br> The disadvantage is that if you move tokens over a large path<br>then it takes considerably longer (in addition to the normal<br>delay this Bag of Tricks introduces). The delay is not<br>noticeable for short distances but becomes e.g. 1 second<br>when you drag a token over 300 squares.<br>  </html>">VBL move check</html></span></html>|CHECK')]
[h:inputStr = json.append(inputStr, 'doCentreOnTok|'+doCentreOnTok+				'|<html><span title="<html>Check to continuously centre the map on the moving token.<br>Does not work for multiple moving tokens</html>">Centre on token</html></span></html>|CHECK')]
[h:inputStr = json.append(inputStr, 'doTriggerOnZeroMove|'+doTriggerOnZeroMove+	'|<html><span title="<html>If you move a token and put it back onto its original spot then,<br>this will trigger the onTokenMoveEvent. If you <b>check</b> this box then if<br>a token is standing on a special pad, that pad will be activated.<br><b>Uncheck</b> to ignore this zero move.<br><b>Note</b> that if you set Waypoints and then return to the original<br>spot, that the token has actually moved and the special pad<br>WILL be activated!</html>">Trigger Pads on zero move</html></span></html>|CHECK')]
[h:inputStr = json.append(inputStr, 'doSpecialPads|'+doSpecialPads+				'|<html><span title="<html>Uncheck to turn off the special pads entirely (Check Start and Check Path included).</html>">Check special pads</html></span></html>|CHECK')]
[h:inputStr = json.append(inputStr, 'doLockMovement|'+doLockMovement+			'|<html><span title="<html>Check to prevent the movement of locked tokens.<br>You can select a token and toggle the <i>lock movement</i><br>macro. When a token is locked this way AND when this setting<br>is turned on, the movement of that tokens will always be <br>reverted. Not even the gm can move the token.<br></html>">Lock movement for locked tokens</html></span></html>|CHECK')]
[h:inputStr = json.append(inputStr, 'doFullScreenMode|'+doFullScreenMode+		'|<html><span title="<html>b89+: Check to turn on a isFullScreen check.<br>This will automatically switch the BoT macro panel to<br>full screen mode (showing the panel while in full screen)<br>and back to a dockable frame when not in full screen.</html>">Full Screen Mode</html></span></html>|CHECK')]
[h:inputStr = json.append(inputStr, 'doShowPath|Do not Track Path, Track Path, Track Path and delete feet manually|<html><span title="<html>When Track Path is turned on, small feet will be placed in the cells over which a token is moved. <br>Red feet for NPCs and Blue feet for PCs.<br><br><b>Do not Track Path:</b> its turned off <br><b>Track Path:</b> its turned on, only the LAST move is shown<br><b>Track Path and delete feet manually:</b> for every move feet will be placed in the path. <br>To remove them from the map use the following command: [bot_getPath(3)]<br><br><b><u>Note that 3 conditions MUST BE MET before you toggle this setting:</u></b><br>1. the blue and red feet must on the BASE map and NOT on the OBJECT layer<br>2. a state <i>pathFeet</i> must be created (the feet must have that state)<br>3. BOTH the <i>impersonation and selection panel</i> must be closed (or the removal will be <br>extremely slow)</html>">Show the last moved path</html></span></html>|RADIO|SELECT='+doShowPath)]
[h:inputStr = json.append(inputStr, 'canSelectShadowTok|Object Layer, Token Layer, Token Layer and autoselect Main Token|<html><span title="<html>When using shadow pads, you can choose the layer where the shadow tokens are placed:<br>- Object layer: shadow token can not be selected (targeted) by players<br>- Token layer: shadow token *can* be selected (targeted) by players<br>- Token layer (autoselect main): when the shadow token is selected the actual token is selected instead.<br>The latter requires the <i>activate switches</i> macro to be running.</html>">Where to place Shadow Tokens</html></span></html>|RADIO|SELECT='+canSelectShadowTok)]

[h:inputStr = json.append(inputStr, "junk|<html><b>The following toggles work for altInitMap only!<br></html>|-|LABEL|SPAN=TRUE")]
[h:inputStr = json.append(inputStr, 'doFirstPointPath|'+doFirstPointPath+	'|<html><span title="<html>This concerns the special pads. If a token starts its movement on a special pad<br>e.g.(under) canopy, then the token activates the relevant code.<br>E.g. in case of Canopy if the token moves away far enough then it will restore<br>the Canopy picture. Turning this off will result in this check NOT taking place.<br>So Canopy will dissapear but no longer reappear. Turning this off is usefull when<br>you are not using Canopy, Foliage or Roof pads.</html>">Check Start (Canopy, Foliage or Roof)</html></span></html>|CHECK')]
[h:inputStr = json.append(inputStr, 'doInnerPointsPath|'+doInnerPointsPath+	'|<html><span title="<html>This concerns the special pads. If a token moves over a Ward or EventPad,<br>then the code is activated for that pad encountered. E.g. in case of Ward,<br>the Token is placed on the edge of the ward and the rest of the movement is negated.<br>Turning this off is usefull when you are not using Ward or EventPad pads.</html>">Check Path (Ward, Event)</html></span></html>|CHECK')]

[h:inputStr = json.append(inputStr, "junk|<html><b>Movement Limiter!<br></html>|-|LABEL|SPAN=TRUE")]
[h:inputStr = json.append(inputStr, 'limitMovement|'+limitMovement+			'|<html><span title="<html>Here you can set a number or a token property to which token movement is limited during<br>initiative. Entering e.g. <i>4</i> means that the max allowed move is 4 cells. Entering<br><i>movement</i> will limit the movement of the token to its <i>movement</i> property. You<br>can enter any token property you like as long as that token property contains a number.<br>Should a player in this case move her token 5 or more cells, then they will receive a<br>message and the movement will be reset (so the tokens will be returned to its original<br>position). <br><br><b>Note that this feature will NOT work:</b><br>- when the user moving the token is a GM<br>- when the number set here is 0<br>- when the token is NOT in the initiative panel<br><br>Also note that this does not prevent someone from moving her token twice!<br><br><b>The macro that handles this is placed on the lib:EventMacros.</b> You can edit<br>this macro to better suit your framework. More explanations you can find there.</html>">Limit movement to: (0 = ignore)</html></span></html>')]

<!-- General Events -->
[h:inputStr = json.append(inputStr, "tab1|<html><b>General Events</html>||TAB")]
[h:inputStr = json.append(inputStr, "junk|<html><b>Here you can link an event macro to other events</b><br>Note that only the macros from the group:<br>'Event list macros' are in the drop downlists</html>|-|LABEL|SPAN=TRUE")]
[h:inputStr = json.append(inputStr, 'eventMacroPreTokenMove|'				+macroNameList+'|<html><span title="<html><b>Select an event macro THAT ALWAYS executes EVERYTIME AFTER<br>initialization but BEFORE the OnTokenMove event macro is executed.<br>This macro will run before any of the OnTokenMove code is executed</html>">Pre On Token Move</html></span></html>|LIST|SELECT='+eventMacroPreTokenMove)]
[h:inputStr = json.append(inputStr, 'eventMacroPreMultipleTokenMove|'		+macroNameList+'|<html><span title="<html><b>Select an event macro THAT ALWAYS executes EVERYTIME AFTER<br>initialization but BEFORE the OnMultipleTokenMove event macro is executed.<br>This macro will run before any of the OnMultipleTokenMove code is executed</html>">Pre On Multiple Token Move</html></span></html>|LIST|SELECT='+eventMacroPreMultipleTokenMove)]
[h:inputStr = json.append(inputStr, 'eventMacroOnTokenMove|'				+macroNameList+'|<html><span title="<html><b>Select an event macro THAT ALWAYS executes EVERYTIME ONE token moves.<br>This macro will run before any events of the special pads take place</html>">On Token Move</html></span></html>|LIST|SELECT='+eventMacroOnTokenMove)]
[h:inputStr = json.append(inputStr, 'eventMacroOnMultipleTokensMove|'		+macroNameList+'|<html><span title="<html><b>Select an event macro THAT ALWAYS executes EVERYTIME MULTIPLE tokens are moved.<br>This macro will run before any events of the special pads take place</html>">On Multiple Token Move</html></span></html>|LIST|SELECT='+eventMacroOnMultipleTokensMove)]
[h:inputStr = json.append(inputStr, 'eventMacroPostTokenMove|'				+macroNameList+'|<html><span title="<html><b>Select an event macro THAT ALWAYS executes EVERYTIME ONE token moves.<br>This macro will run after any events of the special pads take place</html>">After Token Move</html></span></html>|LIST|SELECT='+eventMacroPostTokenMove)]
[h:inputStr = json.append(inputStr, 'eventMacroPostMultipleTokensMove|'		+macroNameList+'|<html><span title="<html><b>Select an event macro THAT ALWAYS executes EVERYTIME MULTIPLE tokens are moved.<br>This macro will run after any events of the special pads take place</html>">After Multiple Token Move</html></span></html>|LIST|SELECT='+eventMacroPostMultipleTokensMove)]
[h:inputStr = json.append(inputStr, 'eventPreMacroTeleport|'				+macroNameList+'|<html><span title="<html><b>Select an event macro to execute BEFORE a teleport on the same map occurs.</html>">Before Teleport on same map</html></span></html>|LIST|SELECT='+eventPreMacroTeleport)]
[h:inputStr = json.append(inputStr, 'eventPostMacroTeleport|'				+macroNameList+'|<html><span title="<html><b>Select an event macro to execute AFTER a teleport on the same map occurs.</html>">After Teleport on same map</html></span></html>|LIST|SELECT='+eventPostMacroTeleport)]
[h:inputStr = json.append(inputStr, 'eventMacroPreInterTeleport|'			+macroNameList+'|<html><span title="<html><b>Select an event macro to execute BEFORE a teleport to another map occurs.</html>">Before Teleport to other map</html></span></html>|LIST|SELECT='+eventMacroPreInterTeleport)]
[h:inputStr = json.append(inputStr, 'eventMacroPostInterTeleport|'			+macroNameList+'|<html><span title="<html><b>Select an event macro to execute AFTER a teleport to another map occurs.</html>">After Teleport to other map</html></span></html>|LIST|SELECT='+eventMacroPostInterTeleport)]

<!-- System -->
[h:inputStr = json.append(inputStr, "tab1|<html><b>System</html>||TAB")]
[h:inputStr = json.append(inputStr, "junk|<html><b>Here you can set the technical stuff</b><br>As a general rule: do not touch unless you <br>know what you are doing</html>|-|LABEL|SPAN=TRUE")]
[h:inputStr = json.append(inputStr, 'libCoordSize|'+libCoordSize+'|<html><span title="<html>This setting is used for the alternative initialize map pads macro for a map<br>Just do not change this value. Its used for the x/y area size of the lib coords</html>">Lib coords size</html></span></html>')]
[h:inputStr = json.append(inputStr, 'maxPadsPerRun|'+maxPadsPerRun+'|<html><span title="<html>This setting is used for the alternative initialize map pads macro for a map<br>If you have a map with a LOT of special pads on it (> 500) it is likely that<br>Maptool will crash when initializing them all at once. For this reason Ive<br>implemented this setting to break up large numbers of special pads to scan into<br>smaller bits which requires you to run the alternative initializing macro more than once.<br>The maximum supported amount of special tokens on one map is 1000 so the default<br>setting (500) will require you to run the init macro at most twice. <br><br><b>Change this when:</b> This number of pads to scan in one run might be too<br>much for older pcs and Maptool might crash. If this is the case lower the setting.<br></html>">Maximum of pads to scan per run</html></span></html>')]
[h:inputStr = json.append(inputStr, 'maxGroupSelect|'+maxGroupSelect+'|<html><span title="<html>This setting is used for the group selection feature, specifically the panel. If a too large selection is made (>1000) MT crashes.<br>In addition the tool will become terribly slow when many are selected. To make sure this is no issue a max limit is set. The default<br>is 500 but you can lower (to speed things up) or up (to allow bigger selections) then number to a max of 1000 (at your own risk)</html>">Maximum allowed group selection</html></span></html>')]
[h:inputStr = json.append(inputStr, 'maxOrderSelect|'+maxOrderSelect+'|<html><span title="<html>This setting is used for the order selection panel. If a too large selection is made (roughly over 500) MT crashes. In addition the tool<br>will become terribly slow when many are selected. To make sure this is no issue a max limit is set. The default is 200 but you<br>can lower (to speed things up) or up (to allow bigger selections) then number to a max of 500 (at your own risk)</html>">Maximum allowed order selection</html></span></html>')]
[h:inputStr = json.append(inputStr, 'padNameList|'+padNameList+'|<html><span title="<html>This is the entire list of special pads. If you remove any of this list then these will not be initialized.<br>If you somehow have messed this up, clear the entire box click OK and then run OCL. </html>">Special Pads List</html></span></html>|TEXT|WIDTH=30')]

<!-- run the input -->
[H: abort(input(json.toList(inputStr,"##")))]

<!-- process results of input -->
[H: excludedMaps = "[]"]
[h, foreach(map, allMaps), code: {
	[H, if(eval("map"+roll.count)): excludedMaps = json.append(excludedMaps,map)]
}]

<!-- if startup coords are not set -->
[h,if(startUpCoords == 0): startUpCoords = "0,0"]

[h,if(!summonPropTypesList): summonPropTypesList = ""]
[h,if(!summonSpecialList): summonSpecialList = ""]

<!-- convert the macro index into the actual macro name -->
[h,foreach(trigger, triggerEventList):set(trigger, listGet(macroNameList, eval(trigger)))]

<!-- check redefine broadcast and initiate accordingly -->
[h,if(oldFSB != fullScreenBroadcast):broadcast("You have changed the broadcast setting. For this to take effect you will need to RELOAD the campaign. Note that its a bad idea to run oncampaignload in this case, you really need to reload the campaign!")]

[H:setLibProperty("useStartUpMap",useStartUpMap,"lib:EventMacros")]
[H:setLibProperty("startUpMap",startUpMap,"lib:EventMacros")]
[H:setLibProperty("startUpCoords",startUpCoords,"lib:EventMacros")]
[H:setLibProperty("useCentreOnMePad",useCentreOnMePad,"lib:EventMacros")]
[H:setLibProperty("runSwitchForm",runSwitchForm,"lib:EventMacros")]
[H:setLibProperty("disableOCLCheck",disableOCLCheck,"lib:EventMacros")]

[H:setLibProperty("excludedMaps",excludedMaps,"lib:EventMacros")]
[h:setLibProperty("useAltImage", useAltImage,"lib:EventMacros")]
[h:setLibProperty("checkMapsOCL", checkMapsOCL,"lib:EventMacros")]
[h:setLibProperty("showGroupPanelOnSelect", showGroupPanelOnSelect,"lib:EventMacros")]
[h:setLibProperty("fullScreenBroadcast", fullScreenBroadcast,"lib:EventMacros")]
[h:setLibProperty("numericIdOnly", numericIdOnly, "lib:EventMacros")]

[h:setLibProperty("baseMapName", baseMapName,"lib:EventMacros")]
[h:setLibProperty("excludeLightTypes",excludeLightTypes, "lib:EventMacros")]

[h:setLibProperty("animationPerClient", animationPerClient,"lib:EventMacros")]
[h:setLibProperty("timeLockDelay", timeLockDelay, "lib:EventMacros")]

[h:setLibProperty("summonPcPropType", summonPcPropType,"lib:EventMacros")]
[h:setLibProperty("summonNpcPropType", summonNpcPropType,"lib:EventMacros")]
[h:setLibProperty("summonPropTypesList", summonPropTypesList,"lib:EventMacros")]
[h:setLibProperty("summonSpecialList", summonSpecialList,"lib:EventMacros")]

[h:setLibProperty("libCoordSize", libCoordSize, "lib:EventMacros")]
[h:setLibProperty("maxPadsPerRun", maxPadsPerRun,"lib:EventMacros")]
[h:setLibProperty("maxGroupSelect", maxGroupSelect,"lib:EventMacros")]
[h:setLibProperty("maxOrderSelect", maxOrderSelect,"lib:EventMacros")]
[h:setLibProperty("padNameList", padNameList, "lib:EventMacros")]

[h:doVBLStamp = if(doVBLStamp && vblSupport, 1, 0)]

<!-- Initialize drawArea -->
[h, if(getStrProp("toggles", "drawArea") == ""), CODE:{
	[drawArea	= 0]
	[setLibProperty("tmpDraWArea", "[]", "lib:EventMacros")]
}]

[h:toggles = strPropFromVars("forceSelectClient,roofHaloColor, doSwitchInterMap,doScaleTeleport,doGroups,doSnap2Grid,doVBLStamp,doResetFoW,doVBLCheck,doTriggerOnZeroMove,doCentreOnTok, doLockMovement, doFullScreenMode, doShowPath, canSelectShadowTok, doSpecialPads, doFirstPointPath, doInnerPointsPath, limitMovement, eventMacroPreTokenMove, eventMacroPreMultipleTokenMove, eventMacroOnTokenMove, eventMacroOnMultipleTokensMove, eventPreMacroTeleport, eventPostMacroTeleport, eventMacroPreInterTeleport, eventMacroPostInterTeleport, eventMacroPostTokenMove, eventMacroPostMultipleTokensMove,movementLock,excludePropertyTypes,drawArea", "UNSUFFIXED")]
[h:setLibProperty("toggles", toggles,"lib:EventMacros")]
Settings done.

@@showHandout
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy=23 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip=<html> Pops up a dialog showing the handout of the selected token on all selected clients ; minWidth=90 ; 
[h:'<!------------------------------------- showHandout (0/1=return image ID) ------------------------------------------------>']
<!-- <html> Pops up a dialog showing the handout of the selected token on all selected clients -->
[h,if(argCount() > 0): returnID	= arg(0) ; returnID = 0]

[h:assert(isGM(),"This macro can only be run by the GM",0)]
[h:me			= getSelected()]
[h:assert(listCount(me)==1, "Make sure (only) one token is selected",0)]
[h:userList		= if(returnID, "", getAllPlayerNames())]

[h, token(me),CODE:{
	[image		= "<html><table><tr><td height='100'><img width=90 height=90 src='"+getTokenImage()+"'></img>	</td></tr><tr><td align='center'>Image</td>	</tr></table></html>"]
	[portrait	= "<html><table><tr><td height='100'><img width=90 height=90 src='"+getTokenPortrait()+"'></img>	</td></tr><tr><td align='center'>Portrait</td>	</tr></table></html>"]
	[handout	= "<html><table><tr><td height='100'><img width=90 height=90 src='"+getTokenHandout()+"'></img>	</td></tr><tr><td align='center'>Handout</td>	</tr></table></html>"]
}] 

[H: inputStr	= "[]"]
[H: inputStr	= json.append(inputStr,"junk|<html><b>Choose picture to show to players:<br></html>|-|LABEL|SPAN=TRUE")]
[H: inputStr	= json.append(inputStr,"picChoice|"+image+","+portrait+","+handout+"|Which picture|RADIO|ORIENT=H SELECT=2")]
[H: inputStr	= json.append(inputStr,"picSize|500|Size of picture (px)")]
[h,if(!returnID), CODE:{
	[H: inputStr	= json.append(inputStr,"text|<enter handout-text here>|Handout text (html)")]
	[H: inputStr	= json.append(inputStr,"junk|<html><b>Select Players<br></html>|-|LABEL|SPAN=TRUE")]
	[H,FOREACH(player, userList): inputStr = json.append(inputStr,"player"+roll.count+"|1|"+player+"|CHECK")]
};{}]

[H: inputStr	= json.evaluate(inputStr)]
[H: abort(input(json.toList(inputStr,"##")))]

[h:playerList = ""]
[H,FOREACH(player, userList), CODE:{	
	[if(eval("player"+roll.count)): playerList = listAppend(playerList, player)]
}]

[h,token(me), if(picChoice == 0): handoutID = getTokenImage(picSize)]
[h,token(me), if(picChoice == 1): handoutID = getTokenPortrait(picSize)]
[h,token(me), if(picChoice == 2): handoutID = getTokenHandout(picSize)]

[h,if(returnID):
	macro.return = handoutID
;
	bot_execAllPlayers("popUpHandout@lib:OnTokenMove",json.append("",handoutID,picSize,text), playerList)
]

@@toggleFullScreen
@PROPS@ fontColor=green ; autoExecute=true ; fontSize=1.00em ; sortBy=42 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip=<html>When toggled, the frames will be changed into dialogs,<br> which ARE allowed in full screen. This way when you<br> toggle this button you can have acces to chat and macros<br> in the form of dialogs.<br> In addition, when you have turned on the <i>redefine broadcast</i><br> setting in the settings, then when using the broadcast() function<br> a dialog will pop up showing the last message broadcasted. ; minWidth=90 ; 
[h:'<!-- ------------------------------------- toggle full screen mode ----------------------------------------------------- -->']
<!-- <html>When toggled, the frames will be changed into dialogs,<br> which ARE allowed in full screen. This way when you<br> toggle this button you can have acces to chat and macros<br> in the form of dialogs.<br> In addition, when you have turned on the <i>redefine broadcast</i><br> setting in the settings, then when using the broadcast() function<br> a dialog will pop up showing the last message broadcasted. -->

<!-- retrieve current setting -->
[FSM = getLibProperty("fullScreenMode", "Lib:EventMacros")]

<!-- initialize setting if not done so before -->
[if(FSM == ""): FSM = 1]
<!-- toggle the setting -->
[FSM = 1- FSM]

<!-- save it -->
[h:setLibProperty("fullScreenMode", FSM , "Lib:EventMacros") ]

<!-- send message to user -->
[h:message = if(FSM, "Full Screen Mode is now turned ON", "Full Screen Mode is now turned OFF")]
[h:bot_message("",message)]

<!-- send virtual bot menu to the full screen in dialog form -->
[closeDialog("Bag Of Tricks Macros")]
[closeFrame("Bag Of Tricks Macros")]
[bot_MacroButtonsOTMUtils()]

[h, if(isFrameVisible("Bag Of Tricks Macros")): bot_MacroButtonsOTMUtils()]

<!-- make sure there's no output to chat -->
[abort(0)]

<!-- ---------------------------------------------------------------------------------->
<!-- ---------------------code to add to depending functions ----------------------- -->
<!-- ---------------------------------------------------------------------------------->

[if(getLibProperty("fullScreenMode", "Lib:EventMacros")), CODE:{
	[dialog("Bag Of Tricks Macros", "width=215; height=700; temporary=0; input=1"): {
		[r:bot_createMacroButtonsOTMSetup()]
	}]
};{
	[frame("Bag Of Tricks Macros", "width=215; height=700; temporary=0"): {
		[r:bot_createMacroButtonsOTMSetup()]
	}]
}]

@@toggleSpecial
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=62 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip= ; minWidth=90 ; 
[h:'<!-- toggleSpecial -->']
[h:useAltImage = getLibProperty('useAltImage', 'lib:EventMacros')]
[h:assert(if(listContains(json.toList(json.get(getInfo("campaign"),"tables")), "tbl_Image"),1,0), "You will need to install the Bag of Tricks Image Tables first before you can use this option. See the how to install on the the forum",0)]

[h:selectedTokens	= getSelectedNames()]
[h, if(selectedTokens == ""):
	allToks			= json.toList(json.sort(getTokenNames(",", json.set("{}", "layer", json.append("","TOKEN", "OBJECT", "HIDDEN","BACKGROUND")))))
; 
	allToks			= selectedTokens
]
[h:roofToks			= ""]

[h:specNameList = "Canopy, Foliage, Roof, Linked"]
[h:abort(input("tokenName|"+specNameList+"|Choose the special tokens on this map to toggle on or off?|LIST|VALUE = STRING"))]
[h,foreach(tok, allToks), CODE:{
	[if(startsWith(tok, tokenName)), CODE:{
		[roofToks = listAppend(roofToks, tok)]
		[setProperty("w42.bot.tokens.onHouse", "", tok)]
	}; {}]
}]

[h:assert(roofToks != "", "No "+tokenName+" tokens found "+if(selectedTokens!="", "in selection", "on map"), 0)]
[h:tmpTok = listGet(roofToks, 0)]

[h: switchToken(tmpTok)]
[h, if(getTokenHandout() != ""): noRoofImg = getTokenHandout(); noRoofImg = tblImage("tbl_Image",1)]
[h: currentImg = getTokenImage()]
[h, if(currentImg != noRoofImg): noRoof = 1; noRoof = 0]

[h:'pause("allToks", "roofToks", "tmpTok", "noRoof", "currentImg", "noRoofImg")']

[h,if(noRoof), CODE:{
	[h, foreach(tok, roofToks), CODE:{
		[switchToken(tok)]
		[setProperty("w42.bot.tokens.onHouse","")]
		[if(getTokenHandout() != ""): noRoofImg = getTokenHandout(); noRoofImg = tblImage("tbl_Image",1)]
		[roofImg = getTokenImage()]
		[if(roofImg != noRoofImg):setProperty("w42.bot.image.original", roofImg)]

		[setTokenImage(noRoofImg)]
	}]
}; {
	[h, foreach(tok, roofToks), CODE:{
		[switchToken(tok)]
		[setProperty("w42.bot.tokens.onHouse","")]
		[setTokenImage(getProperty("w42.bot.image.original"))]
		[setHalo("None")]
	}]
}]

@@tokenLock
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=20 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Util ; tooltip=<html>When this is turned ON, no one (gm included) can move the selected token(s).<br>For this to work the toggle in the settings: 'Lock Movement for Locked Tokens' needs to be turned on!</html> ; minWidth=90 ; 
[h:'<!------------------------------------- tokenLock ------------------------------------------------>']
<!-- <html>When this is turned ON, no one (gm included) can move the selected token(s).<br>For this to work the toggle in the settings: 'Lock Movement for Locked Tokens' needs to be turned on!</html> -->
[ids	= getSelected()]
[assert(listCount(ids == 1), "Make sure that at least one token is selected", 0)]

[h,foreach (id, ids), CODE:{
	[switchToken(id)]
	[assert(isGM(),"This macro may only be executed by the GM",0)]
	[lockMovement	= if(getProperty("w42.bot.lockMovement") == 1, 0, 1)]
	[setProperty("w42.bot.lockMovement",lockMovement)]
	[broadcast("<b>The movement for "+token.name+" has been <font color=blue>"+if(lockMovement,"LOCKED","UNLOCKED")+"</font></b>")]
}]

@@Launch Dice Box
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=gray ; playerEditable=true ; applyToSelected=false ; group=Rumbles Dicebox ; tooltip= ; minWidth=90 ; 
<!-- CODE ORIGINALLY FROM RUMBLE'S DICEBOX. REWRITTEN BY WOLPH42-->
<!-- <html>Opens a form with dices where you can set a group of dice to roll<br>The workings of the Dice box are pretty obvious. What might not be<br>obvious is that it supports 10 different dice boxes. You can click the<br>macro 10 times and set each frame individually. -->
[h: maxFrames	= 10]
[h: frameNum	= maxFrames + 1]
[h,count(maxFrames), CODE:{
	[frameName = "Dice Box "+roll.count]
	[if(!isFrameVisible(frameName)):frameNum = min(frameNum, roll.count)]
}]
[h:assert(frameNum <= maxFrames, "You already have the maximum number of frames open",0)]
[h:assert(if(listContains(json.toList(json.get(getInfo("campaign"),"tables")), "tbl_Image"),1,0), "You will need to install the Bag of Tricks Image Tables first before you can use this option. See the how to install on the the forum",0)]

[h:frameName = "Dice Box "+frameNum]

[h: dbArgs = json.set("{}", "mod", 0, "tn", 0, "d4s", 0, "d5s", 0, "d6s", 0, "d8s", 0, "d10s", 0, "d12s", 0, "d20s", 0, "d100s", 0, "showTo", "all", "breakdown", "totalRoll", "frameName", frameName)]

[macro("NDB@this"):dbArgs]

@@NDB
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=default ; playerEditable=true ; applyToSelected=false ; group=Rumbles Dicebox ; tooltip= ; minWidth= ; 
[h:'<!-- --------------------- NDB ----------------------------->']
[h:dbArgs = macro.args]

<!-- Basic Variables from Library Properties-->
<!-- dbArgs = "mod", 0, "tn", 0, "d4s", 0, "d5s", 0, "d6s", 0, "d8s", 0, "d10s", 0, "d12s", 0, "d20s", 0, "d100s", 0, "showTo", "all", "breakdown", "totalRoll" -->
[h,if(json.contains(dbArgs, "explodeDice")): explodeCode = if(json.get(dbArgs, "explodeDice") !=0 ,"CHECKED",""); explodeCode = ""]
<!-- turn all the json keys into variables -->
[h:varsFromStrProp(json.toStrProp(dbArgs))]

[h:frameNum		= replace(frameName, "Dice Box ", "")]
[h:dieList 		= getLibProperty("dieList"+frameNum, "Lib:EventMacros")]
[h:optionsList 	= getLibProperty("optionsList"+frameNum, "Lib:EventMacros")]

<!-- showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=eachRoll ;  -->
[h:varsFromStrProp(optionsList)]

[if(dieList == ""): dieList 		= "4,5,6,8,10,12,20,100"]		

[h: showAll		= if(showTo == "all", "CHECKED", "")]
[h: showGMSelf	= if(showTo == "gm-self", "CHECKED", "")]
[h: showGM		= if(showTo != "all" && showTo != "gm-self", "CHECKED", "")]
[h: showTotals	= if(breakdown == "totalRoll", "CHECKED", "")]
[h: showEach	= if(breakdown != "totalRoll", "CHECKED", "")]

<!-- Common Variables for the Form-->
[h:action		= macroLinkText("NDBUpdate@this","all")]
[h:d4img		= tableImage("tbl_Image",16)]
[h:d5img		= tableImage("tbl_Image",17)]
[h:d6img		= tableImage("tbl_Image",18)]
[h:d8img		= tableImage("tbl_Image",19)]
[h:d10img		= tableImage("tbl_Image",20)]
[h:d12img		= tableImage("tbl_Image",21)]
[h:d20img		= tableImage("tbl_Image",22)]
[h:d100img		= tableImage("tbl_Image",23)]
[h:clearAllLink	= macroLink("(Clear All)", "NDBCall@"+getMacroLocation(), "none")]

<!-- head of frame -->
[h:diceBoxStr	= "
	<html><head><title>%{frameName}</title></head><body><form name='%{frameName}' method='json' action='%{action}'>
	<table align='left' color='black' cellpadding='1'><tr><td valign='centre' align='left'>
		<table cellpadding='1' border='0' valign='centre'><tr><td>
		<input type='hidden' name='frameName' value='%{frameName}'>
"]

<!-- dice part of the frame -->
<!-- initialize all dice types, this needs to be done in case the options are changed-->
[h,foreach(dice, "4,5,6,8,10,12,20,100"): diceBoxStr = diceBoxStr + "<input type='hidden' name='d"+dice+"s'	value=0>"]

<!-- only list the dice that have been listed in the options -->
<!-- 	foreach content:
		'-' Button: lower #dice in NDBUpdate				
		image of die							
		'+' Button: up #dice in NDBUpdate 							
		text box showing dice result		-->
[h,foreach(dice, dieList): diceBoxStr = diceBoxStr + "
			<input type='submit' value='<html>-<!-- "+dice+" -->'	name='clickedButton'>	</td><td>	
			<img src='%{d"+dice+"img}'></img>					</td><td>	
			<input type='submit' value='<html>+<!-- "+dice+" -->'	name='clickedButton'>	</td><td>	
			<input type='text' name='d"+dice+"s'	value='%{d"+dice+"s}' size='2'></td></tr><tr><td>
"]

<!-- options part of the frame and the cancel roll buttons-->
[h:diceBoxStr	= diceBoxStr + "
		</td></tr></table>
		</td><td align='left' valign='top' style='font-size:small; '>

		<table cellpadding='1' border='0'><tr><td>"
			+	if(showMod,		"<b>Modifier</b>:	</td><td>	<input type='text'		name='mod'	value='%{mod}' size='3'>	</input></td></tr><tr><td>",	"<input type='hidden' name='mod'			value='"+modifier+"'>")
			+	if(showTarget,	"<b>Target </b>:	</td><td>	<input type='text'		name='tn'	value='%{tn}' size='3'>		</input></td></tr><tr><td>",	"<input type='hidden' name='tn'				value='"+target+"'>")
			+	if(showExplode,	"<b>Explode?</b>:	</td><td>	<input type='checkbox'	name='explodeDice'  %{explodeCode}>		</input></td></tr><tr><td>",	"<input type='hidden' name='explodeDice'	value='"+explode+"'>")
		+"</table>"

		+ if(showResults, "<b>Show Results To:</b>
		<table  cellpadding='3' border='0'><tr><td>
			<input type='radio' name='showTo' value='all'		%{showAll}></input>		</td><td> All			</tr><tr><td>
			<input type='radio' name='showTo' value='gm'		%{showGM}></input>		</td><td> GM Only		</tr><tr><td>
			<input type='radio' name='showTo' value='gm-self'	%{showGMSelf}></input>	</td><td> You and GM	</tr><tr><td>
		</table>", "<input type='hidden' name='showTo' value='"+showGMOption+"'>")
		
		+ if(showTooltip, "<b>Tooltip Info:</b>
		<table  cellpadding='3' border='0'><tr><td>
			<input type='radio' name='breakdown' value='totalRoll'	%{showTotals}>	</td><td> Totals	</tr><tr><td>
			<input type='radio' name='breakdown' value='eachRoll'	%{showEach}>	</td><td> Each Die	</tr><tr><td>
		</table>","<input type='hidden' name='breakdown' value='"+eachRollOption+"'>")
	+"</td></tr></table>
<input type='submit' width='40' name='clickedButton' value='Roll'>		&nbsp; 
<input type='submit' width='40' name='clickedButton' value='Clear'>		&nbsp; 
<input type='submit' width='40' name='clickedButton' value='Options'>

	</form></body></html>
"]

[if(bot_isFullScreen()), CODE:{
	[dialog(frameName,"width=250; height=350; temporary=0; input=1"):	{ [r:strformat(diceBoxStr)] }]
};{
	[frame(frameName,"width=250; height=350; temporary=0; "):			{ [r:strformat(diceBoxStr)] }]
}]

[h:abort(0)]

@@NDBUpdate
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=default ; playerEditable=true ; applyToSelected=false ; group=Rumbles Dicebox ; tooltip= ; minWidth= ; 
[h:'<!-- --------------------- NDBUpdate ----------------------------->']

[h:dbArgs		= macro.args]
[h:frameName	= json.get(dbArgs, "frameName")]

[h:clickedButton = json.get(dbArgs, "clickedButton")]
[h,switch(clickedButton), CODE:
	case "Clear":{
		[dbArgs = json.set("{}", "mod", 0, "tn", 0, "d4s", 0, "d5s", 0, "d6s", 0, "d8s", 0, "d10s", 0, "d12s", 0, "d20s", 0, "d100s", 0, "showTo", "all", "breakdown", "totalRoll", "frameName", frameName)]
		[macro("NDB@this"): dbArgs]
	}; 
	case "Options":{
		[frameNum		= replace(frameName, "Dice Box ", "")]
		[dieList 		= getLibProperty("dieList"+frameNum, "Lib:EventMacros")]
		[optionsList 	= getLibProperty("optionsList"+frameNum, "Lib:EventMacros")]
		<!-- showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=eachRoll ;  -->
		[varsFromStrProp(optionsList)]

		<!-- convert form values to options -->
		[showGMOption	= listFind("all,gm, gm-self", showGMOption)]
		[eachRollOption	= if(eachRollOption == "eachRoll", 1, 0)]

		[abort(input(
			"junk|<html><b>Check the dice to show on the form</b></html>|-|LABEL|SPAN=TRUE",
			"Di4|"+listContains(dieList, 4)+"|Show D4|CHECK",
			"Di5|"+listContains(dieList, 5)+"|Show D5|CHECK",
			"Di6|"+listContains(dieList, 6)+"|Show D6|CHECK",
			"Di8|"+listContains(dieList, 8)+"|Show D8|CHECK",
			"Di10|"+listContains(dieList, 10)+"|Show D10|CHECK",
			"Di12|"+listContains(dieList, 12)+"|Show D12|CHECK",
			"Di20|"+listContains(dieList, 20)+"|Show D20|CHECK",
			"Di100|"+listContains(dieList, 100)+"|Show D100|CHECK",
			"junk|<html><b>Check the options you want to show on the form</b></html>|-|LABEL|SPAN=TRUE",
			"showMod|"+showMod+"|Show the 'set modifer' box|CHECK",
			"showTarget|"+showTarget+"|Show the 'set succes target' box|CHECK",
			"showExplode|"+showExplode+"|Show the 'explode die' check box|CHECK",
			"showResults|"+showResults+"|Show the 'show results to' options|CHECK",
			"showTooltip|"+showTooltip+"|Show the 'show tooltip' options|CHECK",
			"junk|<html><b>IF certain options are HIDDEN, THEN what should they be set to<br></b>These settings will be ignored if the options are NOT hidden</html>|-|LABEL|SPAN=TRUE",
			"modifier|"+modifier+"|Modifier",
			"target|"+target+"|Target",
			"explode|"+explode+"|Explode|CHECK",
			"showGMOption|All, GM Only, You and GM|Show result to?|RADIO|Select="+showGMOption,
			"eachRollOption|Totals, Each die|Tooltip info|RADIO|Select="+eachRollOption
		))]
		<!-- convert options to values for form -->
		[showGMOption	= listGet("all,gm, gm-self", showGMOption)]
		[eachRollOption	= if(eachRollOption, "eachRoll", "totalRoll")]
		
		[allDice = "4,5,6,8,10,12,20,100"]
		[dieList = ""]
		[foreach(dice, allDice):dieList = if(eval("Di"+dice),listAppend(dieList, dice), dieList)]

		[optionsList	= StrPropFromVars("showMod,showTarget,showExplode,showResults,showTooltip,modifier,target,explode,showGMOption,eachRollOption","UNSUFFIXED")]

		['pause("frameNum", "dieList", "optionsList")']
		[setLibProperty("dieList"+frameNum, dieList, "Lib:EventMacros")]
		[setLibProperty("optionsList"+frameNum, optionsList, "Lib:EventMacros")]
		[macro("NDB@this"): dbArgs]
	}; 
	case "Roll":{
		[macro("RollDice@this"):dbArgs] 
		[abort(0)]
	}; 
	default:{ 
		<!-- Retrieve die number: dice names look like follows: <html>-<!-- 4 --> -->
		['assert(startsWith(clickedButton, "<html>"), ""Error in die roller for value clickedButton: "+clickedButton",0)']
		[sign	= getGroup(strfind(clickedButton, "(?<=html\>)[-+]"), 1, 0))]
		[dice	= getGroup(strfind(clickedButton, "(?<=--\\s)[0-9]+"), 1, 0))]  
		<!-- dbArgs = json.set(dbArgs, "d4s", max(0,json.get(dbArgs, "d4s")-1)) -->
		[dbArgs	= eval(strformat("json.set(dbArgs, 'd%{dice}s', max(0,json.get(dbArgs, 'd%{dice}s')%{sign}1))"))]
		[macro("NDB@this"):dbArgs]
	}
]

@@RollDice
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=default ; playerEditable=true ; applyToSelected=false ; group=Rumbles Dicebox ; tooltip= ; minWidth=90 ; 
[h:'<!-- --------------------- RollDice ----------------------------->']
[h:dbArgs		= macro.args]
[h:numD4	= json.get(dbArgs, "d4s")]
[h:numD5	= json.get(dbArgs, "d5s")]
[h:numD6	= json.get(dbArgs, "d6s")]
[h:numD8	= json.get(dbArgs, "d8s")]
[h:numD10	= json.get(dbArgs, "d10s")]
[h:numD12	= json.get(dbArgs, "d12s")]
[h:numD20	= json.get(dbArgs, "d20s")]
[h:numD100	= json.get(dbArgs, "d100s")]
[h:mod		= json.get(dbArgs, "mod")]
[h:breakout	= json.get(dbArgs, "breakdown")]
[h:target	= json.get(dbArgs, "tn")]
[h:showTo	= json.get(dbArgs, "showTo")]
[h,if(json.contains(dbArgs, "explodeDice")): exp = if(json.get(dbArgs, "explodeDice") !=0 ,"e",""); exp=""]

[h:d4array	= ""]	[h:d4roll	= 0]
[h:d5array	= ""]	[h:d5roll	= 0]
[h:d6array	= ""]	[h:d6roll	= 0]
[h:d8array	= ""]	[h:d8roll	= 0]
[h:d10array	= ""]	[h:d10roll	= 0]
[h:d12array	= ""]	[h:d12roll	= 0]
[h:d20array	= ""]	[h:d20roll	= 0]
[h:d100array= ""]	[h:d100roll	= 0]

[h,if(breakout=="eachRoll"),CODE:{
	[h,count(numD4), CODE: {
		[thisD4 	= eval("1d4"+exp)]
		[d4roll 	= d4roll + thisD4]
		[d4array	= listAppend(d4array, thisD4)]
	}]
	[h,count(numD5), CODE: {
		[thisD5 	= eval("1d5"+exp)]
		[d5roll 	= d5roll + thisD5]
		[d5array	= listAppend(d5array, thisD5)]
	}]
	[h,count(numD6),CODE:	{
		[thisD6 	= eval("1d6"+exp)]
		[d6roll 	= d6roll + thisD6]
		[d6array	= listAppend(d6array, thisD6)]
	}]
	[h,count(numD8),CODE:	{
		[thisD8 	= eval("1d8"+exp)]
		[d8roll 	= d8roll + thisD8]
		[d8array	= listAppend(d8array, thisD8)]
	}]
	[h,count(numD10),CODE:	{
		[thisD10 	= eval("1d10"+exp)]
		[d10roll 	= d10roll + thisD10]
		[d10array	= listAppend(d10array, thisD10)]
	}]
	[h,count(numD12),CODE:	{
		[thisD12 	= eval("1d12"+exp)]
		[d12roll 	= d12roll + thisD12]
		[d12array	= listAppend(d12array, thisD12)]
	}]
	[h,count(numD20),CODE:	{
		[thisD20 	= eval("1d20"+exp)]
		[d20roll 	= d20roll + thisD20]
		[d20array	= listAppend(d20array, thisD20)]
	}]
	[h,count(numD100),CODE:{
		[thisD100	= eval("1d100"+exp)]
		[d100roll	= d100roll + thisD100]
		[d100array	= listAppend(d100array,thisD100)]
	}]

	[h:rolledDice =
			if(d4roll !=0,		numD4+"d4"+exp+"+",		"")
		+	if(d5roll !=0,		numD5+"d5"+exp+"+",		"")
		+	if(d6roll !=0,		numD6+"d6"+exp+"+",		"")
		+	if(d8roll != 0,		numD8+"d8"+exp+"+",		"")
		+	if(d10roll !=0,		numD10+"d10"+exp+"+",	"")
		+	if(d12roll !=0,		numD12+"d12"+exp+"+",	"")
		+	if(d20roll != 0,	numD20+"d20"+exp+"+",	"")
		+	if(d100roll != 0,	numD100+"d100"+exp+"+",	"")
		+	if(mod != 0,		mod+"+",		"")
	]
	[h:assert(rolledDice != "","No dice selected",0)]
	<!-- remove the , -->
	[h:rolledDice = substring(rolledDice, 0,length(rolledDice)-1)]
	
	[h:Values = 
			if(d4roll == 0,		"",	d4roll+"("+d4array+")"+"+")
		+	if(d5roll == 0,		"",	d5roll+"("+d5array+")"+"+")
		+	if(d6roll == 0,		"",	d6roll+"("+d6array+")"+"+")
		+	if(d8roll == 0,		"",	d8roll+"("+d8array+")"+"+")
		+	if(d10roll == 0,	"",	d10roll+"("+d10array+")"+"+")
		+	if(d12roll == 0,	"",	d12roll+"("+d12array+")"+"+")
		+	if(d20roll == 0,	"",	d20roll+"("+d20array+")"+"+")
		+	if(d100roll == 0,	"",	d100roll+"("+d100array+")"+"+")
		+	if(mod == 0,		"",	mod+"+")
	]
	[h:Values = substring(Values, 0,length(Values)-1)]
}; {
	[h:d4roll	= if(numD4 == "0",	0,	eval(numD4+"d4"+exp))]
	[h:d5roll	= if(numD5 == "0",	0,	eval(numD5+"d5"+exp))]
	[h:d6roll	= if(numD6 == "0",	0,	eval(numD6+"d6"+exp))]
	[h:d8roll	= if(numD8 == "0",	0,	eval(numD8+"d8"+exp))]
	[h:d10roll	= if(numD10 == "0",	0,	eval(numD10+"d10"+exp))]
	[h:d12roll	= if(numD12 == "0",	0,	eval(numD12+"d12"+exp))]
	[h:d20roll	= if(numD20 == "0",	0,	eval(numD20+"d20"+exp))]
	[h:d100roll	= if(numD100 == "0",0,	eval(numD100+"d100"+exp))]
	[h:mod		= number(mod)]

	[h:rolledDice =
			if(d4roll !=0,		numD4+"d4"+exp+"+",		"")
		+	if(d5roll !=0,		numD5+"d5"+exp+"+",		"")
		+	if(d6roll !=0,		numD6+"d6"+exp+"+",		"")
		+	if(d8roll != 0,		numD8+"d8"+exp+"+",		"")
		+	if(d10roll !=0,		numD10+"d10"+exp+"+",	"")
		+	if(d12roll !=0,		numD12+"d12"+exp+"+",	"")
		+	if(d20roll != 0,	numD20+"d20"+exp+"+",	"")
		+	if(d100roll != 0,	numD100+"d100"+exp+"+",	"")
		+	if(mod != 0,		mod+"+",		"")
	]
	[h:assert(rolledDice != "","No dice selected",0)]
	<!-- remove the , -->
	[h:rolledDice = substring(rolledDice, 0,length(rolledDice)-1)]

	[h:Values = 
			if(d4roll == 0,		"", d4roll+"+")
		+	if(d5roll == 0,		"", d5roll+"+")
		+	if(d6roll == 0,		"", d6roll+"+")
		+	if(d8roll == 0,		"", d8roll+"+")
		+	if(d10roll == 0,	"", d10roll+"+")
		+	if(d12roll == 0,	"", d12roll+"+")
		+	if(d20roll == 0,	"", d20roll+"+")
		+	if(d100roll == 0,	"", d100roll+"+")
		+	if(mod == 0,		"",	mod+"+")
	]
	[h:Values = substring(Values, 0,length(Values)-1)]
}]

[h:roll = d4roll+d6roll+d5roll+d8roll+d10roll+d12roll+d20roll+d100roll+mod]
[h,if(target > 0 && roll > target): success = "Success!"; success="Failed!"]

<!-- showto = gm, all, gmyou -->
[r:dbxOutputTo(showTo,	"<span><i>Rolling "+rolledDice+"</i>:<b> <span title='"+Values+"'>"+roll+"</b></span> "+if(target > 0, success, "")+"</span>")]

@@dbxConditionalOutput
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=default ; playerEditable=true ; applyToSelected=false ; group=Rumbles Dicebox ; tooltip= ; minWidth=193 ; 
[r: json.get(macro.args, 'toSend')]

@@dbxOutputTo
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=default ; playerEditable=true ; applyToSelected=false ; group=Rumbles Dicebox ; tooltip= ; minWidth=90 ; 
[h: toSend = '{}']
[h: argTest = json.type(arg(0))]
[h, if(argTest=='ARRAY'), code:
{
    [h: toWho = 'list']
    [h: toSend = json.set(toSend, 'mlOutputList', arg(0))]
}; {
    [h: toWho = arg(0)]
}]

[h: toSend = json.set(toSend, 'toSend', arg(1))]
[h: conditionalOutput = macroLinkText('dbxConditionalOutput@this', toWho, toSend)]
[h: execLink(conditionalOutput, 1)]

@@MassVBL
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=3 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Vision Blocking Layer ; tooltip=<html>This function draws VBL crosses on all tokens that match a search string ; minWidth=90 ; 
[h:'<!-- --------------------------------------------- MassVBL -------------------------------------------------- -->']
<!-- <html>This function draws VBL crosses on all tokens that match a search string -->

[h:optionList	= "Canopy, Roof, Selection, All, Search String"]
[h:scaleList	= "Number of Cells, Token Size"]
[h:gridSize 	= bot_getGridSize()] 
[h:currentMap	= getCurrentMapName()]

<!-- initiate last settigns -->
[h:lastSettings	= getLibProperty("lastMassVBLSettings", "Lib:EventMacros")]
[h,if(lastSettings == ""): lastSettings = "option=0 ; searchStr=tree ; doTokenLayer=0 ; doObjectLayer=1 ; doHiddenLayer=0 ; doBackgroundLayer=1 ; scaleOption=0 ; scale=0.5 ; storeVBL=0 ; vblName=maptrees ; "]
[h:varsFromStrProp(lastSettings)]

[h:assert(getLibProperty('vblSupport','lib:EventMacros'),"This version of maptool does NOT support VBL manipulation",0)]
[H:inputstr		= ""]
[h:inputStr		= json.append(inputStr, "junk|<html><b>Set VBL Stamp</b></html>|<html>With this menu you can setup a VBL stamp for the token that you selected.<br>This stamp will be activated immediately and will move along with the <br>token when you move it. For this to work you will need to turn on VBL support<br>in the settings.<br>|LABEL|SPAN=TRUE")]
[h:inputStr 	= json.append(inputStr, 'option|'+optionList+'|<html><span title="<html>Tokens to which the VBL layer will be applied.<br><b>Canopy</b> will select all tokens with <i>Canopy</i> in their name, same for<br><b>Roof</b> and <b>Search string</b>. with the latter you need to enter a search<br>string in the text box here below.<br><b>All</b> will select ALL tokens<br><b>Selection</b> will limit to the currently selected tokens.<br><br>Note that the LAYER filter is applied to all except <b>Selection</b>. <br></html>">Add VBL to which tokens</html></span></html>|RADIO|SELECT='+option)]
[h:inputStr 	= json.append(inputStr, 'searchStr|'+searchStr+'|<html><span title="<html>If you choose <i>other</i> from the radion buttons, enter the search string here.<br>Note that ANY token whos name partialy matches this search string will be added<br>to the VBL list. E.g. <i>can</i> will return token named <i>cans</i>, <i>canopy</i>, <i>cantine</i>, etc.<br>One way to limit the results is by adding a whitespace at the start or end of the <br>name if appropriate. E.g. &quot;can &quot; will NOT return the above examples.</html>">Search string</html></span></html>')]
[h:inputStr		= json.append(inputStr, "junk|<html><b>Check layers to include</html>|<html>The VBL will only be applied to tokens that are on the layers you check here.|LABEL|SPAN=TRUE")]
[h:inputStr		= json.append(inputStr, 'doTokenLayer|'+doTokenLayer+'|<html><span>Token Layer|CHECK')]
[h:inputStr		= json.append(inputStr, 'doHiddenLayer|'+doHiddenLayer+'|<html><span>Hidden Layer|CHECK')]
[h:inputStr		= json.append(inputStr, 'doObjectLayer|'+doObjectLayer+'|<html><span>Object Layer|CHECK')]
[h:inputStr		= json.append(inputStr, 'doBackgroundLayer|'+doBackgroundLayer+'|<html><span>Background Layer|CHECK')]
[h:inputStr		= json.append(inputStr, "junk|<html><b>Scale</b></html>|<html>|LABEL|SPAN=TRUE")]
[h:inputStr 	= json.append(inputStr, 'scaleOption|'+scaleList+'|<html><span title="<html><b>Number of Cells:</b> 0.5 is half a (grid) cell, 1 is 1 cell, 2 is 4 cells, etc.<br><b>Token size:</b> 0.5 means half the size of the token, 2 means twice the size of the token.</html>">Scaling in terms of</html></span></html>|RADIO|SELECT='+scaleOption)]
[h:inputStr 	= json.append(inputStr, 'scale|'+scale+'|<html><span title="<html>Depends on the radio choice</html>">Scale of VBL shape</html></span></html>')]
[h:inputStr		= json.append(inputStr, "junk|<html><b>Saving the VBL</b></html>|<html>Checking the box will save the VBL as a result of this macro|LABEL|SPAN=TRUE")]
[h:inputStr 	= json.append(inputStr, 'storeVBL|'+storeVBL+'|<html><span title="<html>When you check this the VBL will be stored on a lib:token<br>This will allow you to toggle the VBL on or off</html>">Store the VBL</html></span></html>|CHECK')]
[h:inputStr 	= json.append(inputStr, 'vblName|'+vblName+'|<html><span title="<html>This will only work if you have checked the <i>Store the VBL</i> checkbox.<br>The VBL data will be linked to this map and the name you enter allowing you<br>to toggle this specific VBL on or off. Only use alphanumeric characters for<br>the name</html>">Name of VBL to store</html></span></html>')]

<!-- run the input -->
[H: abort(input(json.toList(inputStr,"##")))]

<!-- assertion -->
[h:assert(doTokenLayer+doObjectLayer+doHiddenLayer+doBackgroundLayer, "Check at least one of the (Token, Hidden, Object, Background) layer boxes",0)]

<!-- save settigns -->
[h:setLibProperty("lastMassVBLSettings", strPropFromVars("option, searchStr, doTokenLayer, doObjectLayer, doHiddenLayer, doBackgroundLayer, scaleOption, scale, storeVBL, vblName","UNSUFFIXED"), "lib:EventMacros")]

[h:'<!-- {layer:["TOKEN", "HIDDEN", "OBJECT", "BACKGROUND"]} -->']
[h:chosenLayers = "[]"]
[h,if(doTokenLayer):		chosenLayers = json.append(chosenLayers, "TOKEN")]
[h,if(doObjectLayer):		chosenLayers = json.append(chosenLayers, "OBJECT")]
[h,if(doHiddenLayer):		chosenLayers = json.append(chosenLayers, "HIDDEN")]
[h,if(doBackgroundLayer):	chosenLayers = json.append(chosenLayers, "BACKGROUND")]

[h, if(option == 0): searchStr	= "Canopy "]
[h, if(option == 1): searchStr	= "Roof "]
<!-- selection -->
[h, if(option == 2): allToks	= getSelectedNames()]
[h, if(option == 3): allToks	= getTokenNames(",", json.set("{}", "layer", chosenLayers))]
<!-- ALL -->
[h, if(option < 2 || option == 4):	allToks = bot_seekToken(1, searchStr, chosenLayers)]

[h:shape		= "cross"]
[h:jsonVBL		= "[]"]

['pause("allToks")']
<!-- Top left Centre Coords of the trunk. This is done by: offset of position of entire token + centre of token - half gridsize (so you get the top left corner of the centre) -->
[h, if(scaleOption), CODE:{
	<!-- scale in terms of token size, e.g. 1 is size of token -->

	[foreach(tok, allToks): 
		jsonVBL	= json.append(
			jsonVBL, 
			strformat(
				'{"shape":"cross","w":%s,"h":%s,"x":%s,"y":%s,"scale":%{scale}}', 
				getTokenWidth(tok),
				getTokenHeight(tok),
				getTokenX(2, tok), 
				getTokenY(2, tok)
			)
		)
	]
};{
	<!-- scale in terms of grid cells e.g. 1 is one cell large VBL -->
	[w			= gridSize * scale]
	[h			= w]
	[half		= round(w/2)]
	
	[foreach(tok, allToks): 
		jsonVBL	= json.append(
			jsonVBL, 
			strformat(
				'{"w":%{w},"shape":"cross","h":%{h},"x":%s,"y":%s}', 
				getTokenX(2, tok) + round(getTokenWidth(tok)/2) - half, 
				getTokenY(2, tok) + round(getTokenHeight(tok)/2) - half
			)
		)
	]
}]

<!-- remove '' from strformat result, which will turn it into a json object -->
[h:jsonVBL	= replace(jsonVBL, "'", "")]

<!-- draw all the vbl -->
[h:drawVBL(jsonVBL)]

<!-- save VBL -->
[h,if(storeVBL), CODE:{
	<!-- get currently stored VBL -->
	[storedVBL		= getLibProperty("storedVBL", "lib:EventMacros")]
	[if(json.type(storedVBL)=="UNKNOWN"):		storedVBL		= "{}"]
	[thisMapVBL		= json.get(storedVBL, currentMap)]
	[if(json.type(thisMapVBL)=="UNKNOWN"):		thisMapVBL		= "{}"]
	[thisMapVBLOn	= json.get(storedVBL, currentMap+"_ON")]
	[if(json.type(thisMapVBLOn)=="UNKNOWN"):	thisMapVBLOn	= "{}"]
	
	<!-- add this VBL -->
	[thisMapVBL		= json.set(thisMapVBL, vblName, jsonVBL)]
	[thisMapVBLOn	= json.set(thisMapVBLOn, vblName, 1)]
	[storedVBL		= json.set(storedVBL, currentMap, thisMapVBL, currentMap+"_ON", thisMapVBLOn)]
	[setLibProperty("storedVBL", storedVBL, "lib:EventMacros")]
};{}]

<!-- output to chat -->
[h:broadcast("VBL has been added to the following tokens: "+ allToks)]

@@VBLGrenade
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=3 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Vision Blocking Layer ; tooltip=Select one or more tokens, run macro, set radius (in grid cells) and ALL VBL in that radius around the selected tokens will be cleared. ; minWidth=90 ; 
[h:'<!-- --------------------------------------------- VBLGrenade (tokOnly (1/0), clearVBL(1/0), tok): returns the VBL -------------------------------------------------- -->']
<!--	Select one or more tokens, run macro, set radius (in grid cells) and ALL VBL in that radius around the selected tokens will be cleared. 
		tokOnly (default 0) allows to automatically clear the VBL over the selected token
		clearVBL (default 1) will erase the VBL automatically
-->
[h:assert(getLibProperty('vblSupport','lib:EventMacros'),"This version of maptool does NOT support VBL manipulation",0)]

[h,if(argCount()>0): tokOnly	= arg(0) ; tokOnly	= 0]
[h,if(argCount()>1): clearVBL	= arg(1) ; clearVBL	= 1]
[h,if(argCount()>2): allToks	= arg(2) ; allToks	= getSelected()]

[h,if(tokOnly), CODE:{
	<!-- do not ask input just take the token area for the VBL operation -->
	[radius		= 0]
	[sides		= 0]
};{
	[assert(listCount(allToks),"You need to select at least one token for this to work",0)]
	[abort(input(
		"junk|<html><b>Clear VBL around selected tokens</b></html>|<html>The radius (in grid cells) you choose will be used to clear the VBL directly around the token |LABEL|SPAN=TRUE",
		"radius|1|Radius of VBL to clear around the token (Cells)",
		"junk|<html><b>Sides of VBL clearance circle</b></html>|<html>A regular polygon will be used as 'circle' here you set how many sides the 'circle' should have|LABEL|SPAN=TRUE",
		"sides|3,4,5,6,7,8,9,10,11,12|Radius of VBL to clear around the token|LIST|Select=5 value=string",
		"tokOnly|0|Override the above and only clear VBL covered by token|CHECK"
	))]
}]
<!-- initialize vars -->
[h:w		= 0]
[h:h		= 0]
[h:facing	= 0]
[h:shape	= if(tokOnly, "rectangle", "circle")]
[h:radius	= bot_getGridSize() * radius]

<!-- create json structure of VBL objects to erase -->
[h:jsonVBL		= "[]"]
[h,foreach(tok, allToks), CODE: {
	[if(tokOnly), CODE:{
		[x		= getTokenX(2,tok)]
		[y		= getTokenY(2,tok)]
		[w		= getTokenWidth(tok)]
		[h		= getTokenHeight(tok)]
		[facing	= getTokenFacing(tok)]
		[if(facing == ""): facing = -90]
	};{
		[x		= getTokenX(2, tok) + round(getTokenWidth(tok)/2)]
		[y		= getTokenY(2, tok) + round(getTokenHeight(tok)/2)]
	}]

	[jsonVBL	= json.append(jsonVBL, strformat('{"shape":"%{shape}","fill":1,"radius":%{radius},"sides":%{sides}, "facing":%{facing},"x":%{x},"y":%{y},"w":%{w},"h":%{h}}'))]
}]

<!-- draw all the vbl -->
[h:macro.return	= getVBL(jsonVBL)]
[h,if(clearVBL):eraseVBL(jsonVBL)]

@@createVBL
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=6 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Vision Blocking Layer ; tooltip= ; minWidth=90 ; 
[h: '<!-- --------------------------------------- createVBL ([tok,check,isDoor]) ---------------------------------------------->']
[debug		= 0]

<!-- ignore output SAME SCOPE -->
<!-- this macro defines the types coords etc of a VBL object based on the stored info on the token -->
<!-- it erases the old VBL and defines the new one -->
[if(argCount() > 0): me		= arg(0) ; me		= currentToken()]
<!-- check if the area to be drawn contains VBL already -->
[if(argCount() > 1): check	= arg(1) ; check	= 0]
<!-- do NOT scale the VBL beyon the token in case of a door, cause this will mess up double doors!! -->
[if(argCount() > 2): isDoor	= arg(2) ; isDoor	= 0]

<!-- define the following vars: applyVBL,VBLType,scaleX,scaleY,offsetX,offsetY,thickness,scale, fill, close, sides, centreOffset, resetFoW, rxOffset, ryOffset -->
[varsFromStrProp(getProperty("w42.bot.vblSetup", me))]

<!-- apply VBL on token and save it -->
[typeList	= "cross, rectangle, circle, polygon, polygon, polygon"]
[shape		= listGet(typeList, VBLType)]
[thickness	= max(1, thickness)]
[points		= "[]"]
[w			= getTokenWidth(me)]
[h			= getTokenHeight(me)]
[d			= max(w,h)]
[x			= getTokenX(2, me)]
[y			= getTokenY(2, me)]
[facing		= getTokenFacing(me)]

[radius		= 0]
[vblVars	= "shape, VBLType, x, y, w, h, radius, points, scale, thickness, sides, fill, close, offsetX, offsetY, resetFoW, rxOffset, ryOffset"]

<!-- centre offset 1: align centre shape with centre token ; 0. align top left shape with top left token -->
[switch(VBLType), CODE:
	case 0: {
		<!-- CROSS default aligns centre with centre of the token -->
		[if(!centreOffset), CODE:{
			[offsetX	= offsetX + ceil((scale-1)*w/2)]
			[offsetY	= offsetY + ceil((scale-1)*w/2)]
		}]
	};
	case 1: {
		<!-- RECTANGLE default aligns top left with top left of the token -->
		[if(centreOffset), CODE:{
			[offsetX	= offsetX - ceil((scale-1)*w/2)]
			[offsetY	= offsetY - ceil((scale-1)*h/2)]
		}]
	};
	case 2: {
		<!-- CIRCLE per default aligns centre with top left token -->
		[if(centreOffset), CODE:{
			[offsetX	= offsetX + round(w/2) +1]
			[offsetY	= offsetY + round(h/2) +1]
		};{}]

		<!-- calculate radius of circle -->
		[radius		= floor(min(w,h)/2)]
	};
	case 3: {
		<!-- HORIZONTAL LINE -->
		[if(centreOffset): offsetX= offsetX - ceil((scale-1)*w/2)]
		
		[x1			= x + offsetX]
		[x2			= x1 + round(scale*w)]
		[y1			= y + round(h/2)]
		
		[points		= strformat("[{'x':%{x1},'y':%{y1}},{'x':%{x2},'y':%{y1}}]")]
	};
	case 4: {
		<!-- VERTICAL LINE -->
		[if(centreOffset): offsetY= offsetY - ceil((scale-1)*h/2)]
		
		[y1			= y + offsetY]
		[x1			= x + round(w/2)]
		[y2			= y1 + round(scale*h)]

		[points		= strformat("[{'x':%{x1},'y':%{y1}},{'x':%{x1},'y':%{y2}}]")]
	};
	case 5: {
		<!-- CURRENT VBL (shape 5)-->
		<!-- Simply grab the VBL that covers the token. Using the same parameters.-->
		[x			= x + offsetX]
		[y			= y + offsetY]

		[rectVBL	= json.set("{ }", "shape", "rectangle", "x", x, "y", y, "w", w, "h", h, "fill", 1, "scale", scale)] 
		[bot_saveFgVBL(me, rectVBL)]
		<!-- also save the bgVBL else youll get an error message the first time you move the token -->
		[bot_saveBgVBL(me,rectVBL)]
	};
	default: {
		[assert(0,"it appears you try to create an unknown shape: "+VBLType, 0)]
	}
]

<!-- set and store the parameters for the bgVBL shape -->
<!-- increase the scale of the BG save to take the thickness of the line and the offset of the shape into account -->
[if(isDoor): vblBgScale = 1 ; vblBgScale = 1.5 * max(1,scale) * ( 1 + thickness/20 + max(abs(offsetX), abs(offsetY))/d )]
[setProperty("w42.bot.vblBgScale", vblBgScale, me)]
<!-- centreOffset makes sure that the bgVBL rectangle remains centred on the token when its fgshape is scaled -->
[if(isDoor): vblBgOffsetX = 0 ; vblBgOffsetX	= ceil((max(vblBgScale,1)-1)*if(h>w && !isDoor, h*h/w, w)/2)]
[if(isDoor): vblBgOffsetY = 0 ; vblBgOffsetY	= ceil((max(vblBgScale,1)-1)*if(w>h && !isDoor, w*w/h, h)/2)]

[setProperty("w42.bot.vblBgOffsetX", vblBgOffsetX, me)]
[setProperty("w42.bot.vblBgOffsetY", vblBgOffsetY, me)]

[if(VBLType != 5), CODE:{
	<!-- handle offsets and bgVBL for shapes 0 to 4 -->

	<!-- Get the VBL currently under Token to erase UNROTATED!!-->
	<!-- create the rectVBL to save the Bg VBL -->
	<!-- offsetX and Y have already been added earlier, so they need to be remove here! -->
	[rectVBL	= json.set("{ }", "shape", "rectangle", "x", x-vblBgOffsetX, "y", y-vblBgOffsetY, "w", d, "h", d, "fill", 1, "scale", vblBgScale)]
	
	<!-- build the json structure for the shape -->
	<!-- add the shape offset to the coords to get the x,y of the shape -->
	[x			= x + offsetX]
	[y			= y + offsetY]

	[VBLData	= json.fromStrProp(strPropFromVars(vblVars, "UNSUFFIXED"))]
	[jsonVBL	= json.append("", VBLData)]
	
	<!-- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), getMacroName(), getMacroLocation()) -->
	[h,if(debug == 1), CODE:{
		[bot_debugInfo("me, vblVars, VBLData, jsonVBL, rectVBL, vblBgScale, vblBgOffsetX, vblBgOffsetY, offsetX, offsetY, d",0,1,0, getMacroName(), getMacroLocation())]
	};{}]

	[if(check), CODE:{
	<!-- cannot get this to work properly for doors so skip for now -->
		[rx				= round(w/2)]
		[ry				= round(h/2)] 
		[VBLDataC		= json.set(VBLData,"rx", rx, "ry", ry,"tx", x, "ty", y)]
		[jsonVBLC		= json.append("", VBLDataC)]
		[checkVBL		= json.get(json.get(getVBL(jsonVBLC,0),0),"points")]
		[macro.return	= if(!json.isEmpty(checkVBL), jsonVBLC, "{}")]
	};{
		<!-- the VBL stamp is created -->
		<!-- save background -->
		[bot_saveBgVBL(me,rectVBL)]
		<!-- clear all VBL at token -->
		[eraseVBL(rectVBL)]
		<!-- draw fg vbl at token NO FACING -->
		[drawVBL(jsonVBL)]
		<!-- save it -->
		[bot_saveFgVBL(me, rectVBL)]
		<!-- redraw the background vbl..if any. -->
		[bot_drawBgVBL(me)]	
		<!-- drawBG erases the rect. so the fg needs to be redrawn! WITH FACING-->
		[bot_drawFgVBL(me)]
	}]
};{}]

@@drawBgVBL
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=8 ; color=red ; playerEditable=false ; applyToSelected=false ; group=Vision Blocking Layer ; tooltip= ; minWidth=90 ; 
[h: '<!-- --------------------------------------- drawBgVBL ([tok]) ---------------------------------------------->']
[debug		= 0]

<!--	if the token has moved, then you wish to restore the VBL on the old spot, this you do by retrieving the old rect vbl 
		erase the area below and then redraw the stored bginfo
-->

[if(argCount() > 0): me		= arg(0) ; me		= currentToken()]
[switchToken(me)]

[vblData	= getProperty("w42.bot.bgVBL", me)]
[rectVBL	= getProperty("w42.bot.rectVBL")]
[eraseVBL(rectVBL)]
[points		= json.get(json.get(vblData, 0),"points")]
[if(!json.isEmpty(points)):drawVBL(vblData)]

<!-- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), getMacroName(), getMacroLocation()) -->
[if(debug == 1): bot_debugInfo("me, VBLData, rectVBL, points",0,1,0, getMacroName(), getMacroLocation())]

@@drawFgVBL
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=8 ; color=red ; playerEditable=false ; applyToSelected=false ; group=Vision Blocking Layer ; tooltip= ; minWidth=90 ; 
[h: '<!-- --------------------------------------- drawFgVBL ([toks, drawBg]) ---------------------------------------------->']
[h:debug			= 0]

[h,if(argCount() > 0): toks		= arg(0) ; toks		= getSelectedNames()]
[h:assert(listCount(toks), "Make sure you have at least one token selected",0)]

[h,if(argCount() > 1): drawBg	= arg(1) ; drawBg	= 1]

<!-- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), getMacroName(), getMacroLocation()) -->
[h,if(debug == 1): bot_debugInfo("toks",0,1,0, getMacroName(), getMacroLocation())]

[h:w42.bot.final	= '[ ]']
[h,foreach(me,toks), CODE:{
	[switchToken(me)]
	<!-- Get token location, size, etc -->
	[x		= getTokenX()]
	[y		= getTokenY()]
	[w		= getTokenWidth()]
	[h		= getTokenHeight()]
	[facing	= getTokenFacing()]
	[if(facing == ""): facing = -90]

	[if(drawBg), CODE:{
		<!-- restore old bg vbl on original spot -->
		[bot_drawBgVBL(me)]
		<!-- save bgvbl on new spot -->
		[bot_saveBgVBL(me)]
	};{}]

	<!-- get the fgvbl -->
	[fgVBL	= getProperty("w42.bot.fgVBL")]

	<!-- 
	deduct the translation from the rotational offset first
	The reason for this is that drawVBL FIRST rotates the VBL using the rotational offset and THEN translates it. Thus it rotates the VBL while on the wrong spot. So the rotational offset needs to be done WITHOUT the translation
	-->
	[rx				= getTokenX()+round(getTokenWidth()/2) - x]
	[ry				= getTokenY()+round(getTokenHeight()/2) - y] 

	<!-- fgVBL is already in proper JSON format for "points" so we can use tx,ty to transpose to new coords -->
	[w42.bot.shape = json.set("{ }", "shape", "polygon", "fill", 1, "close", 1, "thickness", 0, "tx", x, "ty", y, "rx", rx, "ry", ry, "facing", facing, "points", fgVBL)]
	[w42.bot.final = json.append(w42.bot.final, w42.bot.shape)]

	<!-- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), getMacroName(), getMacroLocation()) -->
	[h,if(debug == 1): bot_debugInfo("me, fgVBL, w42.bot.final",0,1,0, getMacroName(), getMacroLocation())]
}]

[h,if(!json.isEmpty(w42.bot.final)): drawVBL(w42.bot.final)]

@@extendPoint
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=7 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Vision Blocking Layer ; tooltip=<html>This function applies a VBL (Vision Blocking Layer) upon a token. The VBL will move with the token as you move it. ; minWidth=90 ; 
[h: '<!-- --------------------------------------- extendPoint (coordinate, endPolygon) ---------------------------------------------->']
<!-- IGNORE OUTPUT, NO NEW SCOPE -->

[coordinate	= arg(0)]
[endPolygon	= arg(1)]

[xFP		= json.get(coordinate, "x")]
[yFP		= json.get(coordinate, "y")]
[x0			= xFP]
[y0			= yFP]

[if(xFP == x1 && (yFP == y1 || yFP == y2) || xFP == x2 && (yFP == y1 || yFP == y2)), CODE:{
	<!-- if x/y are in the corner then the extension depends on the direction it takes, which is decided by the Second point-->
	[offset			= if(endPolygon, json.length(newPoints)-2, 1)]
	[secondCoord	= json.get(newPoints, offset)]
	[xSP			= json.get(secondCoord, "x")]
	[ySP			= json.get(secondCoord, "y")]
	[yDirection		= if(xFP == xSP, 1,0)]
	[xDirection		= if(yFP == ySP, 1,0)]
['pause("xFP","yFP","xSP","ySP","offset","newPoints","coordinate","secondCoord","x1","x2","y1","y2","xDirection","yDirection")']
	
	[if(xDirection && !yDirection), CODE:{
		[if(xFP == x1):	x0	= x1 - extendPx]
		[if(xFP == x2):	x0	= x2 + extendPx]
		[y0	= yFP]
	};{ <!-- if its a diagonal then do not extend --> }]
	[if(yDirection && !xDirection), CODE:{
		[if(yFP == y1):	y0	= y1 - extendPx]
		[if(yFP == y2):	y0	= y2 + extendPx]
		[x0	= xFP]
	};{ <!-- if its a diagonal then do not extend --> }]
};{
	<!-- if x/y are at the edge but NOT in the corder, simply expand -->
	[if(xFP == x1), CODE:{
		[x0	= x1 - extendPx]
		[y0	= yFP]
	};{}]
	[if(xFP == x2), CODE:{
		[x0	= x2 + extendPx]
		[y0	= yFP]
	};{}]
	[if(yFP == y1), CODE:{
		[x0	= xFP]
		[y0	= y1 - extendPx]
	};{}]
	[if(yFP == y2), CODE:{
		[x0	= xFP]
		[y0	= y2 + extendPx]
	};{}]
}]
['pause("xFP","yFP","x1","x2","y1","y2","x0","y0")']

[macro.return	= json.set("{}","x", x0, "y", y0)]

@@moveStamp
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=7 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Vision Blocking Layer ; tooltip= ; minWidth=90 ; 
[h:'<!-- ----------------------------------- moveStamp(token) ------------------------------------------------->']

[if(getLibProperty('vblSupport','lib:EventMacros')), CODE:{
	[if(argCount()>0): me	= arg(0) ; me = getSelected()]
	<!-- draw bg where the tokens was -->
	[bot_drawBgVBL(me)]	
	<!-- save background where token is -->
	[bot_saveBgVBL(me)]
	<!-- draw fg vbl at token -->
	[bot_drawFgVBL(me)]

	[toks	= getTokens(",", '{ pc:1 }')]
	[if(toks != ""):selectTokens(toks,1,",")]
	[exposeFOW()]
	[selectTokens(me)]
};{}]

@@removeVBL
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=6 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Vision Blocking Layer ; tooltip=this macro removes ALL VBL data from a token. So NOT the VBL itself ; minWidth=90 ; 
[h:'<!-- ----------------------------------------- removeVBL (token) -------------------------------------------- -->']
<!-- this macro removes ALL VBL data from a token -->
[me				= arg(0)]
<pre>
[if(hasProperty("w42.bot.vblSetup",me)): resetProperty("w42.bot.vblSetup", me)]
[if(hasProperty("w42.bot.rectVBL",me)): resetProperty("w42.bot.rectVBL", me)]
[if(hasProperty("w42.bot.bgVBL",me)): resetProperty("w42.bot.bgVBL", me)]
[if(hasProperty("w42.bot.fgVBL",me)): resetProperty("w42.bot.fgVBL", me)]
[if(hasProperty("w42.bot.vblBgOffsetX",me)): resetProperty("w42.bot.vblBgOffsetX", me)]
[if(hasProperty("w42.bot.vblBgOffsetY",me)): resetProperty("w42.bot.vblBgOffsetY", me)]
[if(hasProperty("w42.bot.vblBgScale",me)): resetProperty("w42.bot.vblBgScale", me)]

@@saveBgVBL
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=8 ; color=red ; playerEditable=false ; applyToSelected=false ; group=Vision Blocking Layer ; tooltip= ; minWidth=90 ; 
[h: '<!-- --------------------------------------- saveBgVBL ([tok, rectVBL]) ---------------------------------------------->']
[debug	= 0]

[if(argCount() > 0): me		= arg(0) ; me		= currentToken()]
[switchToken(me)]

[x			= getTokenX()]
[y			= getTokenY()]
[d			= max(getTokenWidth(), getTokenHeight())]
[facing		= getTokenFacing()]
[if(facing == ""): facing = -90]

<!-- Get the VBL currently under Token, shape expanded 1 pixel in all directions to capture complete token w/h -->
[if(argCount() > 1), CODE: {
	[rectVBL	= arg(1)]
	[if(debug == 1): scale = 1]
};{
	<!-- scale -->
	[scale 			= getProperty("w42.bot.vblBgScale", me)]
	[vblBgOffsetX	= getProperty("w42.bot.vblBgOffsetX", me)]
	[vblBgOffsetY	= getProperty("w42.bot.vblBgOffsetY", me)]

	[rectVBL	= json.set("{ }", "shape", "rectangle", "x", x-vblBgOffsetX, "y", y-vblBgOffsetY, "w", d, "h", d, "fill", 1, "scale", scale)]
}]

[vblData	= getVBL(rectVBL)]

[setProperty("w42.bot.bgVBL", vblData)]
[setProperty("w42.bot.rectVBL", rectVBL)]

<!-- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), getMacroName(), getMacroLocation()) -->
[h,if(debug == 1): bot_debugInfo("me, vblData,rectVBL,scale",0,1,0, getMacroName(), getMacroLocation())]

@@saveFgVBL
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=8 ; color=red ; playerEditable=false ; applyToSelected=false ; group=Vision Blocking Layer ; tooltip= ; minWidth=90 ; 
[h: '<!-- --------------------------------------- saveFgVBL ([tok, rectVBL]) ---------------------------------------------->']
[h:debug		= 0]

[if(argCount() > 0): me		= arg(0) ; me		= currentToken()]
[switchToken(me)]

[x				= getTokenX()]
[y				= getTokenY()]
[w				= getTokenWidth()]
[h				= getTokenHeight()]
[facing	= getTokenFacing()]
[if(facing == ""): facing = -90]

<!-- Get the VBL currently under Token, shape expanded 1 pixel in all directions to capture complete token w/h -->
[if(argCount() > 1): 
	rectVBL		= arg(1) 
; 
	rectVBL		= json.set("{ }", "shape", "rectangle", "x", x, "y", y, "w", w, "h", h, "fill", 1, "facing", facing)
] 
[vblData		= getVBL(rectVBL, 1)]

[if(argCount() < 2):pause()]

[points='[ ]']
<!-- Loop through and subtract x,y from all Short to reset as if tile was at 0,0 for a common reference point -->
<!-- then add an offset string which later on can be used to be replaced by use of regex -->
[len			= json.length(vblData)]
[for(i, 0, len, 2), CODE :{
	[x2			= json.get(vblData, i)]
	[y2			= json.get(vblData, i+1)]
	[vblData	= json.set(vblData, i, x2 - x)]
	[vblData	= json.set(vblData, i+1, y2 - y)]
	
	[newPoints	= json.set("{ }", "x", x2 - x, "y", y2 - y)]
	[points		= json.append(points, newPoints) ]
}]

[h:setProperty("w42.bot.fgVBL", points)]

<!-- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), getMacroName(), getMacroLocation()) -->
[h,if(debug == 1): bot_debugInfo("me, x, y, vblData, points", 0, 1, 0, getMacroName(), getMacroLocation())]

@@setVBLStamp
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=5 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Vision Blocking Layer ; tooltip=<html>This function applies a VBL (Vision Blocking Layer) upon a token. The VBL will move with the token as you move it. ; minWidth=90 ; 
[h: '<!-- --------------------------------------- setVBLStamp ---------------------------------------------->']
<!-- <html>This function applies a VBL (Vision Blocking Layer) upon a token. The VBL will move with the token as you move it. -->
[h:assert(getLibProperty('vblSupport','lib:EventMacros'),"This version of maptool does NOT support VBL manipulation",0)]

[h:allToks		= getSelected()]
[h:assert(listCount(allToks), "Make sure that you have at least one token selected. On which you want to apply the VBL stamp",0)]
[h:typeList		= "Cross, Rectangle, Circle, Horizontal Line, Vertical Line, Current VBL"]
[h:sideList		= ""]
<!-- create sides list ranging from 3 to 12 -->
[h,count(10): sideList = listAppend(sideList, roll.count+3)]
[h:gs			= bot_getGridSize()]

<!-- get previous settings (if any) from FIRST selected token ELSE use default settings -->
[h:tok			= listGet(allToks, 0)]
[h:fgVBL		= getProperty("w42.bot.fgVBL", tok)]
[h:vblPresent	= if(json.type(fgVBL)=="ARRAY", 1, 0)]
[h:vblSetup		= if(vblPresent, getProperty("w42.bot.vblSetup", tok), "applyVBL=0;VBLType=0;scaleX=100;scaleY=100;offsetX=0;offsetY=0;thickness=1;fill=0;scale=1;close=0;sides=6;centreOffset=1;resetFoW=1;rxOffset=0;ryOffset=0")]
[h:varsFromStrProp(vblSetup)]
[h:sides		= sides - 3]

[H:inputstr		= ""]
[h:inputStr		= json.append(inputStr, 'junk|<html><b>Set VBL Stamp (This line contains a tooltip)</b><br><font color=red>Keep in mind that the VBL layer only moves with<br>the token when its on the TOKEN layer</font><br><br></html>|<html>With this menu you can setup a VBL stamp for the token that you selected.<br>This stamp will be activated immediately and will move along with the <br>token when you move it. <br><br>The chosen shape will be applies to ALL selected tokens. The <i>Current VBL</i><br>option will grab ALL VBL that covers the token and uses that as stamp. |LABEL|SPAN=TRUE')]
[h:inputStr 	= json.append(inputStr, 'applyVBL|'+applyVBL+'|<html><span title="<html>When you check this a VBL layer will be added to the token</html>">Apply a VBL Stamp to token</html></span></html>|CHECK')]
[h:inputStr 	= json.append(inputStr, 'VBLType|'+typeList+'|<html><span title="<html>Shape of the VBL layer that will be applied</html>">Shape of VBL</html></span></html>|RADIO|SELECT='+VBLType)]
[h:inputStr 	= json.append(inputStr, 'offsetX|'+offsetX+'|<html><span title="<html>X (left/right) Offset in pixels from top left corner</html>">X offset (in px)</html></span></html>')]
[h:inputStr 	= json.append(inputStr, 'offsetY|'+offsetY+'|<html><span title="<html>Y (top/down) Offset in pixels from top left corner</html>">Y offset (in px)</html></span></html>')]
[h:inputStr 	= json.append(inputStr, 'rxOffset|'+rxOffset+'|<html><span title="<html>RX (left/right) Rotational Offset in pixels from the centre of the token<br>When your change the facing of the token the VBL will rotate around<br>the centre of the token. RX is the offset of that rotational centre</html>">RX offset (in px)</html></span></html>')]
[h:inputStr 	= json.append(inputStr, 'ryOffset|'+ryOffset+'|<html><span title="<html>RY (left/right) Rotational Offset in pixels from the centre of the token<br>When your change the facing of the token the VBL will rotate around<br>the centre of the token. RY is the offset of that rotational centre</html>">RY offset (in px)</html></span></html>')]
[h:inputStr 	= json.append(inputStr, 'thickness|'+thickness+'|<html><span title="<html>Thickness of the VBL line in pixels</html>">Thickness of VBL Line</html></span></html>')]
[h:inputStr 	= json.append(inputStr, 'scale|'+scale+'|<html><span title="<html>Scale 1 is actual size, 0.5 is half, 2 is 2x as big, etc.</html>">Scale VBL shape</html></span></html>')]
[h:inputStr 	= json.append(inputStr, 'fill|'+fill+'|<html><span title="<html>Checked results in a solid (filled) shape, unchecked in a hollow shape</html>">Solid shape</html></span></html>|CHECK')]
[h:inputStr 	= json.append(inputStr, 'centreOffset|'+centreOffset+'|<html><span title="<html><b>UNCHECKED</b>: will align the TOP LEFT corner of the VBL to the TOP LEFT corner of the token<br>(in case of the circle this means that its centre will be aligned to the top left corner)<br><b>CHECKED</b>: will align the CENTRE of the VBL to the CENTRE of the token.</html>">Align with Centre of token</html></span></html>|CHECK')]
[h:inputStr		= json.append(inputStr, "junk|<html><b>Circle Only</b></html>|<html>Note that its not actually  a circle but a regular polygon.<br>Hence the option to set the number of sides|LABEL|SPAN=TRUE")]
[h:inputStr 	= json.append(inputStr, 'sides|'+sideList+'|<html><span title="<html>Note that its not actually  a circle but a regular polygon.<br>Hence the option to set the number of sides</html>">Number of sides</html></span></html>|LIST|VALUE=STRING SELECT='+sides)]
[h:inputStr		= json.append(inputStr, "junk|<html><b>General</b></html>|<html>-|LABEL|SPAN=TRUE")]
[h:inputStr 	= json.append(inputStr, 'resetFoW|'+resetFoW+'|<html><span title="<html>When you check this the Fog of War will be reset entirely and cleared<br>for the current line of sight of the player tokens everytime the VBL<br> token is moved. </html>">Reset FoW after moving token</html></span></html>|CHECK')]

<!-- run the input -->
[H: abort(input(json.toList(inputStr,"##")))]
[h: vblSetup = strPropFromVars("applyVBL,VBLType,scaleX,scaleY,offsetX,offsetY,thickness,scale, fill, close, sides, centreOffset, resetFoW, rxOffset, ryOffset","UNSUFFIXED")]

<!-- apply settings to ALL selected tokens -->
[h, foreach(me, allToks), CODE:{
	<!-- the setup variables get changed with in the foreach loop so they need to be reset with every loop -->
	[varsFromStrProp(vblSetup)]
	[if(applyVBL), CODE:{
		<!-- save settings on token-->
		[setProperty("w42.bot.vblSetup", vblSetup, me)]

		<!-- get the new VBL settigns and apply the new VBL cross to its current position -->
		[bot_createVBL(me)]
	};{
		<!-- erase any current vbl -->
		[bot_drawBgVBL(me)]
		[bot_removeVBL(me)]
	}]
}]

[if(resetFoW): exposePCOnlyArea()]

@@toggleMassVBL
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=3 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Vision Blocking Layer ; tooltip=<html>With this function you can toggle saved mass VBL structures (set with Mass VBL macro) on and off ; minWidth=90 ; 
[h:'<!-- --------------------------------------------- toggleMassVBL -------------------------------------------------- -->']
<!-- <html>With this function you can toggle saved mass VBL structures (set with Mass VBL macro) on and off -->

[h:assert(getLibProperty('vblSupport','lib:EventMacros'),"This version of maptool does NOT support VBL manipulation",0)]

[h:currentMap	= getCurrentMapName()]
[h:storedVBL	= getLibProperty("storedVBL", "lib:EventMacros")]
[h,if(json.type(storedVBL)=="UNKNOWN"): storedVBL = "{}"]
[h:thisMapVBL	= json.get(storedVBL, currentMap)]
[h:thisMapVBLOn	= json.get(storedVBL, currentMap+"_ON")]
[h,if(json.type(thisMapVBLOn)=="UNKNOWN"):	thisMapVBLOn	= "{}"]

[h:assert(json.type(thisMapVBL)!="UNKNOWN","This map contains no stored VBL", 0)]

[h:vblList		= json.fields(thisMapVBL)]

[H:inputstr		= ""]
[h:inputStr		= json.append(inputStr, "junk|<html><b>Toggle Mass VBL Layer</b></html>|<html>Here you can turn on or off the stored Mass VBL resulting from the Mass VBL macro.<br>|LABEL|SPAN=TRUE")]
[h, foreach(vblName, vblList): inputStr	= json.append(inputStr, vblName+'_ON|Deactivated, Activated, Delete from list|'+vblName+'|RADIO|ORIENT=H SELECT='+json.get(thisMapVBLOn, vblName))]

<!-- run the input -->
[H: abort(input(json.toList(inputStr,"##")))]

<!-- filter changes -->
[vblChangedList = ""]
[h, foreach(vblName, vblList), CODE:{
	[if(eval( vblName+'_ON') != json.get(thisMapVBLOn, vblName)): vblChangedList = listAppend(vblChangedList, vblName)]
}]

[h,foreach(vblName, vblChangedList), CODE:{
	<!-- draw all the vbl -->
	[jsonVBL		= json.get(thisMapVBL, vblName)]
	[if(eval(vblName+'_ON')): drawVBL(jsonVBL) ; eraseVBL(jsonVBL)]
	<!-- save changes -->
	[thisMapVBLOn	= json.set(thisMapVBLOn, vblName, eval(vblName+'_ON'))]
	[storedVBL		= json.set(storedVBL, currentMap+"_ON", thisMapVBLOn)]
}]

[setLibProperty("storedVBL", storedVBL, "lib:EventMacros")]

@@SelectAndCentre
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=35 ; color=default ; playerEditable=false ; applyToSelected=false ; group=5. Door Button ; tooltip= ; minWidth=90 ; 
[h:'<!----------------------------------------- SelectAndCentre ----------------------------------------->']
[h:me = arg(0)]
[h:switchToken(me)]
[h:assert(findToken(me) != "", Me+" cannot be found on the map",0)]
[h:'<!-- prevent loop! -->']
[h, if(getSelected() != me):selectTokens(me)]
[h:goto(me)]

@@SwitchFrame
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=default ; playerEditable=false ; applyToSelected=false ; group=5. Door Button ; tooltip=<html>This macro activates a frame. As long as that frame is open the following functions are active:<br>- Door Switches (user can click them to open doors) <br>- Event Buttons (user can click them to activate linked macro) <br>- Full screen mode (if turned on in the settings, frames are automatically turned into Dialogs) <br>- Group select tokens (user can select one token and the rest is auto-selected)<br></html> ; minWidth=90 ; 
[h:'<!-- ------------------ SwitchFrame ----------------------------------->']
<!-- <html>
This macro activates a frame. As long as that frame is open the following functions are active:<br>
- Door Switches (user can click them to open doors) <br>
- Event Buttons (user can click them to activate linked macro) <br>
- Full screen mode (if turned on in the settings, frames are automatically turned into Dialogs) <br>
- Group select tokens (user can select one token and the rest is auto-selected)<br>
-->

[h:me = getSelected()]

[frame("Door Buttons and Full Screen Checker", "width=70; height=4; temporary=1"): {
	<html>
		<head>
			<link rel='onChangeSelection' type='macro' href='[r: macroLinkText("buttonHandler@Lib:OnTokenMove", "none", me)]'>
		</head>
		<body>
			Please leave this frame open. While this frame is open the following functions are activated:<br>
			- Door Switches (user can click them to open doors) <br>
			- Event Buttons (user can click them to activate linked macro) <br>
			- Full screen mode (if turned on in the settings, frames are automatically turned into Dialogs) <br>
			- Group select tokens (user can select one token and the rest is auto-selected)<br>
			- Force token selection (token that gm selects on his client is also selected on a player client)<br>
		</body>
	</html>
}]

@@buttonHandler
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=default ; playerEditable=false ; applyToSelected=false ; group=5. Door Button ; tooltip= ; minWidth=90 ; 
[h:'<!-- ------------------ BUTTON && FULSCREEN HANDLER ----------------------------------->']

[h:'<!-- retrieve: doFullScreenMode, canSelectShadowTok -->']
[h:varsFromStrProp(getLibProperty("toggles", "lib:EventMacros"))]

[h: tokenId	= getSelectedNames()]

<!-- check full screen mode. This can't be done in b87 so the json will return "".  -->
[h:IFS		= json.get(getInfo("client"),"isFullScreen")]
[h,if(isNumber(IFS) && doFullScreenMode),CODE:{
	[if(IFS != getLibProperty("fullScreenMode", "Lib:EventMacros")): bot_toggleFullScreen()]
};{}]

<!-- check if (only) ONE token is selected and has the ISBUTTON state -->
[h, if(listCount(tokenId) !=1 ): abort(0)]

<!-- TIMER -->
<!-- build in delay to make sure the open door macro is called only once as the token select event will fire 2 to 4 times when you select a token -->
[h, if(bot_timeOut(1)), CODE:{
	[bot_resetTimer(1)]
}; {
	<!-- SHADOW TOKENS -->
	<!-- due to the macro fring off 2 to 4 times, the main token can get deselected. This prevents that.  -->
	[h, if(getProperty("w42.bot.isShadowToken", tokenId) == 1 && canSelectShadowTok == 2): selectTokens(substring(tokenId, 0, length(tokenId) - 7))]
	
	[abort(0)]
}]

<!-- GROUP TOKENS -->
<!-- if its a group token, open the group move menu -->
[h,token(tokenId),if(startsWith(token.label,"group")), CODE:{
	[if(getLibProperty('showGroupPanelOnSelect','lib:EventMacros') && !isFrameVisible("Group Move Macros")):bot_MacroButtonsGroupMove()]
}]

<!-- SHADOW TOKENS -->
<!-- the token has the shadow property then select its shadow token -->
	[h,token(tokenId), if(getProperty("w42.bot.isShadowToken", tokenId) == 1 && canSelectShadowTok == 2): selectTokens(substring(token.name, 0,length(token.name) - length(" shadow")))]

<!-- TOKEN BUTTON & FORCE ON TOP -->
<!-- check if it has buttonArgs property and thus is a button -->
[h:tokButton	= hasProperty("buttonArgs", tokenId)]

<!-- check if there is a gm client called 'forceButtons' (used for always on top) -->
[h:forceButtons	= if(isGM() && getPlayerName() != "forceButtons" && json.contains(getLibProperty("gmNames","Lib:EventMacros"), "forcebuttons"),1,0)]
<!-- abort if no button token, or for full screen token select you need to be gm. -->
[h: abort(tokButton + forceButtons)]

[h, if(tokButton), CODE:{
	[buttonArgs = getProperty("buttonArgs", tokenId)]
	[varsFromStrProp(buttonArgs)]

	<!-- call the macro that is in the buttonArgs deferred -->
	[macroLink = macroLinkText(macroToCall, "none", buttonArgs)]
	[execLink(macroLink, 1)]
}; {}]

[h, if(forceButtons), CODE:{
	<!-- for use with 'always on top': check if there is a gm client called forceButtons, which selects the token you just selected so the correct macro panel is shown on the full screen panel -->
	[broadcast(macroLink("<span  style='text-decoration:none'>&nbsp; </span>", 'SelectAndCentre@this', 'none', tokenId ),"forceButtons")]
};{}]

@@buttonHandler
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=default ; playerEditable=false ; applyToSelected=false ; group=5. Door Button ; tooltip= ; minWidth=90 ; 
[h:'<!-- ------------------ BUTTON && FULSCREEN HANDLER ----------------------------------->']

[h:'<!-- retrieve: doFullScreenMode, canSelectShadowTok -->']
[h:varsFromStrProp(getLibProperty("toggles", "lib:EventMacros"))]

[h: tokenId	= getSelectedNames()]

<!-- check full screen mode. This can't be done in b87 so the json will return "".  -->
[h:IFS		= json.get(getInfo("client"),"isFullScreen")]
[h,if(isNumber(IFS) && doFullScreenMode),CODE:{
	[if(IFS != getLibProperty("fullScreenMode", "Lib:EventMacros")): bot_toggleFullScreen()]
};{}]

<!-- check if (only) ONE token is selected and has the ISBUTTON state -->
[h, if(listCount(tokenId) !=1 ): abort(0)]

<!-- TIMER -->
<!-- build in delay to make sure the open door macro is called only once as the token select event will fire 2 to 4 times when you select a token -->
[h, if(bot_timeOut(1)), CODE:{
	[bot_resetTimer(1)]
}; {
	<!-- SHADOW TOKENS -->
	<!-- due to the macro fring off 2 to 4 times, the main token can get deselected. This prevents that.  -->
	[h, if(getProperty("w42.bot.isShadowToken", tokenId) == 1 && canSelectShadowTok == 2): selectTokens(substring(tokenId, 0, length(tokenId) - 7))]
	
	[abort(0)]
}]

<!-- GROUP TOKENS -->
<!-- if its a group token, open the group move menu -->
[h,token(tokenId),if(startsWith(token.label,"group")), CODE:{
	[if(getLibProperty('showGroupPanelOnSelect','lib:EventMacros') && !isFrameVisible("Group Move Macros")):bot_MacroButtonsGroupMove()]
}]

<!-- SHADOW TOKENS -->
<!-- the token has the shadow property then select its shadow token -->
	[h,token(tokenId), if(getProperty("w42.bot.isShadowToken", tokenId) == 1 && canSelectShadowTok == 2): selectTokens(substring(token.name, 0,length(token.name) - length(" shadow")))]

<!-- TOKEN BUTTON & FORCE ON TOP -->
<!-- check if it has buttonArgs property and thus is a button -->
[h:tokButton	= hasProperty("buttonArgs", tokenId)]

<!-- check if there is a gm client called 'forceButtons' (used for always on top) -->
[h:forceButtons	= if(isGM() && getPlayerName() != "forceButtons" && json.contains(getLibProperty("gmNames","Lib:EventMacros"), "forcebuttons"),1,0)]
<!-- abort if no button token, or for full screen token select you need to be gm. -->
[h: abort(tokButton + forceButtons)]

[h, if(tokButton), CODE:{
	[buttonArgs = getProperty("buttonArgs", tokenId)]
	[varsFromStrProp(buttonArgs)]

	<!-- call the macro that is in the buttonArgs deferred -->
	[macroLink = macroLinkText(macroToCall, "none", buttonArgs)]
	[execLink(macroLink, 1)]
}; {}]

[h, if(forceButtons), CODE:{
	<!-- for use with 'always on top': check if there is a gm client called forceButtons, which selects the token you just selected so the correct macro panel is shown on the full screen panel -->
	[broadcast(macroLink("<span  style='text-decoration:none'>&nbsp; </span>", 'SelectAndCentre@this', 'none', tokenId ),"forceButtons")]
};{}]

@@openFrame
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy=22 ; color=orange ; playerEditable=false ; applyToSelected=false ; group=5. Door Button ; tooltip=<html>Turns on door switches at selected players. This will allow players to use doorswitches ; minWidth=90 ; 
[h:'<!------------------------------------- openFrame ------------------------------------------------>']
<!-- Turns on door switches at selected players. This will allow players to use doorswitches -->
[h:assert(isGM(),"This macro can only be run by the GM",0)]
[h:userList	= getAllPlayerNames()]

[h,if(listCount(userList) != 1), CODE:{
	[h:'<!-- input string -->']
	[h:inputStr	= "junk|<html><b>Turn on door switches for selected players<br></html>|-|LABEL|SPAN=TRUE"]
	[H,FOREACH(player, userList): inputStr = listAppend(inputStr, "player"+roll.count+"|1|"+player+"|CHECK","@")]

	[h:'<!-- ask for input-->']
	[h:abort(eval(listFormat(inputStr, "input( %list )", " ' %item ' ", ",", "@")))]

	[h:playerList = ""]
	[H,FOREACH(player, userList), CODE:{
		[if(eval("player"+roll.count)): playerList = listAppend(playerList, player)]
	}]
};{
	[h:playerList = userList]
}]
[h:bot_resetTimer(1)]
[h:bot_execAllPlayers("SwitchFrame@lib:OnTokenMove","", playerList)]

@@operateLever
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=default ; playerEditable=false ; applyToSelected=false ; group=5. Door Button ; tooltip= ; minWidth=90 ; 
[h:'<!-- ------------------ OPERATE LEVER -------------------------- -->']

<!-- arg(0): leverToken (ID), mainDoor (Name), proximity (Range in cells), macroToCall (operateLever@This) -->
[h:varsFromStrProp(arg(0))]
[h:switchToken (mainDoor)]
[h:leverToken = getSelected()]
[h:closeEnough= 1]
[h:operator = ""]
[h:tokenList = ""]
<!-- proximity check -->
[h,if(proximity), CODE:{
	[tokenList		= getTokenNames(",",json.set("{}", "layer", "TOKEN", "range",json.set("{}","token",leverToken, "upto", proximity)))]
	[tokenList		= listDelete(tokenList, listFind(tokenList,getName(mainDoor)))]
	[closeEnough	= 0]
	[player			= getPlayerName()]
	[foreach(tok, tokenList), CODE:{
		[if(isOwner(player, tok)): closeEnough = 1]
		[if(isOwner(player, tok)): operator = tok]
	}]
}; {
	[tokenList	= getTokenNames(",",json.set("{}", "layer", "TOKEN", "range",json.set("{}","token",leverToken)))]
	[operator	= listGet(getOwned(getPlayerName()),0)]
	[if(operator != ""): operator = getName(operator)]
}]

<!-- flip the lever -->
[h, if(closeEnough): setTokenFacing(180+getTokenFacing(leverToken), leverToken)]

<!-- Handle the Door -->
[h: bot_toggleDoor(mainDoor, closeEnough, operator, tokenList)]

@@toggleLock
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=default ; playerEditable=false ; applyToSelected=false ; group=5. Door Button ; tooltip= ; minWidth=90 ; 
[h:'<!-- ------------------ toggleLock -------------------------- -->']
[h:'<!-- check if (only) ONE token is selected and has the ISBUTTON state -->']
[h:tokenId = getSelected()]
[h:assert(listCount(tokenId)==1, "Make sure (only) one token is selected",0)]
[h:switchToken(tokenId)]

[h:setState('Locked', 1-getState('Locked'))]

@@Token Version 37m
@PROPS@ fontColor=white ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=black ; playerEditable=false ; applyToSelected=false ; group=z. Version ; tooltip= ; minWidth=190 ; 
[h:libversion = "37m"]
[h:setLibProperty("libversion", libversion, "lib:OnTokenMove")]
[h:setLibProperty("libversion", libversion, "lib:EventMacros")]

[h:credits = "<b>Credits</b><br>
The Bag of Tricks is created by Wolph42. For any questions, remarks or requests, simply post in the <font color='blue'><a href='http://forums.rptools.net/viewtopic.php?f=46&t=16066#p170978'>BoT Thread</a></font> on the rptools forum.<br><br>
A couple of macros were based on the code of others, here an overview of who the original creators are and my improvements to their code:
<table>
	<tr><td><b><u>What</b></u></td><td><b><u>Who</b></u></td><td><b><u>Improvements</u</b></td></tr>
	<tr><td>Dicebox</td><td>Rumble</td><td>rewrote most of the code, redid the dice images, added d5 die and the options tab</td></tr>
	<tr><td>Disguise macro</td><td>Aliasmaks</td><td>added the option so you can also create a disguise list by selecting image:tokens together with the disguise token</td></tr>
	<tr><td>Whisper frame</td><td>LMarkus</td><td>added Impersonate selected token and text formatting</td></tr>
	<tr><td>Delete Macros</td><td>Rumble</td><td>added copy/paste function and an 'all macros' panel where you can meta select all macros or groups of macros.</td></tr>
	<tr><td>Message Manager</td><td>Plothos</td><td>added text formatting and images (select a token and then use 'add seleected image').</td></tr>
	<tr><td>Input String Builder</td><td>Bubblobill</td><td>no addition!.</td></tr>
</table>

"]

[h:output = credits + "<br>
<b>Version 37m</b><br>
- updated text for animated door setup.<br>
<b>Version 37l</b><br>
- updated oncampaignload on onTokenMove to take care of the 'no gm' bug.<br>
<b>Version 37k</b><br>
- changed OCL to prevent strange bug<br>
<b>Version 37j</b><br>
- fixed bot_table <br>
- fixed bot_getColumns<br>
<b>Version 37i</b><br>
- Fixed two bugs in the VBL stamp code <br>
- Create a 'Set VBL Stamp' entry in the manual under UTILITY FUNTIONS. <br>
<b>Version 37h</b><br>
- Token move animation now also works in grid pixels (instead of grid cells), but i haven't tested the bounce yet, so at your own risk. <br>
- added bot_snapToGrid(token) function
- added Snap To Grid option in settings. These can be used to animate smooth token move and still have the tokens snapped. (When tokens are snapped, animation will always be in steps of grid cells)
<b>Version 37g</b><br>
- upgraded Diagnose to check for tokens with a numeric ID. <br>
<b>Version 37f</b><br>
- taipoz<br>
<b>Version 37e</b><br>
- small offset fix in teleports for small grid. Uncertain though to the repercussions, so futher testing required<br>
<b>Version 37d</b><br>
- changed getSelected to getSelectedNames in ontokenmove to circumvent the id truncate issue<br>
<b>Version 37c</b><br>
- more tweaks and bugs in map editor!!<br>
<b>Version 37b</b><br>
- tweaks and bugs in map editor!!<br>
<b>Version 37a</b><br>
- adde movetohidden & token macro for the map editor!!<br>
<b>Version 37</b><br>
New Features:<br>
- Map editor. This is a tool to quickly and easily create a full map, without the need to copy paste every token all the time!!<br>
<br>
- Input string editor, as created by Bubblobill. This is for scripter to swiftly create an input string for use. <br>
<br>
Other stuff:<br>
- left rotation animation now also possible<br>
- removed pause from rotation animation<br>
- added runMacroFinal to animatemove, to be executed when animation is done.<br>
- fixed deferanimatemove when you have both a translation and a rotation at the same time <br>
- Fixed issue in Diagnose which did not detect ',' in map names<br>
- Heavy update of the 'delete properties' macro. Added lots of options<br>
- clean up of tokens.<br>
- small bug fix in select on line.<br>
- Added 'Move Crowd Plus' - an upgraded version of 'Move Crowd' albeith much slower.<br>
- Added that and 'Choose Crowd' button to the panels.<br>
- Small tweaks. <br>
--> due to the addition of 'Move Crowd +' the state 'Prone' is required. <br>
- fixed deferRemoveToken<br>
- fixed selectOnLine<br>
- added sort option for selectOnline (sorts in order of distance from origin)<br>
- added moveCrowdPlus (requires Prone state) whic gives a more realistic movement of the crowd and also dissolves it when it reaches the border of the square. <br>
--> due to the addition of the sort function, the lib:fixb90 is now required to use that. <br>
- update on bot_getTokenFacing, added option 2, to NOT add the +90 degrees<br>
- updated bot_selectOnLine() which is now MUCH faster<br>
- Crowd now allows for mulitple Antagonists<br>
- more small bug fixes in crowd build macro<br>
<br>
<b>Version 36a</b><br>
- small bug fix in crowd build macro<br>
<b>Version 36</b><br>
New feature: Crowd. Three new macros. One to select the images to form the crowd. One to create a square filled with tokens forming a crowd and the last macro to disperse the crowd away from the antagonist. <br>
- added bot_pauseTime()<br>
- added bot_resumeTime()<br>
- Added setting 'Force Token Selection'.<br>
- additional Fixes 'startup map'.<br>
- Fixed 'startup map' bug.<br>
- changed 'errorChecks' to 'diagnose'.<br>
 <b>Version 35</b><br>
New feature: Map Error Checks. This function checks ALL maps and ALL (lib)tokens for potential issues. It checks whether token names contain non-alphanumerical characters and checks the libs for the same and owner ship and visibility. Any errors are rendered in a frame with hyperlinks that lead you to the token. 
- pulled out the error checks OCL to a seperate functions<br>
<b>Version 34</b><br>
New feature: Tables<br>
This feature allows you to add, edit (both dynamically and through a form) and delete tables on lib:OnTokenMove. The values can be accessed through the function bot_table(). More info can be found in the manual. <br>
- Added explanation on how to create a polymorph table to use with AM's 'disquise' tool.<br>
<b>Version 33</b><br>
New feaures: Added Geometric Functions (quite a bit of them). They support selection of tokens, point check, draw shape, for the followin shapes: Circle, Cone, Triangle, Line and Square.<br>
- Added extra check to see if lib:eventmacros is to be found in the campaign file.<br>
- Added functions bot_round2Grid() and bot_dpc2GridCoord to the functions manual.<br>
- updated OCL text for doors.<br>
- small fix in set vbl stamp.<br>
<b>Version 32</b><br>
New feature: added New function: Benchmark.<br>
- made sure that removeVBL() does not render any errors when run<br>
- fixed switch map in virtual bot menu<br>
- updated limit movement macro on the evenmacros lib to allow for properties and added more comment<br>
- updated settings movement limitation tooltip<br>
- Updated vblGrenade to both a function that can be called and a function that when given the argument 1 it automatically clears vbl on selected tokens. Also added that function to the input screen.<br>
- set door updated. check for present VBL and if there, add checkbox that allows to clear the VBL on door. It was not possible to clear just the door VBL but it IS possible to clear ALL vbl on the door.<br>
- set door now detects the presence of a double door and checks the box if one is found<br>
- fixed blank line issue ontokenmove<br>
- added eventMacroPreTokenMove and eventMacroPreMultipleTokenMove to the settings and ontokenmove events. This allows to insert code AFTER initialization but BEFORE code execution<br>
- changed 'west' to 'east' for door handles<br>
- added option in doors to add door name to gm notes<br>
- added none to the roof halo colors in the settings<br>
- fixed key hole and window door view
- added new util: Pad Explorer. Shows all special pads on current map<br>
- added quick selection links to the initialize pad results<br>
- corrected halo option for linked pads<br>
- further improvements to useDisguise (if multiple tokens on map have the same image, only one is shown. Self is NOT shown and if no visible images on map then the tab is not shown)<br>
- added warning for non square doors<br>
- updated use disguise to also use polymorph table and visible images on map<br>
- several text updates on suggestion of Oryan<br>
- Added setting where you can set the roof halo color (in the settings)<br>
- summon token no longer shows empty lists<br>
- fixed issue with initialize pads<br>
<br>
<b>Version 31</b><br>
- full check and LOTS of fixes in the doors VBL (my god that was buggy)<br>
- dito for VBL stamps, still had issues with remnants of VBL remaining with rotated tokens<br>
- full VBL support check<br>
- added delete all props to BoT menu<br>
- use red color during OCL to indicate errors<br>
- minor rewrite of the BoT virtual menus<br>
- moved 'difficult' settings to 'system' tab in settings<br>
- create 'scale teleportation' settings, so teleporting from the lower right of a enormous teleport, will put you on the lower right of a huge teleport. (instead of the relative position of the upper left corner of the teleport<br>
- expanded setting 'change to map after inter teleport' with the option to store coords of interteleport pads first. This way you can use the option without reloading the map. Drawback is that need to rerun initialize maps after moving the teleport. <br>
- fixed alt init pads coords value<br>
- alt init lib coords pads are removed if alt init process is aborted (under usual circumstances)<br>
- initialize pads now also checks for the existence of lib:coord files and if there, warns the user.<br>
- added new function (also documented in manual): bot_findDuplicates() which returns all duplicate token(name)s from all layers on the current map.<br>
- fixed initalization bug in shadowpad<br>
<br>
<b>Version 30</b><br>
- Added shadowpads, updated manual<br>
<br>
<b>Version 29a</b><br>
- fixed when you teleport from an activated roof, the roof is de-activated<br>
<br>
<b>Version 29</b><br>
New feature: Added Tunnels, same as Bridges, but reversed (so the roofs only remove if you move over a tunnel token).<br>
- finally mananged to keep bridge and tunnel tokens consistent when moving over them (if you move over a bridge onto a roof it does not disappear, however if you move again from one roof to another without touching the bridge token, the roofs disappear. This is now fixed.).<br>
<br>
<b>Version 28</b><br>
New feature: Bridge pads, to be used icw Roofs and linked pads.
- fixed issue with roofs and doors
- fixed issue with VBL on roofs
- added new function bot_removeVBL(token), which removes all VBL data from the token.
<b>Version 27</b><br>
New feature: Event Buttons. You can set any token up as a 'Event Button'. When that token is selected a macro (of you own design) is activated. This effectively turns a token into a macro button.<br>
- rewrote bot_switchMap() to allow optional arguments (mapname and playerlist)<br>
- Added bot_switchMap() to the documented functions<br>
- created work-around for varsfromstrprop bug in MT. in ontokenmove<br>
- Updated manual with a seperate section on Event Pads and Event Buttons<br>
<br>
<b>Version 26a</b><br>
- fixed MAJOR bug in ontokenmove, without a linked token the bot didn't work<br>
- fixed cleargroup macro<br>
<br>
<b>Version 26</b><br>
A lot of major changes, the big ones 
- I've removed the 'numeric restriction' to the special pads. That means that instead of 'PadStart 1' and 'PadEnd 1' you can now also use 'PadStart Sea Level' and 'PadEnd Sea Level'. This does mean that you will need to be a bit more careful with tokens as now EVERY token that starts with a special name will be indentified as such. Fortunately there is the overview form at the end of the initialization which shows you the results. So keep a close eye on that one. I did however add a setting 'numeric Id only' in the settings, which you can check so it works again. 
- Linked Pads. This works for Roofs, Canopy and Foliage. You can now link these tokens together by an identifier. E.g. 'Linked 1 Canopy 1' and 'Linked 1 Roof 3'. All 'Linked 1' tokens are linked so if one of them is triggered, then they are ALL triggered. 
New features: <br>
- fully operative stamps. The stamps can now cross VBL sections without distorting it.<br>
- dito for doors, they won't cut out vbl walls anymore<br>
- added a new option for roofs: swap VBL, it will have a cross when tokens are outside and it will swap for the room VBL when inside. <br>
- add rotation to animate move<br>
- updated function manual<br>
- integrated Aliasmasks Disguise macro, and added an extra feature: you can also create a disguise list by selecting image:tokens together with the disguise token.<br>
- integrated LMarkus whisper frame and added an extra features: Impersonate selected token and text formatting.<br>
- integrated Rumbles Delete Macros utility. Added extra features: copy/paste function and a 'all macros' panel where you can meta select all macros or groups of macros.<br>
- integrated Plothos Message Manager uttility. Added features: text formatting and adding pictures.
Other<br>
- added check during initialize map to check whether roofs are snapped to grid (which they shouldn't
- updated 'set doors' macro with additional info. Also apply VBL is turned on per default.
- Fixed the token handout. The frame sizes together with the image. Also lowered the default setting from 700 to 500. <br>
- fixed issue in debuging for where you leave out the macro name<br>
- removed a couple of stray 'pause()' debug spots. <br>
- added text field to the handouts<br>
- tested all macros and fixed numerous bugs (some of which I do not understand why I never encountered them before)<br>
- By True_Hitoare: fixed numbering bug in toggle doors, removed the 'auto-open-with one door only' and a visibility check.<br>
- removed redundant error check on initialize pads. BoT also works with over 4000 tokens
- add extra error check and optimization on the initialize pads macro.
<br>
<b>Version 25</b><br>
<b>New features:</b> <br>
bot_debugInfo(). This macro you can put anywhere in your code for debugging purposes. It has several features, described in the function manual.<br> Typical use: [if(debug=1): bot_debugInfo('variable1, variable2, etc.')], and at the top of your macro you can set [debug=1]. This way you can turn debugging swiftly on or off. Per default debugInfo() parses the value to the chat using broadcast() so if the error happens AFTER the call, you'll have the values. Next to that it will show the currentToken, impersonatedToken, and has the option to use pause(). <br>
<br>
Z-order panel: a panel where you can rearrange the order of the tokens on the map, works on selection base. It has extra functions like:<br>
- set layer<br>
- set shape<br>
- rotate tokens<br>
- rotate group<br>
- rotate random <br>
- reset rotation<br>
<br>
rotateGroup(). This macro allows the rotations of a group of selected tokens of different size, while keeping there relative distances intact. The condition however is that the participating tokens must NOT be set to 'freesize'. <br>
<br>
<b>Other changes</b><br>
- Optimization group panel<br>
- updated manual with debugInfo and rotateGroup<br>
- added settings to maximize the number of selected tokens at which panels stop operating<br>
- fixed bug in sliding doors (no animation)<br>
- fixed bug in show area tokens<br>
- fixed bug in animate text<br>
- fixed bug in assignedPads (macro call)<br>
- added timer function and removed Cif's timer lib. <br>
-- bot_startTime: starts/resets the time<br>
-- bot_subTime: gives the time since the last subTime (or startTime if its the first)<br>
-- bot_totalTime: gives the time since it was last started/reset<br>
--- The latter two functions can be given '1' as parameter to return the time formatted: 1h3m2.324s. Else they return ms.
- fixed selection issue in group (select) <br>
- fixed resetFoW bug in ontokenmove <br>
- overhaul of group rotation, added a new function and it now supports rotation of different sized tokens. I removed 45 degrees though.<br>
- generalized the time out macros. <br>
- Fixed issue with door animation closing directly after opening<br>
- last bugs (hopefully) from the group select panel, which was INSANELY difficult to fix. MT does some really strange stuff like negating selections when it fire off the onchangeselection function (4x)<br>
- group select now allows for multiple selections (so you can select two groups and other tokens in addition.<br>
<br>
<b>Version 24</b><br>
New feature (as always when I increase the version number): Group Select Functions. Three macros in total 'Group (Select)', 'Ungroup (Select) and 'Activate Group'. With these macros you can create a group that will act as one object. When you select one token of the group, all other tokens will be auto-selected as well. This is particularly usefull when creating a map with tokens and you want a set of tokens to act as one object. These 'select' groups have nothing to do with the 'move' group functions (aka formations) which is explained in more detail in the manual. For this reason I've renamed the group move macros to better distinct them.<br>
Other changes:<br>
- Updated seektoken to match all when search string is left empty: ' '.<br>
- added extra check OCL: all lib:tokens on BASE map will be checked for ownership. An error is reported when ownership is set.<br>
- VBL stamps are now also supported by multiple token move.<br>
- on request of Jamz, added proximity check to 'toggle doors' macro. A gm can use the macro without selecting a pc token, a player must have a player token selected before this macro works. It then shows a list of doors to open where you're close to enough.
- fixed incompatibility issue with VBL check and draw polygon VBL stamp<br>
- added snap to grid and extend vbl for draw polygon VBL stamp
- two fixes in the vbl stamps<br>
- minor tweaks in the polygon vbl code<br>
- the macro panel now works without the img_table installed<br>
- added setting to turn off the messaging checks oncampaignload<br>
- updated OCL to check the existance of the VBL-brush token<br>
<b>Version 23</b><br>
New feature: Multiple Polygon VBL Stamps. What this means is that you can add (more then one) vision blocking layer to a token. This is particularly usefull for Dungeon Tiles. You can add the VBL to the tiles, save them and then copy paste them over the map and then activate their VBL. I've also went one step futher and added a 'draw mode' where you can use a brush to draw the VBL onto token. To use you will need either b87 with Jamz' fork installed or b89+. In the bot settings, toggles tab, turn on 'VBL Stamps'. Then select a token and run 'Set VBL Stamp'. There choose the polygon option and click ok.<br>
Other changes<br>
- fixed OCL for b87<br>
- added is fullscreen check to the door switch frame. So the isfull screen is now done automatically (b89+)<br>
- renamed the area buttons after the tutorial <br>
- fixed issue with assigned macro to areas not showing up.<br>
- fixed issue draw area, token not appearing on selected token.<br>
- something went wrong with the OCL of 'd'. 2nd attempt. <br>
- made sure that json.fromlist is NOT redefined from b89+ (as its fixed in that version and broken before that)
- Added VBL macro check for build 89 and beyond (so the VBL macros are activated for this version. <br>
- Fixed VBL on move check bug with tokens with the same name. <br>
- macro clean up, reshuffled OCL. <br>
- Added new macro: bot_sortTokeByProp. sort tokens by property. Can be found in function manual<br>
- added tan function. <br>
- added option to bot_travelAngle() to return cardinal points instead of angle<br>
- fixed several issues with lock token. one with the track path still showing and one with vbl check still on. Also multipleontokenmove had some issues. <br>
<b>Version 22</b><br>
New feature: lock token. This prevents the token from being moved. Both by player and gm!<br>
To use: select one or more token. Click the 'lock token' macro. There is a general toggle in the settings to turn this feature on and off. Note that the 'lock' property is stored on the token itself. When you select a mixture of locked and unlocked tokens and run the macro then their settings will be inverted. So the locked will unlock and the unlocked will lock!<br>
Other changes<br>
- updated manual with explanation between initalize maps and alt.init.maps<br>
- Fixed several small bugs in the define and remove area tokens<br>
- Fixed bug in fill area macro (bugged out when using one selected token NOT on basemap<br>
- Added extra functionality to the fill area macro: the fill coordinates are now derived fully when two tokens are selected (upper left is from token 1 and width and height are derived from the relative position of token 2<br>
- fixed small bug in switchmap when gm forces player to the map where the gm already is (and tokens are selected<br>
- fixed bug in seek tokens<br>
- warded areas will be checked first THEN Eventpads THEN the rest (to prevent stepping on a teleport AFTER moving over a ward
- fixed bug in warded tokens <br>
- removed the lower() function from all the message related macro like gm(), self() etc. <br>
- VBL compatibility check is now done OCL <br>
- added more verbosity in OCL <br>
- restored door vbl macro (was erased for unknown reason. <br>
- fixed bug in util menu. <br>
- fixed 'base map' bug in OCL. <br>
- added workaround for a bug in broadcast(), is only in effect when the redefined bc setting is set. <br>
- made sure that all the message owner/self/all/etc macros return lower case names. <br>
- Added bot_getTokensPath(). This function returns the path in cell coordinates (including and) between two tokens. <br>
- Updated function manual with getTokensPath() and getPath()<br>

<b>Version 21</b><br>
Full Screen Mode. Currently this mode needs to be toggled (Shortcut key is F2) as there is no way to check whether you are in Full Screen or not (in the next MT build this should be solved). How it works is simple: if you are in full screen (ctrl+alt+enter) you can press F2 to toggle to full screen mode. The BoT menu will also pop in screen. All the relevant screens will show up in dialog, even the last chat message IF you make use of the message function implemented in this FW. To do that you will need to check the 'redefine broadcast' setting in the settings. This results in the broadcast function not only porting to chat but also to a chat dialog. In that case you will always see the last broadcasted message in full screen. <br>
One remark: when you click somewhere on the MT map then the dialogs will 'dissapear' (as they are moved to the background). To get them back use alt+tab.<br>
Other changes<br>
- the door shape is now automatically set to TOP DOWN (if you have the special jar file installed) for doors that are set.<br>
- expanded the VBL stamps, they now incorporate rotational offsets (not yet in the input). This does require a re-set of the tokens with a vbl stamp. When setting old vbl stamp tokens you get a couple of input requests, just click ok.<br>
- added upgraded code for doors icw vbl stamps (currently deactivated). Something for the future. It does work, but not yet for sliding nor for double doors. <br>
- completely rewritten the door VBL code. Its now simpler (I hope) and the window vbl remains issue should be solved. I've tested it for ALL possible combinations and they all work.<br>
- in addition (though not tested yet) this should allows for freeform doors, so the doors no longer need to be 'large' (4x4 cells) size. <br>
- The only current drawback is that this function is no longer compatible with older set doors, so you will need to set the doors in your campaign again.<br>
- fixed numerous issues with doors (vbl, toggledoors, identifiers, etc.)<br>
- filtered out the double doors from the toggle doors macro.<br>
- fixed bug in toggledoor when only one or no option is selected<br>
- Based on an idea of Pinkrose I Added the net-trap to the campaign file. To use this you will need to add the 'trapped' state to your campaign and you need the 'Standard Net Trap' macro located on lib:EventMacros. There are also  a net token and a trip wire token available in the zip.
- updated manual with rules for the door images when using the VBL option. <br>
- extended 'switch map' with the functionality to move selected tokens as well. <br>

<b>Version 20</b><br>
Message macros. Version 20 contains an update not readily available for most but in the form of a new macro set. Message macros. Specifically bot_message('This is a message', 'This is the header', 'black-white', all(), 'Wolf', 'Prey'). This will broadcast a preformatted message with a header containing both the images of the Wolf and Prey token and the header text and with black background color and white text. I've also included 'user' macros like all(), self(), etc. that return a json array with the users in question. Read the macro manual for more info. <br>
Other changes<br>
- Switchmap automatically selects current map.<br>
- Updated the virtual tables and message() so they remain compatible with java 7.<br>
- added message() functions..<br>
- fixed bug in turning the ontokenmove event on and off. Relic from the split up of the menu. Message is now set to gm only.<br>
- the roof and canopy special pads are automatically moved to the background layer when moved over and moved back to the original layer when moved off<br>
- solved issue with open frame OCL where players got an not gm error message<br>
- track path is turned off for unsnapped to grid tokens<br>
- vbl move check and path tracking now work together (single tok move only)<br>
- updated issue in settings when upgrading from <v18<br>
- show handout function now also has the option to show portrait and token image. Also updated the GUI of this function<br>
- added option to the settings for track path that allows for manual/command removal of the 'path feet'<br>

<b>Version 19</b><br>
Not really a big change but a new feat nonetheless: path tracking. In the settings --> toggles tab a new toggle has been added called <i>Show the last moved path</i>. When checked, small feet will be placed in the cells over which a token is moved. Red feet for NPCs and Blue feet for PCs.<br>
Other changes<br>
- formation rotation goes slightly faster as its optimized<br>
- when the group is NOT snapped to grid the rotation will go in increments of 45 instead of 90 for snapped to grid<br>
- when the selected token has tokenfacing set then the group is rotated according to that tokens rotation<br>
- added Extra manual. When you click 'manual' you will get 2 manuals. The default one and one explaining the available functions from the macro lib.<br>
- added waypointfinder macro to new macro utils (not yet accessible through campaign panel).<br>

<b>Version 18</b
Observant users might notice I've skipped v17 entirely, which I actually didn't but the whole version remained fully in beta and was only available through another topic. This concerned the addition of VBL (Vision Blocking Layer) support. After I was finished with that I did a FULL overhaul of EVERYTHING, mainly function names and property names. This means that this new version will not be backwards compatible with older versions. That is... if you only use teleport pads you need to reinitialize and everything will work, other stuff though like assign pads, doors and canopy probly not. I've made numerous changes and fixes in this version and did not keep track cause of the sheer amount of it. The major VBL changes however you can read. in this log under v 17<br>
Note that this MT version supports the new VBL code, but you need both the .jar file and replace it with the current one in the mt install directory AND you need to turn on 'VBL support' in the settings. <br>
Other changes under v18<br>
-fixed two links in the assign and define area macro buttons, which occured during the tutorial session. The macros are ok, but the buttons were not.<br>
-Added draw area macro, which enables you to fill up an area with one token by dragging the other. The 'one' token will be copied in the path of the moved token. <br>
-Expanded options for Mass VBL with All and Selection<br>
-Added VBL grenade. Select one or more tokens, run macro, set radius (in grid cells) and ALL VBL in that radius around the selected tokens will be cleared. <br>
-Change canopyVBL into Mass VBL and added a lot of options (layers, search string and the option to save the VBl)<br>
-Added Toggle Mass VBL macro, with which you can turn on or off mass VBL structures created by the Mass VBL macro. <br>
-bugfix in the layers selection of Seek Token. <br>
-added circular VBL Stamps<br>
-VBL Stamps can now be added to multiple selected tokens (of different size and rotation)<br>
-token stamp snap to grid issue resolved<br>
-implemented the draw and erase funcitons with json variables<br>
-added horizontal and vertical line option to the vbl stamp<br>
-implemented the draw and erase funcitons with json variables<br>
-added horizontal and vertical line option to the vbl stamp<br>
<br>
<b>Version 17</b><br>
NEW: This version needs a special .jar file for the vbl support to work. Hopefully this code will be implemented in the last version of MT, for no you will need to replace the .jar file in the mt install directory with the vbl support one. 
Added VBL draw and remove for doors (rotating, sliding and double doors for both). In addition some bugfixes to the doors code. 
further improvements on seek token<br>
- find duplicate lib:tokens and swiftly delete them<br>
- sort the found tokens<br>
- restructure the seek token GUI<br>
- updated the regex for looking for partials. I've removed the start/end part but the results show up roughly 3x faster.
- maps in switch map are sorted<br>
- updated manual.<br>
- updated settings with VBL options.<br>
- split up the virtual menu into two tabs (macro got a bit long)
- seekToken can now also be called in a macro, similar to getTokenNames only here you can actually set a name partial for the return.<br>
- added token stamp vbl. If you label a token 'VBLStamp' then a vbl cross will be added to the token when you move it and the vbl will move along with the token. <br>
- vbl stamp now also handles 90 degrees rotations. <br>
- fixed issue with doors on multi clients and some clients getting a pop-up<br>
- fixed vbl issue with doors on clients<br>
- fixed several doors bugs (pop-up request on settin door, duplicate doors over clients)<br>
- VBL for rotating doors is now set ON the door. So if the door is under an angle the VBL line is in the same angle. <br>
- On door VBL now also works for double doors.<br>
- fixed bug in seek token, move from map didn't work<br>
- added couple of functions from Aliasmaks lib:math (cos, sin, toradians)<br>
- created facingToCoord()<br>
- updated door section to work with the new vbl functions<br>
- fixed clearFoW issue (hopefully)<br>
added the following VBL settings for doors:<br>
- crack open door<br>
- half way open door<br>
- peek through key hole<br>
- peek through window<br>
- rewrote VBL part<br>
- made it work for both the non-animated and the animated version<br>
- updated set door with extra tab concerning VBL<br>
- added setting: VBL support (so you can turn it off)<br>

<b>Version 16</b><br>
NEW (well... incrementally over the last subversions): Seek Token. This function can look for a partial string in ALL tokens on ALL maps and allows for a wide variety of settings:<br>
- where to look in the name (start, end, anywhere)<br>
- what to show as result (image, name, layer)<br>
- which layers to look on (token, hidden, object, background)<br>
- The result is shown in the form of executable links which allow you to either: Copy, Move or Select the token.<br>
- And finally: the macro will save the last settings<br>
<b>Other stuff</b>:<br>
- Added more functions to seek token. An image of the found token can be provided, you can set what to show in the results and the settings are saved. The latter means that if you use your own lib:Eventmacro token that you willl get pop-up requests on first use. After that these settings are saved and will be updated with every use.<br>
- Added more functions to seek token. You can now also move or copy a token to the current location through the macro link.<br>
- Added endswith and anywhere options to the seekToken function<br>
- Added macro links to the seekToken results so you can goto the map and select the token automatically.<br>
- Added new macro: <i>Fill Area</i>. This allows you to select one token set the upper left corner of the 'to be filled area' and then set the width and height of the area. The area will then be filled witht copies of the selected token. <br>
- Restructued the show area macro (special areas)<br>
- Added overlay tokens to show special areas<br>
- Fixed some textual issues in assign special area<br>
- updated manual<br>
- Added 'startsWithTxt' option to 'getValidTokens' macro.
- Further improvement of seek token, it can now handle 'infinite' number of token instead of only the first 1000.<br>
- dito for renumber tokens which was limited to 2000 tokens. <br>
- The 'Seek token' macro can now sort found lib:Tokens per map. Also added checkbox to specifically search for these.<br>
- Removed stray 'debug pause()' from initialize maps.<br>
- Added extra setting to exclusions: you can now give a list of token property types that will NOT trigger the onTokenMoveEvent (request of JamzTheMan). For this I removed the earlier check that checked for ANY special pad and if it IS a special pad to abort the trigger. Now you need to set the property type to an excluded one to NOT trigger the event.<br>
- changed the propertyType of ALL the special pads in the example campaign to: 'SpecialPad'. This is no requirement in your campaign file, but can be used to prevent triggering the onTokenMove event for certain property types. These you can set in the settings.<br>
- Updated input screen for show token handout macro. It now depicts a thumbnail of the handout.<br>
- Added show token handout. This forces a pop-up on all selected clients showing the handout.<br>
<br>
<b>Version 15</b><br>
NEW - Event Areas: Added the option to create Areas with a resolution of the current grid that will trigger an event (macro) when a token moves (on, off, over, etc) this area. These Areas can take ANY form and do NOT need to be contiguous. The besst part: they are FAST! Especially when you need to use a lot of pads for e.g. difficult terrain, then Areas will make a HUGE difference in speed. I've also updated the Limit Movement event macro so it works with Areas assigned to it. <br>
Other stuff:<br>
- Fixed 'all' part of summon tokens. <br>
- Added new versions of the teleport pads, showing the entire area they cover so you now exactly what the 'trigger' area is. <br>
- upgraded the event toggle button on the macro panel<br>
- updated 'execute event' macro. It now lists all the macros in lists per group. Multiple macros can be chosen this way to run consecutively<br>
- Rebuild BASE map. The old one is now an example map. The new BASE map contains all the special tokens <br>
- Added explainatory notes to all the special pads on the (new) BASE map. <br>
- The 'result' frame after 'initalize pads' now no longer show the 'found none' entries<br>
- Cleaned up redundant maps
- added option to settings to centre on 'centreOnMePad' on the map.
- Updated execAllPlayers with extra parameter where you can give a list of users to execute for<br>
- Updated switchmap with a selection panel where you can select users<br>
- Implemented code from the_meek which roughly halves the time to initialize the campaign file. As the initialization can vary from a few seconds upto minutes can have a HUGE positive impact on the initalization time!!<br>
- Dice box now supports 10 different boxes (you can click the macro upto 10 times <br>
- added 'show result to GM and You' option. <br>
- added 'switch map' macro. This macro forces ALL clients to the chosen map AND forces view to the centreOnMePad (if its on the map). <br>
- small update in manual <br>
- added util: seek token: searches ALL maps and check ALL tokens to match the first part of a string you enter. <br>

<b>Version 14</b><br>
hmm, forgot to keep track of this... I do remember fixing a LOT of things<br>
The two MAJOR changes;<br>
- I've integrated aliasmaks VBL move check, this is a setting you can turn on. When doing so the path of the token is checked and any move through VBL will be reverted. As a nice side effect, this will also prevent individual FoW lag. <br>
- Because of this feat i had to integrate a defer, which has an effect on the token movement. It LOOKS very snappy but the calculations still take roughly the same amount of time. Point is that the move is done instantly and THEN the pads are checked. Unless you turn on the VBL check in which case your movement will be reverted first, then the path is checked and THEN the token is moved back. Just try it and you'll see what I mean<br>
- Another Side effect of this implementation is that there is NO OUTPUT TO CHAT anymore. This means that for the events in which you want to port something to the chat you'll need to use broadcast(). I've updated the eventMacros to reflect this, so you have some examples. <br>
- Added RUMBLES dice box. I did however rewrote most of the code, redid the dice images and added a couple of options. But its still recognizable as his work!<br>
- bug in the roof, also made it a bit faster<br>
- removed a stray 'pause' in the initialize pads.<br>
- A LOT of restructuring so there is a fair chance that some things won't work properly, testing is required!!<br>
- added extra idiot checks in the settings for lib:eventmacros <br>
- It turned out that it was VERY difficult to setup the bag for a fresh campaign file. Fixed that. The settings will now also automatically run the first time IF you name your initial map not 'BASE'<br>
- Added trigger event AFTER on(multiple)tokenmove.<br>
- Added arguments to macro.<br>
- Updated manual with General Event Macros (last section).<br>
- Updated manual with how to upgrade.<br>
- Added new feature. You can now set events to trigger simultaneous with other events: ontokenmove, onmultipletokenmove, onTeleport, afterTeleport, onInterTeleport and afterInterTeleport.<br>
- fixed couple of bugs in animateText<br>
- added <none> to the assignlist for assigned pads<br>
- added 2 arguments to mtt_executeAssingPads(1,'red') the first executes all pads if set to one, the second limits this to only one group. Using this will immediately  execute the teleportation without an input screen<br>
<b>13.0</b><br>
AssignPads have been added to the mixture on request of BoneWhite. You can place these pads on the map give them a group name and an index name. Then run one macro to link tokens to the pads (this you typically do in preperation of you game). Then with another macro you can execute the teleportation and the linked tokens will be teleported onto the AssignedPads. More in the manual.<br>
Other changes:<br>
- Repaired set light source. You can now select multiple tokens, the current sources of the first selected token are taken as default, after you click ok, those settings are applied to ALL selected tokens. If you have 'set light source' in your campaign panel then turn off 'apply to selected tokens'<br>
- Updated tooltip, noting that this macro does NOT work for light sources with a comma ',' in the name.<br>
- Added functionality: you can assign a trigger macro (placed on lib:eventmacros) to a door.<br>
- Removed macro existence checks from oncampaignload as they generated errors.<br>
- Move the movement limitation macro outside of ontokenmove and onto lib:EventMacros, so a user can now change it to her own liking. Also updated the Settings to reflect this. This DOES REQUIRE YOU HOWEVER TO MOVE TWO FUNCTIONS FROM THE NEW LIB:EVENTMACROS TO YOUR LIB:EVENTMACROS. As I've placed the updated code there. <br>
- onmultiple tokens move passed on the token ID instead of the token name to its macros.<br>
- Expanded tool-tip for max movement and allowed for changing the message.<br>
- Added Alternative code input for movement limiter.<br>
- Added movement limiter to the settings (toggles). This will prevent tokens from moving further then the preset amount.<br>
- removed the last references to pit pads. (now covered by eventPads)<br>
- optimized the ontokenmove a bit, movement should be a bit speedier<br>
- the distance for sliding doors is now set to gridSize of map per default<br>
- added onCampaignLoad setting to automatically run the door switches form<br>
<b>12.0</b><br>
Version 12 now supports sliding doors. This was a bit more tricky then I first envisioned and it required me to rewrite some of the code and variables for the rotating doors as well. In all it should work *better* (not that you would notice). HOWEVER: ALL EXISTING DOORS IN YOUR FRAMEWORK NEED TO BE RESET. With that I mean, if you have a framework with doors using an older version of the Bag of Tricks (<12), then if you update you need to select every existing door in your framework, click setup door and ok. Once thats done everything should be working as usual. <br>
Other stuff:<br>
- implented sliding doors without animation<br>
- completely rewrote setup door<br>
- added teleport demo maps to the campaign<br>
<b>11.0</b><br>
A new number means new pads: InterPadBorder, PadStartBorder, PadEndBorder. I've created these to complete the list of teleport tokens. There existed already 'Border' pads but only for the jump/drop pads I've added them for the Start/End and Inter. This means that these border pads work TWO way, while the others work ONE way. In addition in this version I also did some cleaning up. Also completed a couple of incomplete lists, listing not all the special pads. The manual is updated with these new teleports <br>
Other stuff:<br>
-removed silly typo.<br>
-base map name kept resetting when running setup.<br>
-Fixed bug in MappedPads.<br>
-Updated manual with reported mishaps.<br>
-FoW is cleared for tokens after an teleport to another map (on request of Lonewolf).<br>
-Bug fix startup coordinates, if set to 0 it can generate an error in the OCL.<br>
-Bug fix in OCL map swap.<br>
-added feature to settings to load picked map and coordinates when you load the campaign.<br>
-fixed text animation to other clients<br>
-fixed Set event pad macro<br>
<br>
<b>10.0</b><br>
Version 10 entails a major overhaul of the Bag of Tricks. Which effectively result in two things:<br>
1. The pit and trap special tokens have been replaced by EventPads, read the manual for further info. Note though that this build also contains a macro with which you can swiftly convert old campaign (with pits and traps macro) to be compatible with this build.<br>
2. The introduction of a new library: lib:EventMacros. Here the macros associated with Pits and Traps can (must) be moved AND in addition all the settings, including the info about the pads for your campaign file are store on this token. So with future updates you no longer need to redo the settings and initializing pads. You can simply drag the updated lib:OnTokenMove to your campaign and leave the 'lib:EventMacros' intact.<br>
<br>
The other changes<br>
- Updated manual<br>
- Added ALL to summon tokens<br>
- toggle special now also works for selections<br>
- fixed issue with initializing interjump/interdrop pads.<br>
- minor fix and update in getValidTokens (summon token macro).<br>
- Fixed issue with 'getNumSize not defined' error. (I hope).<br>
- fixed issue with request to map mappads on ALL maps, even if there are no mapped pads.<br>
- the time lock delay in the setting didn't work on the door buttons. Now it does. <br>
- added option to summon multiple tokens of each selected token. Also added a spread option.<br>
<br>
<b>9.0</b><br>
I used to up the version number with each new set of special tokens, but neglected to do that with the border pads. This time however on request of Lindsay (a looong time ago) and lonewolf, I decided to add 'Mapped' teleport pads ('MappedPads') to the mix. Hence the new version number.<br>
- Added Mapped Pads, these pads work similar to the teleport pads, although of these there is only one type of pad and not two like the start and end pad with the 'normal' teleports. When initializing them you'll get a pop-up per map where they exist and here you can set the destination pad. The 'destination' must be a number, so you can if you like also put in forumulas or dice rolls, as long as the result is a number (and as long as a destination pad with that number actually exist). <br>	
- Added toggle to no longer activate special pads if the token was 'moved' around but put back on its original spot. <br>
- another correction to scatter images<br>
- Restore FoW and Centre on Token now happens AFTER taking care of special tokens instead of before (which lead to some unwanted behaviour with e.g. wards and teleports<br>
- updated the manual<br>
- updated the pause message for alt init map<br>
<br>
<b>8.6</b><br>
- the one way teleports were not initialized when using the alt init map<br>
- added one way teleport jumps border pads. Both map and intermap. These are activated when a token moves OVER (or onto) the token and can be used to transport tokens to different maps WITHOUT the need to actually step onto the token.<br>
- correction in travelAngle<br>
- correction in token animation<br>
- implemented Oryans new formation buttons (thnx!!)<br>
- Created seperate button for formations buttons for campaign panel<br>
- added option to run a macro after each step in the animation move macro<br>
- added option to travel a certain distance with the animation move macro<br>
- added function snapAngle()<br>
<br>
<b>8.5</b><br>
- Tabs in settings<br>
- Added toggles to turn certain things on and off in the settings, among which:<br>
- Added toggles to turn on 'restore FoW' on token move<br>
- finally fixed the sorting issue with summon tokens (and its faster now)<br>
- update in getValidTokens() _none no longer requires a mapswitch (the image is retrieved with getimage()<br>
- fixed turn on/off ontokenmove toggle macro<br>
- fixed move issue with group move when members of the group are deleted (this resulted in the moved token to be moved again)<br>
- accidentily broke the door animations... (fixed)<br>
<br>
<b>8.4</b><br>
- added new feature, force selection on 'slave' client. Read last part of the manual for more info. <br>
- changed name of 'init' to mtt.init to prevent interference with token properties<br>
<b>8.3</b><br>
- set group can be called with arguments<br>
- added time-lock setting to the settings. In case of door animation being triggered multiple times when using the token buttons. <br>
<b>8.2</b><br>
- open wedge for selected tokens didn't work properly<br>
- packed wedge for both group tokens and selected tokens didn't work properly<br>
<br>
<b>8.1</b><br>
- Added more formations to the group move.<br>
- Changed the 'group' formation macros such that they also can be used for non grouped tokens, just select more then one token to use them.<br>
- Changed the call for the group move macro panel onTokenSelect method, so the panel is NOT rebuild every time you select a group token<br>
- Updated manual<br>
- Updated notes of nearly all the tokens (new zip file)
- Removed a couple of buggy tokens from the zip file
- The macros running from the macro panel now ignore output (so you don't get blank lines)
- Changed formation macros for icons.
- Fixed a couple of macros that did not run when using the macro frame
<br>
<b>8.0</b><br>
- Added new feature: group move. You can combine a set of tokens into one group, then when you move one token of the group the rest will follow accordingly. Also added some extra macro for rotation and spread.<br>
<br>
<b>7.9</b><br>
- Added settings 'run animation per client' (so you can turn this off)<br>
- Updated manual<br>
-Turned off ownership of lib token (again) (when an owner is checked, the BoT will not function well.)<br>
<br>
<b>7.8</b><br>
- Fixed Proximity issue when using 'toggle doors'.<br>
- Fixed Proximity issue for old door'.<br>
- Added new functionality: doors can be linked to roofs, when this is done, then  token can only 'enter' the roof when it went over an open door. Else the token is warded. <br>
<br>
<b>7.7</b><br>
- Fixed interjumps: jumped to the wrong coordinates.<br>
<br>
<b>7.6</b><br>
- Added setting: automaticaly switch map for interpads. Unchecking this will prevent the map from automatically switching<br>
<br>
<b>7.5</b><br>
- Build in a proximity check for the door switch buttons<br>
- updated manual
- cleaned up the 'set door' macro
- Fixed issue for 'special pads' with no number. This would ask the user for 'padName' when initializing<br>
- Fixed sorting issue for summon tokens<br>
<br>
<b>7.4</b><br>
- Moved the initialization report to a frame to prevent stac overflow when initializing a lot of maps.<br>
<br>
<b>7.3</b><br>
- Added a Text animation macro and a corresponding input screen. you can both use the macro itself or use the input screen as a tool<br>
- fixed small issue where the tokenOwnerOnlyVisible check was not turned off for animated doors when no server is running (e.g. when creating and testing a map)<br>
<br>
<b>7.2</b><br>
- Added a macro with which you can temporarily disable the On Token Move Event. This is usefull for when you e.g. create a map. <br>
- updated manual<br>
<br>
<b>7.1</b><br>
- added Token door switch functionality. You can now set a switch on a door and when you click on that the door will autamatically open/close. This requires some preperations, read the manual for further instructions <br>
- added option to set animation of doors to 0, in which case the door is simply opened without any animation<br>
- added option to lock a door (which means that only the GM can open it.), for this too the manual must be read<br>
<br>
<b>7.0</b><br>
- added one way teleports, both for on a map and in between them<br>
<br>
<b>6.7a</b><br>
- if no special tokens are listed, it will not show up in the summon tokens input<br>
- if no proptypes are listed, it will no longer generate an error<br>
<br>
<b>6.7</b><br>
<br>
- Added line at the bottom of the summon token with the coords and name of the selected token<br>
- Fixed 'Init' request on Intermap teleport<br>
- Started with text animation, not yet ready though<br>
<br>
<b>6.6a</b>: Finetuning in the vbl bounce of animate movement<br>
<br>
<b><u>Changes in 6.6</b></u><br>
- Added Movement Animation Support<br>
- This version is no longer beta<br>
<br>
<b>6.5d</b>: added tooltips to the macro panel.<br>
<b>6.5c</b>: fixed resetPit<br>
<b>6.5b</b>: Interpad didn't work properly<br>
<br>
<b><u>Changes in 6.5 beta</b></u><br>
I've been working pretty hard to get this build out. I've sacked several versions before I came to this one. I think this is the best performace you can get out of this, without loosing any quality. The major change in this one is a different build up of alt.init.pads and a complete rebuild of onTokenMove and onMultipleTokenMove macros. This should result in a faster response to the movement of one or more tokens. I've also added an extra dimension to freesize tokens so in case they're rectangles the move over token works better. I think the most performance increase is noticeable with movement of multiple token in large forests (although even now its slower then I would have want it, but this really is as good as it gets....). Because of the HUGE rebuilds I've been doing between 6.4 and this one, you can consider this release again pretty 'BETA'. So pls test and give feedback.<br>
<br>
<b><u>Changes in 6.4 beta</b></u><br>
- Performance update (mainly for maps which are initialized with 'Initialize Pads' <br>
- Updated output, more condensed output and error reports<br>
- Fixed blank line to chat when multiple tokens were moved
- Downsized tree trunks for performace increase
- fixed issue with set doors, got a bigdecimal error
- added 3 more trunks
- PAD NUMBERS DO NO LONGER NEED TO BE CONTIGUOUS <br>
- Manual text is updated<br>
- Settings and Initialize Pads have been partially rewritten to allow funky characters in mapnames (thnx Alias)<br>
<br>
<b><u>Changes in 6.3 beta</b></u><br>
- added light source editor, can also be adjusted in the settings.<br>
- Added Summon Tokens Macro<br>
<b><u>Changes in 6.2 beta</b></u><br>
- updated manual with 'Implementation'<br>
- removed relic code from 'Bag of Tricks Macros' macro<br>
- (size) fix in alt. init maps.<br>
<br>
<b><u>Changes in 6.1 beta</b></u><br>
- removed the first couple of bugs to implement the rptok straight into a foreign FW. 
<b><u>Changes in 6.0 beta</b></u><br>
Note that this version is HEAVILY updated and is thus still in beta fase. I've tested it a couple of times and encountered some errors (which I later couldn't reproduce) but despite the errors (which you can click away) everything appears to work. <br>
- Created an alternative method to initialize pads, this method saves EVERY coordinate on the map where a special token is placed and when a token moves through it it checks vs that coordinate. This is a faster method if many special tokens (> 100) are used on the map, or when you move a lot of tokens at once. <br>
- Rewritten the internal structure of ontokenmove and onmultipletokenmove<br>
- Rewritten Autoforest<br>
- Updated manual<br>
- Renamed all UDF's to mtt_ so it does no longer interfere with anyones own macros. <br>
- Added progress bar for huge calculations like the alternative initialization<br>
- Updated settings so you can omit certain maps in the initialization process <br>
- added macro frame containing all the Bag of Tricks Macros so it takes less space on the campaign panel.<br>
- All the original campaign macros are still available, but are all updated so you need to re-drag these from the lib:token to your owns campaign panel (or use the alternative button).<br>
- added a couple of usefull functions like:<br>
- 'remove %20', this replaces any %20  with a normal space <br>
- renumber tokens, this makes sure all the tokens of one type are numbered continuously<br>
- toggle special, with this you can turn on/off all canopy, foliage or roofs in one click. <br>
- set draw order, witht this you can better influence the z-order of a token. <br>
<br><br>
Note: In the campaign file on the BASE map you'll find two extra libraries, rpedit and token manager, these are not mine, but are drop-ins from the forum which I use to code and debug this drop-in. <br>
<br><br>

<b><u>Changes in 5.2</b></u><br>
- Few tweaks in Autoforest so it can also be used for 5ft squares<br>
<br>
<b><u>Changes in 5.1</b></u><br>
<br>
- NEW: Auto Forests<br>
- Rebuild scatter macros<br>
<br>
<b><u>Changes in 5.0</b></u><br>
- NEW: CANOPY: Canopy has the same function as foliage however 'Canopy' tokens are given a treetrunk image as token handout automatically when 'Initialize maps' is run. Read Manual for further info. 
- NEW: SCATTER: Merged scatter functions (drop-in of Craig, further developed by me) with the back of tricks. Especially usefull icw Canopy. <br>
- Upgraded scatter with 'Spread' function. <br>
- Updated Manual <br>
- Manual is now shown in a frame.  <br>
- Added photoshopped images of Treetrunks to the campaign file and the zip.  <br>
- Removed code from Campaign Buttons.  <br>
- Added Remove %20 macro  <br>
- Added renum tokens macro  <br>
- Added toggle special pads macro  <br>
 <br>
<b><u>Changes in 4.2</b></u><br>
- accidentily set ownership of the lib:token, meaning that the autoexec didn't work anymore meaning that the animations got screwed up.<br>
- fixed issue when a player is on another map when you start the macro<br>
- added feature to set a description for the door, which you find back in the Toggle Door<b>s</b> macro. <br>
<br>

<b><u>Changes in 4.1</b></u><br>
- animated doors function now works seperate on every client, this does however means that GMs will see ghost images of every clients animation<br>
- fixed issue with duplicated lib:tokens when a client connects or when a server is started. 
<br>

<b><u>Changes in 4.0</b></u><br>
- added animated doors functionality<br>
- updated manual<br>
<br>

<b><u>Changes in 3.2</b></u><br>
- fixed chkMapsOCL error when you only use the token<br>
<br>

<b><u>Changes in 3.1</b></u><br>
- mfrizzell pointed out to me that the map initialization onCampaignLoad is confusing for some and certainly not always wanted. To make this tool as UF as possible it does a rough check on startup (onCampaignLoad) and if it finds anything it properly initilises all the maps. This makes it appear that all the maps are loaded serially (you see the maps flicker shortly by) instead of just loading the campaign file. For big maps this can be VERY annoying, while for small maps and during development this can be very usefull... so now its a setting. You can turn it on or off is you want. The default is on (checked).<br>
<br>

<b><u>Changes in 3.0</b</u><br>
Big changes (even if they don't look like it) so reason for a version increase.<br>
- <b>Full support for multiple tokens move</b>. This means that if you position you tokens correctly, you can in one move of 4 tokens: teleport, move in a trap, another in a pit and move a fourth one to another map<br>
- Couple of performance fixes (although overall performance for mutliple token move will have decreased, because of the full support)<br>
- Tokens are not stopped in front of a warded area instead of a full reset of the move.<br>
- The path of the token is now correctly cut off when e.g. trapped in a pit or stopped by a warded area. Before you could drag a token through a warded area onto foliage, which would let the foliage dissapear while the token was not on it. <br>
<br>
<b><u>Changes in 2.7</b</u>
<br>
- If the pads are not yet initialized on this map, its done so automatically. Note that this only happens when the entry on the libtoken is empty!<br>
- Added settings: use alternative 'transparent image for foliage' which allows the use of the token handout image in stead of the tabel image. <br>
- Updated the manual<br>
- Removed all the text tags and placed it in the 'Notes' sections of the tokens, so just click on the tokens for more info about them. <br>
- Added macro 'set draw order' so you can manually set the draw order. 
"]
[r:broadcast(output)]

@@VBLPolyForm BCK
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=99 ; color=gray ; playerEditable=false ; applyToSelected=false ; group=z. Version ; tooltip=<html>This function applies a VBL (Vision Blocking Layer) upon a token. The VBL will move with the token as you move it. ; minWidth=90 ; 
[h: '<!-- --------------------------------------- VBLPolyForm ---------------------------------------------->']
[args		= macro.args]
[me			= json.get(args,"me")]
[brush		= json.get(args,"brush")]
[resetFoW	= json.get(args,"resetFoW")]
[thickness	= json.get(args,"thickness")]
[snap2Grid	= if(json.get(args,"snap2Grid") != 0, "CHECKED", "")]
['pause("args","snap2Grid","resetFoW")']

[extendPx	= json.get(args,"extendPx")]
[extendPx	= if(isNumber(extendPx), extendPx, 0)]

[tokName	= getName(me)]
[actionStr	= macroLinkText('drawVBLPolygon@this', 'none')]
[vblArrays	= getProperty('w42.bot.vblPoints', me)]
[vblDataStr	= replace(string(vblArrays), "\\],\\[", "]<br><br>[")]
[vblDataStr	= replace(string(vblDataStr), "\\},\\{", "} {")]

[htmlStr	= strformat("
	<html><body style='font-size:8.5px; text-align:left'>
	
	<form id='drawVBLPolygon' method='json' action='%{actionStr}'>
	<input type='hidden' name='me' value='%{me}'>
	<input type='hidden' name='brush' value='%{brush}'>
	<input type='hidden' name='resetFoW' value='%{resetFoW}'>
	<input type='hidden' name='thickness' value='%{thickness}'>
	<input type='hidden' name='snap2Grid' value='0'</input>

	<b><font color='red' size=5>Adding Polygon VBL Shape to: </font><font size=5>%{tokName}</b><br>
	<br><font color='red'><b>First of all: make sure that 'brush' is added to the exclusion type in the settings:</b></font> open the BoT settings --> exclusion tab --> at the bottom you'l find 'Exclude Property Types'. Add 'brush' (without the ' ') to that list!!<br>
	<br>
	A small brush just appeared on the token you wish to add VBL to. Its possible that the brush is behind the token. If thats the case then right-click on the token and then 'send to back'. <br>
	<br>
	To draw the VBL select the brush and drag it over the token, you will notice a blue line: that will be the VBL line. To set waypoints, press the space bar.<br>
	<br>
	Below are three buttons:<br>
	- <u>Add VBL To Token</u>: this will add the LAST PATH of the brush. So it will add the 'blue line waypoints' (including start and end) as polygon coordinates to the VBL layer of the token. Hence if you move the brush, drop it, then move it again and drop it. It will ONLY store the last move.
	- <u>Remove All VBL from Token</u>: this will remove all the VBL points currently saved on the token.
	- <u>Quit VBL Draw mode</u>: this will stop the VBL edit mode and will NOT add the lastPath (so add first then quit)add the VBL polygon lines you have created so far. 'Add VBL' will <br>
	<br>
	So in short, to draw a vbl line:<br>
	1. First postion the brush on the starting point<br>
	2. Then drag the brush over the token to draw the vbl lines and press spacebars to set waypoints.<br>
	3. When done, click: Add VBL To Token.<br>
	<br>
	<u>Some notes:</u><br>
	- If you make a mistake: don't click the Add VBL but just repeat steps 1 to 2 again and then add the VBL.<br>
	- If you want to draw multiple polygons, just go through steps 1 to 3 multiple times. 
	- With every added polygon the apply/delete VBL process will be a bit slower as it has to apply each shape seperately. Hence its better to draw the VBL line in one go (if possible). If you're using this method to add VBL to static objects (so things that normally don't move) then this is less important as the shapes will be added only one time. <br>
	- Keep in mind that complex VBL layers can and will slow down token movement and overall game play. Try to keep waypoint to a minimum!!
	- The brush was created for a 50 pixel square grid, any deviation from that will make the blue line appear somewhere else then the tip of the brush. To correct this double click on the brush and go to the config tab. At the bottom left you see a 'layout' panel here you can move the brush image such that it aligns with the blue line. It might take a couple of tries to get this right. Also note that you do not *have* to do this, its just easier while editing. The *only* important thing is the blue line!. 
	<br>
	<table><tr><td>
		<input type='submit' value='Add VBL To Token' name='action'></input>
	</td><td>
		<input type='submit' value='Remove All VBL from Token' name='action'></input>
	</td><td>
		<input type='submit' value='Quit VBL Draw mode' name='action'></input>
	</td></tr></table>

	<table>
	<tr><td width 10px><input type='checkbox' name='snap2Grid' %{snap2Grid} /></td><td><span title='<html>This will not snap the blue line to grid, but it will adjust the x,y coordinates of the waypoints to the closest gridpoints.<br>So the eventual applied VBL will be aligned to the grid.'>Snap to grid</span></td></tr>
	<tr><td width 10px><input size='3' value=%{extendPx} name='extendPx'></td><td><span title='<html>When snapping to grid and applying lines to dungeon tiles you<br>want the opening VBL not to stop at the edge of the token but<br>extend a few pixels so it better connects with another tile. <br>Here you can set the number of pixels it should be extending..<br><br>THIS ONLY WORKS WHEN:<br>- snap to grid is turned on<br>- the edges of the dungeon tile are aligned to the grid!<br>'>Extend VBL lines (Pixels)</span></td></tr>
	</table>

	<br>
	<b><u>Current VBL data, stored on token:</u></b><br>
	<font bgcolor='white'> %{vblDataStr}</font><br>

	</body></html>
")]

[frame("Add Polygon VBL","width=400; height=400"):{[r:htmlStr]}]

@@drawVBLPolygon BCK
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=0.90em ; sortBy=99 ; color=gray ; playerEditable=false ; applyToSelected=false ; group=z. Version ; tooltip=<html>This function applies a VBL (Vision Blocking Layer) upon a token. The VBL will move with the token as you move it. ; minWidth=90 ; 
[h: '<!-- --------------------------------------- drawVBLPolygon ---------------------------------------------->']
[debug = 1]
<!-- <html>This function processes lastpath of the brush token into VBL polygon coords and stores it onto the token. -->

[args		= macro.args]
[me			= getName(json.get(args,"me"))]
[brush		= getName(json.get(args,"brush"))]
[resetFoW	= json.get(args,"resetFoW")]
[thickness	= json.get(args,"thickness")]
[action		= json.get(args,"action")]
[snap2Grid	= if(json.get(args,"snap2Grid") != 0, 1, 0)]
[extendPx	= json.get(args,"extendPx")]
[pointList	= getProperty("w42.bot.vblPoints", me)]
[token(brush):path	= getLastPath(1,brush)]

['pause("args","snap2Grid")']

<!-- actions are: 'Add VBL To Token', 'Remove All VBL from Token', 'Quit VBL Draw mode' -->
[if(action == "Add VBL To Token"), CODE:{
	<!-- note that the points have a -25% XY offset so you need to add 1/2 gridsize both to x and y for each point.  -->
	[newPoints	= "[]"]
	[gs			= bot_getGridSize()]
	[offset		= floor(gs/2)]

	<!-- if snap 2 grid use the current gridsize, else set grid to 1, effectively ignoring this setting. -->
	[s2g		= if(snap2Grid, gs, 1)]
	[foreach(point, path):newPoints	= json.append(newPoints, json.set("{}","x",round((json.get(point, "x")+offset)/s2g)*s2g, "y", round((json.get(point, "y")+offset)/s2g)*s2g))]

	<!-- check if the first and last 2 points are the same, this happens when the user set a waypoint at the start or end  -->
	[j1	= json.get(newPoints, 0)]
	[j2	= json.get(newPoints, 1)]
	[if(json.equals(j1,j2)): newPoints	= json.remove(newPoints, 0)]
	[n	= json.length(newPoints)-1]
	[j1	= json.get(newPoints, n)]
	[j2	= json.get(newPoints, n-1)]
	[if(json.equals(j1,j2)): newPoints	= json.remove(newPoints, n)]

	<!-- extend the edges of the polygon with n pixels, make sure that these edges are aligned to the grid as well! -->
	<!-- if the tile is created sloppy e.g 197 px wide instead of 200, then compensate for this -->
	[if(extendPx), CODE:{
		[x1	= round(	(getTokenX(1, me)			)/s2g)*s2g]
		[y1	= round(	(getTokenY(1, me)			)/s2g)*s2g]
		[x2	= round(	(x1 + getTokenWidth(me)		)/s2g)*s2g]
		[y2	= round(	(y1 + getTokenHeight(me)	)/s2g)*s2g]

		<!-- extend the FIRST and LAST point of the polygon -->
		[firstPoint	= json.get(newPoints, 0)]
		[pointA		= bot_extendPoint(firstPoint, 0)]
		[lastPoint	= json.get(newPoints, json.length(newPoints)-1)]
		[pointB		= bot_extendPoint(lastPoint,1)]
	
		[if(!json.equals(firstPoint, pointA)):	newPoints	= json.merge(json.append("",pointA), newPoints)]
		[if(!json.equals(lastPoint, pointB)):	newPoints	= json.append(newPoints, pointB)]
	};{}]
	
	<!-- add the new polygon to the existing array, in case someone double clicked the submit button, erase the double entry -->
	[pointList		= json.unique(json.append(pointList, newPoints))]
	[vblSetup		= "applyVBL=1; VBLType=5; scaleX=100; scaleY=100; offsetX=0; offsetY=0; fill=0; scale=1; close=0; pxRadius=0; radius=0; sides=0; centreOffset=0; rxOffset=0; ryOffset=0"]

	[setProperty("w42.bot.vblSetup", vblSetup, me)]
	[setProperty("w42.bot.vblPoints", pointList, me)]
	[resetProperty("w42.bot.jsonVBL", me)]

	[varsFromStrProp(vblSetup)]

	<!-- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), getMacroName(), getMacroLocation()) -->
	[h,if(debug == 1): bot_debugInfo("me, vblSetup, pointList, newPoints, path",0,1,1, getMacroName(), getMacroLocation())]
	
	<!-- get the new VBL settings and apply the new VBL cross to its current position -->
	[bot_createVBL(me,1)]

	[macro("VBLPolyForm@this"):args]
''
};{}]

[if(action == "Remove All VBL from Token"), CODE:{
	[jsonVBL	= getProperty("w42.bot.jsonVBL", me)]
	[if(json.type(jsonVBL)=="ARRAY"):eraseVBL(jsonVBL)]
	[resetProperty("w42.bot.vblSetup", me)]
	[resetProperty("w42.bot.vblPoints", me)]
	[resetProperty("w42.bot.jsonVBL", me)]
	[macro("VBLPolyForm@this"):args]
};{}]

[if(action == "Quit VBL Draw mode"), CODE:{
	[jsonVBL	= getProperty("w42.bot.jsonVBL", me)]
	[removeToken(brush)]
	[closeFrame("Add Polygon VBL")]
	[if(json.type(jsonVBL) == "ARRAY"):numShapes	= json.length(jsonVBL) ; numShapes = 0]
	[setLibProperty("vblSnap2Grid",snap2Grid, "lib:EventMacros" )]
	[setLibProperty("vblExtendPx",extendPx, "lib:EventMacros" )]
	[broadcast(strformat("Finished VBL Draw Mode. %{numShapes} polygon shapes have been added to ")+getName(me))]
};{}]

@@getFullInfo
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=42 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=z. Version ; tooltip= ; minWidth=90 ; 
[r:broadcast("
	Server:
	<pre>"+json.indent(getinfo("server"),1)+"
	_________________________________________________________
")]

[r:broadcast("
	Client:<br>
	<pre>"+json.indent(getinfo("client"),1)+"
	_________________________________________________________
")]

[r:broadcast("
	Campaign:<br>
	<pre>"+json.indent(getinfo("campaign"),1)+"
	__________________________________________________________
")]

[r:broadcast("
	Current Map:<br>
	<pre>"+json.indent(getinfo("map"),1)
)]

@@all
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=44 ; color=orange ; playerEditable=false ; applyToSelected=false ; group=Message ; tooltip= ; minWidth=20 ; 
[h:macro.return=json.fromList(getAllPlayerNames())]

@@gm
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=46 ; color=orange ; playerEditable=false ; applyToSelected=false ; group=Message ; tooltip= ; minWidth=20 ; 
[h:macro.return=getLibProperty("gmNames", "lib:EventMacros")]

@@message
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=41 ; color=orange ; playerEditable=false ; applyToSelected=false ; group=Message ; tooltip= ; minWidth=90 ; 
[h:'<!-- --------------------------------- BOT_message ------------------------------------------------>']
<!-- 
0:message, 
OPTIONAL
1:headertxt, 
2:color (bgcolor-txtcolor), 
3:userList, 
4:token, 
5:target
6:broadcast, 
-->

<!-- ignore output , new scope -->

<!-- arguments -->
[h:message		= arg(0)]

<!-- Optional arguments -->
[h,if(argCount() > 1): headerText	= arg(1) ; headerText	= ""]

[h,if(argCount() > 2): color 		= arg(2) ; color		= "black"]
[h,if(indexOf(color, "-")+1), CODE:{
	[break		= indexOf(color, "-")]
	[bgColor	= substring(color, 0, break)]
	[textColor	= substring(color, break + 1)]
}; {
	[bgColor	= color]
	[textColor	= "white"]
}]

[h,if(argCount() > 3): userList		= arg(3) ; userList		= "[]"]

[h,if(argCount() > 4), CODE:{
	[me			= arg(4)]
	[token(me): meImage	= getTokenImage()]
	[me			= strformat("<b>%{me}</b> ")]
	[meImage	= strformat("<img src='%{meImage}' height='20' width='20' alt='%{me}'/>")]
}; {
	[me			= ""]
	[meImage	= ""]
}] 

[h,if(argCount() > 5), CODE:{
	[target	= arg(5)]
	[if(target != ""), CODE:{
		[token(target):	targetImage	= getTokenImage()]
		[targetImage	= strformat("<img src='%{targetImage}' height='20' width='20' alt='%{target}'/>")]
	}; {
		[targetImage	= ""]
	}]
}; {
	[target			= ""]
	[targetImage	= ""]
}] 

[h,if(argCount() > 6): bc			= arg(6) ; bc		= 1]

<!-- the actual code -->
[h:txtResult	= strformat("
	<table bgcolor='%{bgColor}' width='100%' cellpadding='3' cellspacing='0'><font color = '%{textColor}'>
		<tr>
			<td>
				%{meImage}
			</td>
			<td align='middle'>
				%{me}%{headerText}
			</td>
			<td align='right'>
				%{targetImage}
			</td>
		</tr>
	</font></table>"+
	if(message != "", "
		<table bgcolor='%{bgColor}' width='100%' cellpadding='1' cellspacing='0'>
			<table bgcolor='White' width='100%'>
				<tr>
					<td>
						%{message}
					</td>
				</tr>
			</table>
		</table>
	", "")
))]

[h, if(bc), CODE:{
	[if(!json.isEmpty(userList)): broadcast(txtResult, userList); broadcast(txtResult)]
	<!-- retrieve: doFullScreenMode, used to store the last message and update the macro frame with it. -->
	[varsFromStrProp(getLibProperty("toggles", "lib:EventMacros"))]
	[if(doFullScreenMode),CODE:{
		[isFullScreen	= json.get(getInfo("client"),"isFullScreen")]
		[frameVisible	= isFrameVisible("Bag Of Tricks Macros") + isDialogVisible("Bag Of Tricks Macros")]
		[if(isFullScreen == 1 && frameVisible), CODE:{
			[dialog("Bag Of Tricks Macros", "width=215; height=700; temporary=0; input=1"): {
				[r:bot_createMacroButtonsOTMUtils(txtResult)]
			''
			}]
		''
		};{}]
	''
	};{}]
''
}; {
	[macro.return = txtResult]
''
}]

@@message JAVA 7
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=41 ; color=orange ; playerEditable=false ; applyToSelected=false ; group=Message ; tooltip= ; minWidth=90 ; 
[h:'<!-- --------------------------------- BOT_message ------------------------------------------------>']
<!-- 
0:message, 
OPTIONAL
1:headertxt, 
2:color (bgcolor-txtcolor), 
3:userList, 
4:token, 
5:target
6:broadcast, 
-->

<!-- ignore output , new scope -->

<!-- arguments -->
[h:message		= arg(0)]

<!-- Optional arguments -->
[h,if(argCount() > 1): headerText	= arg(1) ; headerText	= ""]

[h,if(argCount() > 2): color 		= arg(2) ; color		= "black"]
[h,if(indexOf(color, "-")+1), CODE:{
	[break		= indexOf(color, "-")]
	[bgColor	= substring(color, 0, break)]
	[textColor	= substring(color, break + 1)]
}; {
	[bgColor	= color]
	[textColor	= "white"]
}]

[h,if(argCount() > 3): userList		= arg(3) ; userList		= "[]"]

[h,if(argCount() > 4), CODE:{
	[me			= arg(4)]
	[token(me): meImage	= getTokenImage()]
	[me			= strformat("<b>%{me}</b> ")]
	[meImage	= strformat("<img src='%{meImage}' height='20' width='20' alt='%{me}'/>")]
}; {
	[me			= ""]
	[meImage	= ""]
}] 

[h,if(argCount() > 5), CODE:{
	[target	= arg(5)]
	[if(target != ""), CODE:{
		[token(target):	targetImage	= getTokenImage()]
		[targetImage	= strformat("<img src='%{targetImage}' height='20' width='20' alt='%{target}'/>")]
	}; {
		[targetImage	= ""]
	}]
}; {
	[target			= ""]
	[targetImage	= ""]
}] 

[h,if(argCount() > 6): bc			= arg(6) ; bc		= 1]

<!-- the actual code -->
[h:txtResult	= strformat("
<table style='border:1px solid %{bgColor}; background-color:red; color:%{textColor}; width:100%; ' cellpadding='1' cellspacing='0'>
	<tr>
		<td>
			%{meImage}
		</td>
		<td align='middle'>
			%{me}%{headerText}
		</td>
		<td align='right'>
			%{targetImage}
		</td>
	</tr>
</table>

<table style='border:1px solid %{bgColor};color:black;' cellpadding='0' cellspacing='0' width='100%'>
	<tr>
		<td>
			%{message}
		</td>
	</tr>
</table>
"))]

[h, if(bc), CODE:{
	[if(!json.isEmpty(userList)): broadcast(txtResult, userList); broadcast(txtResult)]
}; {
	[macro.return = txtResult]
}]

@@ngm
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=44 ; color=orange ; playerEditable=false ; applyToSelected=false ; group=Message ; tooltip= ; minWidth=23 ; 
[h:macro.return = json.difference(getAllPlayerNames("json"), getLibProperty("gmNames", "lib:EventMacros"))]

@@nownergm
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=52 ; color=orange ; playerEditable=false ; applyToSelected=false ; group=Message ; tooltip= ; minWidth=90 ; 
[h,if(isOwnedByAll()):macro.return = "[]" ; macro.return = json.difference(getAllPlayerNames("json"), bot_ownergm())]

@@nself
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=48 ; color=orange ; playerEditable=false ; applyToSelected=false ; group=Message ; tooltip= ; minWidth=38 ; 
[h:macro.return = json.difference(getAllPlayerNames("json"), json.fromList(getPlayerName()))]

@@nselfgm
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=48 ; color=orange ; playerEditable=false ; applyToSelected=false ; group=Message ; tooltip=returns all but self and gm ; minWidth=39 ; 
[h:macro.return = json.difference(getAllPlayerNames("json"), json.union(getLibProperty("gmNames", "lib:EventMacros"), json.fromList(getPlayerName())))]

@@ownergm
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=51 ; color=orange ; playerEditable=false ; applyToSelected=false ; group=Message ; tooltip= ; minWidth=90 ; 
[h,if(isOwnedByAll()):macro.return = getAllPlayerNames() ; macro.return = json.union(getOwners("json"), getLibProperty("gmNames", "lib:EventMacros"))]

@@self
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=47 ; color=orange ; playerEditable=false ; applyToSelected=false ; group=Message ; tooltip= ; minWidth=38 ; 
[h:macro.return=json.fromList(getPlayerName())]

@@selfgm
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=50 ; color=orange ; playerEditable=false ; applyToSelected=false ; group=Message ; tooltip= ; minWidth=39 ; 
[h:macro.return = json.union(getLibProperty("gmNames", "lib:EventMacros"), json.fromList(getPlayerName()))]

@@altInitMap
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=16 ; color=fuchsia ; playerEditable=false ; applyToSelected=false ; group=2. onTokenMove ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------------------------ ALTINITMAP -------------------------------------------------------------->']

[h: assert(getImpersonated() == "", "Make sure no token is impersonated while running this macro", 0)]
[h,if(argCount()>0): allToks = arg(0); allToks = ""]
[h:map = getCurrentMapName()]

[h:libCoordName	= strformat("lib:Coords %{map}")]
[h:libCoordSize = getLibProperty("libCoordSize", "lib:EventMacros")]
[h:existTok		= findToken(libCoordName)]
[h,if(existTok != ""): initRun = getLibProperty("initRun", libCoordName); initRun = 0]
[h,if(initRun == ""): initRun = 0]
[h:baseMapName	= getLibProperty("baseMapName", "lib:EventMacros")]

[h,if(initRun == 0 && existTok != ""), CODE:{
	[message = "It seems you have Initialized this map before, if there are any lib:Coords XxYy tokens on the map, press Cancel and delete these first.<br>These tokens can typically be found at the 0,0 coordinate.<br>If there are no lib:Coords XxYy on the map, press ok to continue"]
	[pause("message")]
}]

[h,if(initRun > 0), CODE:{
	[h:'<!-- initRun is a number indicating that this concerns multiple runs to initialize this map. -->']
	[h:numMinX = 0]
	[h:numMinY = 0]
	[h:numMaxX = 0]
	[h:numMaxY = 0]
}; {
	[h:'<!-- if initRun has no value or 0 then this is the first time the map is initialized -->']
	[h:'<!-- create the coord libs -->']
	[h:specNameList = "Canopy, Foliage, InterPad, PadStart, PadEnd, InterPadBorder, PadStartBorder, PadEndBorder, PadJump, InterJump, PadJumpBorder, InterJumpBorder, MappedPad, Roof, EventPad, Ward"]
	[h, if(allToks == ""): allToks = json.toList(json.sort(getTokenNames(",", json.set("{}", "layer", json.append("","TOKEN", "OBJECT", "HIDDEN","BACKGROUND")))))]

	[h:tokList = ""]
	[h, foreach(tok, allToks), CODE:{
		[padName = getGroup(strfind(tok, "[A-z]+"), 1,0)]
		[if(listContains(specNameList, padName)): tokList = listAppend(tokList, tok)]
	}]

	[h:numToks = listCount(tokList)]
	[h:assert(numToks <= 1000, "Fatal error: The number ("+numToks+") of special pads on this map is more than 1000. This tool can handle upto 1000 special pads. Please remove "+(numToks - 1000)+" pads from this map",0)]

	[h:tok = listGet(tokList, 0)]
	[h:switchToken(tok)]
	[h:xMin=getTokenX(0)]
	[h:yMin=getTokenY(0)]

	[xSize	= getProperty("w42.bot.xSize")]
	[ySize	= getProperty("w42.bot.ySize")]
	[if(!isNumber(xSize) || !isNumber(ySize)): bot_determineTokSize()]
	[h:xMax=xMin + xSize]
	[h:yMax=yMin + ySize]

	[h, foreach(tok, tokList), CODE:{
		[switchToken(tok)]

		[xSize	= getProperty("w42.bot.xSize")]
		[ySize	= getProperty("w42.bot.ySize")]
		[if(!isNumber(xSize) || !isNumber(ySize)): bot_determineTokSize()]
		
		[h:x = getTokenX(0)]
		[h:y = getTokenY(0)]
		[h:xMin = min(xMin, x)]
		[h:yMin = min(yMin, y)]
		[h:xMax = max(xMax, x + xSize)]
		[h:yMax = max(yMax, y + xSize)]
	}]
	
	Upper left	= ([r:xMin], [r:yMin])<br>
	Lower Right	= ([r:xMax], [r:yMax])<br><br>
	[h:numMinX = floor(xMin/libCoordSize)]
	[h:numMinY = floor(yMin/libCoordSize)]
	[h:numMaxX = floor(xMax/libCoordSize)+1]
	[h:numMaxY = floor(yMax/libCoordSize)+1]

	[h:'pause("xMin","yMin","xMax","yMax","numMinX","numMinY","numMaxX","numMaxY","libCoordSize")']

	[h:initRun = 1]
}]

[h:'<!-- here the lib:coords are actually created. if this is a second run then numMin[n] are all set to 0 -->']
[h,if(existTok != ""): createdCoordLibs = getLibProperty("createdCoordLibs", libCoordName); createdCoordLibs = ""]
[h,for(x, numMinX, numMaxX,1, "<br>"),CODE:{
	[r,for(y, numMinY, numMaxY, 1, "<br>"),CODE:{
		[h:xCoord = x*libCoordSize]
		[h:yCoord = y*libCoordSize]
		[h:name = strformat("lib:Coords %{map} X%{xCoord}Y%{yCoord}")]
		[h:existTok = findToken(name)]
		[h,if(existTok != ""):removeToken(existTok)]
		[h:updates = '{"name":"[r: name]", "useDistance":"0", "x":"[r:x]", "y":"[r:y]"}']
		[r:createdCoordLibs = listAppend(createdCoordLibs, getName(copyToken("lib:Coords", 1, baseMapName, updates)))] 
	}]
}]
Created: [r:createdCoordLibs]

[h:'<!-- a pause break is necessary for the copy tokens, else the coordinates will be discarded. This only needs to be done if there are actually lib:tokens created this run -->']
[r, if(initRun == 1), CODE:{
	[h:existTok = findToken(libCoordName)]
	[h,if(existTok != ""):removeToken(existTok)]
	[h:x = numMinX - 1]
	[h:y = numMinY - 1]
	[h:updates = '{"name":"[r: libCoordName]", "useDistance":"0", "x":"[r:x]", "y":"[r:y]"}']
	<br>[r:getName(copyToken("lib:Coords", 1, baseMapName, updates))] Created<br>
	[h:answer	= input("junk|<html>This break is necessary for the just created lib:Coords tokens.<br>Click ok to continue.<br><br>his is also a good moment to mention that it is VITAL that FREESIZE<br>(or native size) tokens are NOT SET TO SNAP TO GRID.<br><br>In case you are using <b>Freesize</b> special pad tokens, its advisable (but<br>not necessary) to set the size of these tokens before you run this macro.<br>To do this select the token and click the set size macro. If you don't<br>do this up front this macro will pop-up the size request for each of<br>these tokens.<br><br>For <b>Interpads, InterJumpBorder and MappedPads</b> you'll need to<br>initialize the campaign 'normally' first so they get setup properly.<br>This only needs to be done once (unless you change or add those tokens).<br><br>Make sure you've done all this, if you're not sure, press cancel, <br>b>delete the lib:coords files</b> that have just been created and check<br>the tokens you're not sure of and/or run the 'normal' initialize pads.</html>|-|LABEL|SPAN=TRUE")]
	[h,if(answer == 0), CODE:{
		<!-- if process is aborted delete the created coord tokens -->
		[foreach(tok, createdCoordLibs): removeToken(tok)]
		[removeToken(libCoordName)]
		[assert(0,"Alt. init. Process aborted",0)]
	};{}]

	[message = "This break is necessary for the just created lib:Coords tokens. Click ok to continue.<br><br>This is also a good moment to mention that it is VITAL that FREESIZE (or native size) tokens are NOT SET TO SNAP TO GRID.<br><br>In case you are using <b>Freesize</b> special pad tokens, its advisable (but not necessary) to set the size of these tokens before you run this macro. To do this select the token and click the set size macro. If you don't do this up front this macro will pop-up the size request for each of these tokens.<br><br>For <b>Interpads, InterJumpBorder and MappedPads</b> you'll need to initialize the campaign 'normally' first so they get setup properly. This only needs to be done once (unless you change or add those tokens).<br><br>Make sure you've done all this, if you're not sure, press cancel, <b>delete the lib:coords files</b> that have just been created and check the tokens you're not sure of and/or run the 'normal' initialize pads."]
[pause("message")]

	[h:setLibProperty("initRun", initRun, libCoordName)]
	[h:setLibProperty("libCoordSize", libCoordSize, libCoordName)]
}]
[h:setLibProperty("createdCoordLibs", createdCoordLibs, libCoordName)]

[h:'<!-- Here starts the process of mapping the special pads on the cell coordinates. To do this the location and size of each pad is determined and from there the coordinates of the cells it actually covers are calculated. These coordinates are used to create a property on lib:Coords and contain the name of the special pad. -->']

[r,if(initRun == 1), CODE:{
	[h:numToks 			= listCount(tokList)]
	[h:maxPadsPerRun 	= getLibProperty("maxPadsPerRun", "lib:EventMacros")]
	[h:numRuns 			= ceil(numToks/maxPadsPerRun)]
	[h:tokList 			= json.fromList(tokList)]

	[h,for(i, 1, numRuns+1), CODE:{
		[runToksname = "runToks"+i]
		[if(i < numRuns):	set(runToksname, json.toList(json.get(tokList, (i-1) * maxPadsPerRun, i * maxPadsPerRun - 1))); 
							set(runToksname, json.toList(json.get(tokList, (i-1) * maxPadsPerRun, -1)))
		]
		[setLibProperty(runToksname, eval(runToksname), libCoordName)]
	}]

	[h:setLibProperty("numRuns", numRuns, libCoordName)]
	[h:tokList = runToks1]
	[h:'pause("runToks1","runToks2","runToks3","runToks4","numRuns", "tokList")']

}; {
	[h:tokList = getLibProperty("runToks"+initRun, libCoordName)]
}]

Run [r:initRun]:
[h: bot_abortProcess(1)]
[h: link = macroLinkText("deferInitialize@Lib:OnTokenMove", "self", json.append("",listCount(tokList), tokList))]
[h: execLink(link,1)]

@@checkInterPads
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=11 ; color=default ; playerEditable=false ; applyToSelected=false ; group=2. onTokenMove ; tooltip= ; minWidth=90 ; 
[h:'<!-- checkInterPads (no new scope)-->']

[h,if(json.contains(interPadCheckList, fullPadName)), CODE:{
	[tmp = json.get(interPadCheckList, fullPadName)]

	[if(json.contains(tmp, "map1")), CODE:{
		[map1 = 1]
		[map1Name = json.get(tmp, "map1")]
	}; {
		[map1 = 0]
	}]

	[if(json.contains(tmp, "map2")), CODE:{
		[map2 = 1]
		[map2Name = json.get(tmp, "map2")]
	}; {
		[map2 = 0]
	}]

	[if(map1 && map2), CODE:{
		[txtOutPut = txtOutPut + "<font color='red'>Error: found three (or more) identical <u>"+padName+" "+tmpNum+"</u> on maps " + map1Name + ", " + map2Name + " and " + currentMap + "<br></font>"]
		[error = 1]
	}; {}]
}; {}]

@@chkMoveStop
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=12 ; color=default ; playerEditable=false ; applyToSelected=false ; group=2. onTokenMove ; tooltip= ; minWidth=90 ; 
[h:'<!-- CHKMOVESTOP -->']
[h:pathPadList = bot_path2pads(json.get(lastPath,1,-2))]
[h:moveStopList = "Ward"]

[r,foreach(item, moveStopList), if(bot_inStr(pathPadList, item)), CODE:{
	[h:newLastPath = "[]"]
	[h:clear = 1]
	[h:edgePoint = ""]
	[h,foreach(step, lastPath), CODE:{
		[pads = bot_path2pads(step)]
		[if(clear): newLastPath = json.append(newLastPath, step)]
		[foreach(item, moveStopList): clear = if(bot_inStr(pads, item),0, clear)]
		[h:'<!-- in this line x and y are defined as vars -->']
		[if(!clear && edgePoint == ""): edgepoint = varsFromStrProp(json.toStrProp(step))]
	}]
	[r:lastPath = newLastPath]
	[h,if(!clear): moveToken(x,y,0)]
	[h:'<!-- build a new pathPadList for the next foreach UNLESS its the last check -->']
	[if(roll.count < 1 && !clear):pathPadList = bot_path2pads(json.get(lastPath,1,-2))]
}; {
	[h:clear = 1]
	[r:lastPath]
}]

@@deferFinishInit
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=default ; playerEditable=false ; applyToSelected=true ; group=2. onTokenMove ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------------------------ deferFinishInit -------------------------------------------------------------->']
[h:map 				= getCurrentMapName()]
[h:libCoordName		= strformat("lib:Coords %{map}")]
[h:numRuns 			= getLibProperty("numRuns", libCoordName)]
[h:initRun 			= getLibProperty("initRun", libCoordName)]
[h:createdCoordLibs = getLibProperty("createdCoordLibs", libCoordName)]
[h:closeFrame("Progress Bar")]
[h:done = if(initRun == numRuns, 1, 0)]

[h: message = if(done, "Map is initialized", "There are a total of "+numRuns+ " runs necessary to complete the initialization. This is run "+initRun+". Run the macro again for Run "+(initRun + 1))]

[h, if(!done): initRun = initRun + 1]
[h:setLibProperty("initRun", initRun, libCoordName)]
[r:message]

[h:'<!-- Now gather all the properties from all the libCoords tokens and concatenate them and at the same time create variables from each of them -->']
[h: allProps = "[]"]
[h,foreach(tok,createdCoordLibs), CODE:{
	[props = getPropertyNamesRaw ("json", tok)]
	[foreach(prop, props):set(prop, getProperty(prop, tok))]
	[allProps = json.merge(allProps, props)]
}]

[h:'<!-- use strPropsFromVars to turn the concatenated list in one go into a strProp list and save that to the lib:Coord file -->']
[h:mappedCoords = strPropFromVars( json.toList(allProps), "UNSUFFIXED")]
[h:'<!-- it turns out that there occur spaces in the strProps due to: X_31Y_31 =Canopy 81, Canopy 61 ; . The space ", " needs to be removed -->']
[h:mappedCoords = replace(mappedCoords, ", ", ",")]
[h:setLibProperty("mappedCoords", mappedCoords, libCoordName)]
[h:setLibProperty("allCoordsArray", allProps, libCoordName)]

[h:'<!-- delete the  lib:CoordXY files -->']

[h,if(done), CODE:{
	[foreach(tok, createdCoordLibs): removeToken(tok)]
}]

@@deferInitialize
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=8 ; color=default ; playerEditable=false ; applyToSelected=true ; group=2. onTokenMove ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------------------------------------ DEFERINITIALIZE --------------------------------------------------------------------------->']
[h:assert(getLibProperty("abortProcess", "lib:EventMacros")!=0, "Process Aborted", 0))]

[h:totalIteration = arg(0)]
[h:tokList = arg(1)]
[h:currentIteration = totalIteration - listCount(tokList)]

[h:output = "
	<table width=305px bgcolor='red'>
		<tr><td>
			[h:prog.percentage = floor(100*currentIteration/totalIteration)]
			<table width=[r:3*prog.percentage]px bgcolor = 'green' color='white'>
				<tr><td>
					[r:prog.percentage]%&nbsp; " + if(band(currentIteration,1), '0', 'o') + "
				</td></tr>
			</table>
		</td></tr>
	</table>

	&nbsp; 
	<table width=100px bgcolor='black' cellpadding='1'>
		<table width=100% bgcolor='red'><td align='center')>
			<td>
				<span  style='text-decoration:none; color:yellow'>
					" + macroLink('Abort process', 'abortProcess@this', '', 0) + "
				</span>
			</td>
		</table>
	</table>
"]

[if(bot_isFullScreen()), CODE:{
	[dialog("Progress Bar", "width=410; height=20; temporary=1; ouptut=1"): {[r:output]}]
};{
	[frame("Progress Bar", "width=410; height=20; temporary=1"): {[r:output]}]
}]

[h:'<!----------------------------- here you can do your calculations -------------------------->']

[h:tok			= listGet(tokList, 0)]
[h:tokList		= listDelete(tokList, 0)]
[h:xSize		= getProperty("w42.bot.xSize", tok)]
[h:ySize		= getProperty("w42.bot.ySize", tok)]
[h:map			= getCurrentMapName()]
[h:libCoordSize	= getLibProperty("libCoordSize", strformat("lib:Coords %{map}"))]
[h:'<!-- output to chat -->']
[r, token(tok):token.name] 
(
	[r, token(tok):xTok = getTokenX(0)] 
	[r, token(tok):yTok = getTokenY(0)] 
)
<br>
[h:'<!-- /output to chat -->']
[h:'e.g: lib:Coords Grasslands X-50Y-50']
[h, for(x, xTok, xTok + xSize), CODE:{
	[for(y, yTok, yTok + ySize), CODE:{
		[xCoord		= floor(x/libCoordSize)*libCoordSize]
		[yCoord		= floor(y/libCoordSize)*libCoordSize]
		[if(x<0):xn = replace(x,"-","_"); xn = x]
		[if(y<0):yn = replace(y,"-","_"); yn = y]
		[coordName	= strformat("X%{xn}Y%{yn}")]
		[libName 		= strformat("lib:Coords %{map} X%{xCoord}Y%{yCoord}")]
		[setLibProperty(coordName, listAppend(getLibProperty(coordName, libName),tok), libName)]
	}]
}]

[h:'<!----------------------------- /here you can do your calculations -->']

[h, if(listCount(tokList)):	execLink(macroLinkText("deferInitialize@Lib:OnTokenMove", "self", json.append("",totalIteration, tokList)),1); 
							execLink(macroLinkText("deferFinishInit@Lib:OnTokenMove", "self"),1)
]

@@deferOnMultipleTokensMove
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy=4 ; color=yellow ; playerEditable=false ; applyToSelected=false ; group=2. onTokenMove ; tooltip= ; minWidth=193 ; 
[h:'<!-- ----------------------------------- deferOnMultipleTokensMove ------------------------------------------------->']
[h:'<!-- -----------------------------------INITIALIZE-----------------------------------------------']
<!-- The reason for the strange layout of this code is so that it aligns with onMultipleOntokenmove, which makes it easier to compare the two codes-->
<!-- VARS: tok,map,libCoordName,lastPath,isAltInit,lastPPath,usedMove,doAbort -->

[h: varsFromStrProp(arg(0))]

<!-- define the following vars:  doGroups,doResetFoW,doTriggerOnZeroMove,doCentreOnTok,doSpecialPads,doFirstPointPath,doInnerPointsPath,limitMovement,eventMacroOnTokenMove, eventMacroOnMultipleTokensMove, eventPreMacroTeleport, eventPostMacroTeleport, eventMacroPreInterTeleport, eventMacroPostInterTeleport, eventMacroPostTokenMove, eventMacroPostMultipleTokensMove -->
[h: varsFromStrProp(arg(1))]

<!-- The reason for this big gap (yes its a gap cause theres more code way down) is because of the similarity with deferOntokenMove, all the code that is the same are on the same line number.  -->

	

	
	
	
	
	
	
	
	
<!-- execute a linked event from the settings -->
[r, if(eventMacroOnMultipleTokensMove != "<none>"), CODE:{[macro(eventMacroOnMultipleTokensMove+"@Lib:EventMacros"): json.append("", toks)]}; {}]

<!-- AMs VBL Checker -->
[h,if(doVBLCheck), CODE:{
	[foreach(tok,toks):bot_moveVBLToken(tok, eval("lastPath"+roll.count))]
}; {}]

<!-- Align VBL Stamps with moved token-->

[h,if(doVBLStamp), CODE:{
	<!-- any token with the label VBLStamp will have a VBL cross that moves with the token -->
	<!-- if a VBL cross is already there, remove it first (its params are stored on the token) -->
	<!-- createVBL defines x, y,etc. and vblPresent is its stored on token -->
	[foreach(tok,toks), CODE:{
		[hasVBL	= if(json.type(getProperty("w42.bot.fgVBL", tok))=="ARRAY",1,0)]
		[if(hasVBL): 	bot_moveStamp(tok)]
	}]
	[if(doResetFoW): exposePCOnlyArea()]
}; {}]

<!-- abort if special pads are turned off -->
[h:abort(doSpecialPads)]

[h,if(isAltInit), CODE:{
	[mappedCoords 	= getLibProperty("mappedCoords", libCoordName)]
	[allCoordsArray	= getLibProperty("allCoordsArray", libCoordName)]
	<!-- turn all mapped coordinates of the special tokens into active variables e.g. X1Y5 = "Canopy 12" -->
	[varsFromStrProp(mappedCoords, "UNSUFFIXED")]

	<!-- if token has not moved but just "wobbled" there will be 1 coordinate == listSize(2) abort in this case -->
	[token(json.get(toks,0)):lastPPath = getLastPath(0)]
	[abort(if(listCount(json.fromList(lastPPath))<3,0,1))]
	[oneStepOnly = if(listCount(json.fromList(lastPPath))<5,1,0))]

	
	<!-- GET THE PADS OVER WHICH THE TOKEN MOVED, START, MIDDLE AND END -->
	<!-- @@MULTIPLE TOKEN MOVE SPECIFIC CODE-->
	<!-- combine all coordinates of the lastpaths of all the tokens that moved and then create the padList. -->
	[Path		= '[]']
	[firstPoint = '[]']
	[lastPoint	= '[]']
	[foreach(tok, toks), CODE:{
		[token(tok):lastPPath = getLastPath(0)]
		<!-- if the token walks over a pad that stops it in its path, then discard the remainder of the path and move token to the (new) edge -->
		[if(!oneStepOnly && doInnerPointsPath): bot_chkMoveStop()]
		[if(!oneStepOnly): Path = json.union(Path, json.get(lastPPath,1,-2)); Path = "[]"]
		[firstPoint	= json.union(firstPoint,json.get(lastPPath,0,0))]
		[lastPoint	= json.union(lastPoint,	json.get(lastPPath,-1,-1))]
	}]
	[lastPointPadList	= bot_path2pads(lastPoint)]
	<!-- /@@MULTIPLE TOKEN MOVE SPECIFIC CODE-->
	
	<!-- FILTER OUT ONLY THOSE PAD THAT NEEDS TO BE CHECKED FOR EITHER START, MIDDLE AND END -->
	[if(doFirstPointPath), CODE:{
		<!-- check if token is on a relevant token when leaving -->
		[firstPointPadList		= bot_path2pads(firstPoint)]
		[firstPointPadCheckList = "Canopy, Foliage, Roof, EventPad"]
		[padTypeList			= replace(firstPointPadList, " [0-9]+", "")]
		[oldPadList				= firstPointPadList]
		[firstPointPadList		= ""]
	}; {
		[padTypeList 			= ""]
		[firstPointPadList		= ""]
	}]
	[for(i, 0, listCount(padTypeList)), CODE:{
		[check = listContains(firstPointPadCheckList, listGet(padTypeList, i))]
		[if(check): firstPointPadList = listAppend(firstPointPadList, listGet(oldPadList, i))]
	}]

	[if(doInnerPointsPath), CODE:{
		<!-- check if a token walks over a relevant pad -->
		[pathPadList 			= bot_path2pads(Path)]
		[pathPadCheckList		= "Ward, EventPad, PadJumpBorder, InterJumpBorder, PadStartBorder, PadEndBorder, InterPadBorder"]
		[padTypeList			= replace(pathPadList, " [0-9]+", "")]
		[oldPadList				= pathPadList]
		[pathPadList			= ""]
	}; {
		[padTypeList 			= ""]
		[pathPadList			= ""]
	}]
	[for(i, 0, listCount(padTypeList)), CODE:{
		[check = listContains(pathPadCheckList, listGet(padTypeList, i))]
		[if(check): pathPadList = listAppend(pathPadList, listGet(oldPadList, i))]
	}]
}; {
	<!-- if the list is build traditionally -->
	[allMapsPads = getLibProperty("allMapsPads", "lib:EventMacros")]
	[if( json.type(allMapsPads) != 'OBJECT' ), CODE:{
		[broadcast("The pads of this campaign are not initialized yet, doing so now...")]
		[bot_initializePads()]
		[allMapsPads = getLibProperty("allMapsPads", "lib:EventMacros")]
	}; {}]
	[abort(json.contains(allMapsPads,getCurrentMapName()))]
	[pathPadList			= json.get(allMapsPads, getCurrentMapName())]
	[firstPointPadList			= ""]
	[lastPointPadList			= ""]
}]

[h:'<!-- -----------------------------------/INITIALIZE------------------------------------------------->']

<!-- SPECIAL AREAS -->
[h: linkedAreas = getLibProperty("linkedAreas", "lib:EventMacros")]
[h,if(json.contains(linkedAreas, map)), CODE:{
	[thisMapLinks			= json.get(linkedAreas, map)]
	[thisMapAreas			= json.get(getLibProperty("storedAreas","lib:EventMacros"),map)]
	<!-- distance per cell e.g. 5ft per cell then walking 2 cells will result in 10 -->
	[DpC					= json.get(json.get(getInfo("map"),"grid"),"units per cell")]
}; {
	[thisMapLinks = "{}"]
}]

<!-- LINKED PADS @@@ NOT WORKING FOR MULTIPLE TOKENS MOVE-->
[h:linkedPads				= json.get(getLibProperty("linkedMappedPads", "lib:EventMacros"), getCurrentMapName())]
[h:doLinkedPads				= if(!json.isEmpty(linkedPads),1,0)]
[h,if(doLinkedPads), CODE:{
	[lastLinkId				= getLibProperty("lastLinkId","lib:EventMacros")]
	[linkedIdList			= json.fields(linkedPads)]
	[actList				= "startLinkId=;endLinkId="]
	[foreach(id, linkedIdList): actList = setStrProp(actList, "activated"+id, 0)]
};{}]

<!-- retrieve current location of token-->
<!-- /@@MULTIPLE TOKEN MOVE SPECIFIC CODE-->
[h:numToks = listCount(toks)-1]
[h,foreach(tok, toks), CODE:{
	<!-- /@@MULTIPLE TOKEN MOVE SPECIFIC CODE-->
	[h:doAbort					= if(roll.count == numToks, 0,1)]
	[h:switchToken(tok)]
	[h:lastPath					= eval("lastPath"+roll.count)]
	[h:tok						= eval("tok"+roll.count)]
	[h,if(!doTriggerOnZeroMove && json.length(lastPath)==1):abort(0)]
	[h:startingLocation			= eval("startingLocation"+roll.count)]
	[h:currentLocation			= eval("currentLocation"+roll.count)]
	<!-- reset all linkedpad variables for every token -->
	[h,if(doLinkedPads):varsFromStrProp(actList)]

	<!-- handle SPECIAL AREAS -->
	[h:ignoreStartPath		= json.remove(lastPath,0)]
	[h,foreach(areaName, thisMapLinks,"<br>"):bot_EventArea()]

	<!-- handle all starting position pads-->
	[h,foreach(padName, firstPointPadList,""):	eval("bot_"+getGroup(strfind(padName, "[A-z]+"), 1,0)+"()")]
	<!-- handle all Path related pads-->
	[h,foreach(padName, pathPadList,""):		eval("bot_"+getGroup(strfind(padName, "[A-z]+"), 1,0)+"()")]
	<!-- handle all ending position pads-->
	[h,foreach(padName, lastPointPadList,""):	eval("bot_"+getGroup(strfind(padName, "[A-z]+"), 1,0)+"()")]

	<!-- execute a linked event from the settings -->
	[h, if(eventMacroPostMultipleTokensMove != "<none>"), CODE:{[macro(eventMacroPostMultipleTokensMove+"@Lib:EventMacros"): json.append("", tok)]}; {}]
	[h,if(!json.isEmpty(linkedPads)):setLibProperty("lastLinkId", endLinkId, "lib:EventMacros")]
}]

@@deferOnTokenMove
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy=3 ; color=yellow ; playerEditable=false ; applyToSelected=false ; group=2. onTokenMove ; tooltip= ; minWidth=193 ; 
[h:'<!-- ------------------------ deferOnTokenMove - this macro is run automatically if ONE token is moved ---------------------------- -->']
[h:'<!-- -----------------------------------INITIALIZE-----------------------------------------------']
<!-- The reason for the strange layout of this code is so that it aligns with onMultipleOntokenmove, which makes it easier to compare the two codes-->
<!-- VARS: tok,tokId,map,libCoordName,lastPath,isAltInit,lastPPath,usedMove,doAbort,doShowPath, doSnap2Grid -->
[h: vars				= arg(0)]
[h: varsFromStrProp(vars)]
[h: switchToken(tok)]

<!-- define the following vars:  doGroups,doResetFoW,doVBLCheck,doTriggerOnZeroMove,doCentreOnTok,doSpecialPads,doFirstPointPath,doInnerPointsPath,limitMovement,eventMacroOnTokenMove, eventMacroOnMultipleTokensMove, eventPreMacroTeleport, eventPostMacroTeleport, eventMacroPreInterTeleport, eventMacroPostInterTeleport, eventMacroPostTokenMove, eventMacroPostMultipleTokensMove,movementLock,doVBLStamp -->
[h: varsFromStrProp(arg(1))]

<!-- group movement -->
[h,if(doGroups && startsWith(token.label,"group")), CODE:{
	[groupName			= token.label]
	[startingLocation	= json.toList(json.get(lastPath,0,0))]
	[currentLocation	= json.toList(json.get(lastPath,-1,-1))]
	[xDiff				= json.get(currentLocation, "x") - json.get(startingLocation, "x")]
	[yDiff				= json.get(currentLocation, "y") - json.get(startingLocation, "y")]
	[tokList			= getProperty("w42.boT."+token.label)]
	[foreach(tmpTok,tokList), CODE:{
		[token(tmpTok), if(findToken(tmpTok) != ""):moveToken(getTokenX()+xDiff, getTokenY()+yDiff)]
	}]
}]

<!-- execute a linked event from the settings -->
[r, if(eventMacroOnTokenMove != "<none>"), CODE:{[macro(eventMacroOnTokenMove+"@Lib:EventMacros"): json.append("", tok)]}; {}]

<!-- AMs VBL Checker -->
[h,if(doVBLCheck):bot_moveVBLToken(tokId, lastPath)]

<!-- snap to grid option -->
[h,if(doSnap2Grid):bot_snapToGrid(tokId)]

<!-- Align VBL Stamps with moved token-->
[h: doVBLStamp = if(doVBLStamp && json.type(getProperty("w42.bot.fgVBL"))=="ARRAY", 1, 0)]
[h,if(doVBLStamp), CODE:{
	<!-- any token with the label VBLStamp will have a VBL cross that moves with the token -->
	<!-- if a VBL cross is already there, remove it first (its params are stored on the token) -->
	<!-- createVBL defines x, y,etc. and vblPresent is its stored on token -->
	[bot_moveStamp(tok)]
	[if(doResetFoW): exposePCOnlyArea()]
}; {}]

<!-- put small feet in the moved path -->
[h,if(doShowPath && isSnapToGrid()):bot_getPath(doShowPath, 1, tok, lastPath)]

<!-- abort if special pads are turned off -->
[h:abort(doSpecialPads)]

[h,if(isAltInit), CODE:{
	[mappedCoords 	= getLibProperty("mappedCoords", libCoordName)]
	[allCoordsArray	= getLibProperty("allCoordsArray", libCoordName)]
	<!-- turn all mapped coordinates of the special tokens into active variables e.g. X1Y5 = "Canopy 12" -->
	[varsFromStrProp(mappedCoords, "UNSUFFIXED")]

	
	<!-- if token has not moved but just "wobbled" there will be 1 coordinate == listSize(2) abort in this case -->
	[abort(if(listCount(json.fromList(lastPPath))<3,0,1))]
	[oneStepOnly = if(listCount(json.fromList(lastPPath))<5,1,0))]
	

	<!-- GET THE PADS OVER WHICH THE TOKEN MOVED, START, MIDDLE AND END -->
	<!-- if the token walks over a pad that stops it in its path, then discard the remainder of the path -->
	<!-- this macro also runs pathPadList = bot_path2pads(json.get(lastPPath,1,-2)), which needs to be rebuild is !clear -->

	
	
	
	
	
		[if(!oneStepOnly && doInnerPointsPath):	bot_chkMoveStop(); pathPadList = ""]
		<!-- added clear = 0 as its clearly not initialized. Need more infor on clear as its unclear what it does... god the pun... -->
		[if(oneStepOnly):	clear = 1 ; clear = 0]

		
	[lastPointPadList		= bot_path2pads(json.get(lastPPath,-1,-1))]

	
	<!-- FILTER OUT ONLY THOSE PAD THAT NEEDS TO BE CHECKED FOR EITHER START OR MIDDLE. End is checked for all!! -->
	[if(doFirstPointPath), CODE:{
		<!-- check if token is on a relevant token when leaving -->
		[firstPointPadList		= bot_path2pads(json.get(lastPPath,0,0))]
		[firstPointPadCheckList = "Canopy, Foliage, Roof, EventPad"]
		[padTypeList			= replace(firstPointPadList, " [0-9]+", "")]
		[oldPadList				= firstPointPadList]
		[firstPointPadList		= ""]
	}; {
		[padTypeList 			= ""]
		[firstPointPadList		= ""]
	}]
	[for(i, 0, listCount(padTypeList)), CODE:{
		[check = listContains(firstPointPadCheckList, listGet(padTypeList, i))]
		[if(check): firstPointPadList = listAppend(firstPointPadList, listGet(oldPadList, i))]
	}]

	[if(doInnerPointsPath), CODE:{
		<!-- check if a token walks over a relevant pad -->
		[if(!clear):pathPadList = bot_path2pads(json.get(lastPPath,1,-2))]
		[pathPadCheckList		= "Ward, EventPad, PadJumpBorder, InterJumpBorder, PadStartBorder, PadEndBorder, InterPadBorder"]
		[padTypeList			= replace(pathPadList, " [0-9]+", "")]
		[oldPadList				= pathPadList]
		[pathPadList			= ""]
	}; {
		[padTypeList 			= ""]
		[pathPadList			= ""]
	}]
	[for(i, 0, listCount(padTypeList)), CODE:{
		[check = listContains(pathPadCheckList, listGet(padTypeList, i))]
		[if(check): pathPadList = listAppend(pathPadList, listGet(oldPadList, i))]
	}]
}; {
	<!-- if the list is build traditionally -->
	[allMapsPads = getLibProperty("allMapsPads", "lib:EventMacros")]
	[if( json.type(allMapsPads) != 'OBJECT' ), CODE:{
		[broadcast("The pads of this campaign are not initialized yet, doing so now...")]
		[bot_initializePads()]
		[allMapsPads = getLibProperty("allMapsPads", "lib:EventMacros")]
	}; {}]
	[abort(json.contains(allMapsPads,getCurrentMapName()))]
	[pathPadList				= json.get(allMapsPads, getCurrentMapName())]
	[firstPointPadList			= ""]
	[lastPointPadList			= ""]
}]

[h:'<!-- -----------------------------------/INITIALIZE------------------------------------------------->']

<!-- SPECIAL AREAS -->
[h: linkedAreas = getLibProperty("linkedAreas", "lib:EventMacros")]
[h,if(json.contains(linkedAreas, map)), CODE:{
	[thisMapLinks			= json.get(linkedAreas, map)]
	[thisMapAreas			= json.get(getLibProperty("storedAreas","lib:EventMacros"),map)]
	<!-- distance per cell e.g. 5ft per cell then walking 2 cells will result in 10 -->
	[DpC					= json.get(json.get(getInfo("map"),"grid"),"units per cell")]
}; {
	[thisMapLinks = "{}"]
}]

<!-- LINKED PADS -->
[h:linkedPads				= json.get(getLibProperty("linkedMappedPads", "lib:EventMacros"), getCurrentMapName())]
[h,if(!json.isEmpty(linkedPads)), CODE:{
	[lastLinkId				= getLibProperty("lastLinkId","lib:EventMacros")]
	[startLinkId			= ""]
	[endLinkId				= ""]
	[linkedIdList			= json.fields(linkedPads)]
	[foreach(id, linkedIdList): set("activated"+id, 0)]
};{}]

<!-- retrieve current location of token, if the token has not actually moved abort if that toggle is turned off in the settings-->
[h:resetMove					= 0]
	

	
	

	
	[h,if(!doTriggerOnZeroMove && json.length(lastPath)==1):abort(0)]

	<!-- handle SPECIAL AREAS -->
	[h:ignoreStartPath		= json.remove(lastPath,0)]
	[h,foreach(areaName, thisMapLinks): bot_EventArea()]

	<!-- handle all starting position pads-->
	[r,foreach(padName, firstPointPadList,""):	eval("bot_"+getGroup(strfind(padName, "[A-z]+"), 1,0)+"()")]
	<!-- handle all Path related pads-->
	[r,foreach(padName, pathPadList,""):		eval("bot_"+getGroup(strfind(padName, "[A-z]+"), 1,0)+"()")]
	<!-- handle all ending position pads-->
	[r,foreach(padName, lastPointPadList,""):	eval("bot_"+getGroup(strfind(padName, "[A-z]+"), 1,0)+"()")]
	<!-- Centre of Token -->
	[h,if(doCentreOnTok):goto(getTokenX(0), getTokenY(0))]
	<!-- execute a linked event from the settings -->
	[h,if(eventMacroPostTokenMove != "<none>"), CODE:{[macro(eventMacroPostTokenMove+"@Lib:EventMacros"): json.append("", tok)]}; {}]
	[h,if(!json.isEmpty(linkedPads)):setLibProperty("lastLinkId", endLinkId, "lib:EventMacros")]

@@deferOnTokenMove TMP
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy=3 ; color=silver ; playerEditable=false ; applyToSelected=false ; group=2. onTokenMove ; tooltip= ; minWidth=193 ; 
[h:'<!-- deferOnTokenMove - this macro is run automatically if ONE token is moved -->']
[h:'<!-- -----------------------------------INITIALIZE-----------------------------------------------']
<!-- The reason for the strange layout of this code is so that it aligns with onMultipleOntokenmove, which makes it easier to compare the two codes-->
<!-- VARS: tok,tokId,map,libCoordName,lastPath,isAltInit,lastPPath,usedMove,doAbort,doShowPath -->
[h: vars				= arg(0)]
[h: varsFromStrProp(vars)]
<!-- @@@@This is a work around due to a varsfromstrpop bug where in case of e.g. an id 000010000 is truncated to 100000 -->
[h: tokId	= string(getStrProp(vars, "tokId"))]

[h: switchToken(tok)]

<!-- define the following vars:  doGroups,doResetFoW,doVBLCheck,doTriggerOnZeroMove,doCentreOnTok,doSpecialPads,doFirstPointPath,doInnerPointsPath,limitMovement,eventMacroOnTokenMove, eventMacroOnMultipleTokensMove, eventPreMacroTeleport, eventPostMacroTeleport, eventMacroPreInterTeleport, eventMacroPostInterTeleport, eventMacroPostTokenMove, eventMacroPostMultipleTokensMove,movementLock,doVBLStamp -->
[h: varsFromStrProp(arg(1))]

<!-- group movement -->
[h,if(doGroups && startsWith(token.label,"group")), CODE:{
	[groupName			= token.label]
	[startingLocation	= json.toList(json.get(lastPath,0,0))]
	[currentLocation	= json.toList(json.get(lastPath,-1,-1))]
	[xDiff				= json.get(currentLocation, "x") - json.get(startingLocation, "x")]
	[yDiff				= json.get(currentLocation, "y") - json.get(startingLocation, "y")]
	[tokList			= getProperty("w42.boT."+token.label)]
	[foreach(tmpTok,tokList), CODE:{
		[token(tmpTok), if(findToken(tmpTok) != ""):moveToken(getTokenX()+xDiff, getTokenY()+yDiff)]
	}]
}]

<!-- execute a linked event from the settings -->
[r, if(eventMacroOnTokenMove != "<none>"), CODE:{[macro(eventMacroOnTokenMove+"@Lib:EventMacros"): json.append("", tok)]}; {}]

<!-- AMs VBL Checker -->
[h,if(doVBLCheck):bot_moveVBLToken(tokId, lastPath)]

<!-- Align VBL Stamps with moved token-->
[h: doVBLStamp = if(doVBLStamp && json.type(getProperty("w42.bot.fgVBL"))=="ARRAY", 1, 0)]
[h,if(doVBLStamp), CODE:{
	<!-- any token with the label VBLStamp will have a VBL cross that moves with the token -->
	<!-- if a VBL cross is already there, remove it first (its params are stored on the token) -->
	<!-- createVBL defines x, y,etc. and vblPresent is its stored on token -->
	[bot_moveStamp(tok)]
	[if(doResetFoW): exposePCOnlyArea()]
}; {}]

<!-- put small feet in the moved path -->
[h,if(doShowPath && isSnapToGrid()):bot_getPath(doShowPath, 1, tok, lastPath)]

<!-- abort if special pads are turned off -->
[h:abort(doSpecialPads)]

[h,if(isAltInit), CODE:{
	[mappedCoords 	= getLibProperty("mappedCoords", libCoordName)]
	[allCoordsArray	= getLibProperty("allCoordsArray", libCoordName)]
	<!-- turn all mapped coordinates of the special tokens into active variables e.g. X1Y5 = "Canopy 12" -->
	[varsFromStrProp(mappedCoords, "UNSUFFIXED")]

	
	<!-- if token has not moved but just "wobbled" there will be 1 coordinate == listSize(2) abort in this case -->
	[abort(if(listCount(json.fromList(lastPPath))<3,0,1))]
	[oneStepOnly = if(listCount(json.fromList(lastPPath))<5,1,0))]
	

	<!-- GET THE PADS OVER WHICH THE TOKEN MOVED, START, MIDDLE AND END -->
	<!-- if the token walks over a pad that stops it in its path, then discard the remainder of the path -->
	<!-- this macro also runs pathPadList = bot_path2pads(json.get(lastPPath,1,-2)), which needs to be rebuild is !clear -->

	
	
	
	
	
		[if(!oneStepOnly && doInnerPointsPath):	bot_chkMoveStop(); pathPadList = ""]
		<!-- added clear = 0 as its clearly not initialized. Need more infor on clear as its unclear what it does... god the pun... -->
		[if(oneStepOnly):	clear = 1 ; clear = 0]

		
	[lastPointPadList		= bot_path2pads(json.get(lastPPath,-1,-1))]

	
	<!-- FILTER OUT ONLY THOSE PAD THAT NEEDS TO BE CHECKED FOR EITHER START OR MIDDLE. End is checked for all!! -->
	[if(doFirstPointPath), CODE:{
		<!-- check if token is on a relevant token when leaving -->
		[firstPointPadList		= bot_path2pads(json.get(lastPPath,0,0))]
		[firstPointPadCheckList = "Canopy, Foliage, Roof, EventPad"]
		[padTypeList			= replace(firstPointPadList, " [0-9]+", "")]
		[oldPadList				= firstPointPadList]
		[firstPointPadList		= ""]
	}; {
		[padTypeList 			= ""]
		[firstPointPadList		= ""]
	}]
	[for(i, 0, listCount(padTypeList)), CODE:{
		[check = listContains(firstPointPadCheckList, listGet(padTypeList, i))]
		[if(check): firstPointPadList = listAppend(firstPointPadList, listGet(oldPadList, i))]
	}]

	[if(doInnerPointsPath), CODE:{
		<!-- check if a token walks over a relevant pad -->
		[if(!clear):pathPadList = bot_path2pads(json.get(lastPPath,1,-2))]
		[pathPadCheckList		= "Ward, EventPad, PadJumpBorder, InterJumpBorder, PadStartBorder, PadEndBorder, InterPadBorder"]
		[padTypeList			= replace(pathPadList, " [0-9]+", "")]
		[oldPadList				= pathPadList]
		[pathPadList			= ""]
	}; {
		[padTypeList 			= ""]
		[pathPadList			= ""]
	}]
	[for(i, 0, listCount(padTypeList)), CODE:{
		[check = listContains(pathPadCheckList, listGet(padTypeList, i))]
		[if(check): pathPadList = listAppend(pathPadList, listGet(oldPadList, i))]
	}]
}; {
	<!-- if the list is build traditionally -->
	[allMapsPads = getLibProperty("allMapsPads", "lib:EventMacros")]
	[if( json.type(allMapsPads) != 'OBJECT' ), CODE:{
		[broadcast("The pads of this campaign are not initialized yet, doing so now...")]
		[bot_initializePads()]
		[allMapsPads = getLibProperty("allMapsPads", "lib:EventMacros")]
	}; {}]
	[abort(json.contains(allMapsPads,getCurrentMapName()))]
	[pathPadList				= json.get(allMapsPads, getCurrentMapName())]
	[firstPointPadList			= ""]
	[lastPointPadList			= ""]
}]

[h:'<!-- -----------------------------------/INITIALIZE------------------------------------------------->']

<!-- SPECIAL AREAS -->
[h: linkedAreas = getLibProperty("linkedAreas", "lib:EventMacros")]
[h,if(json.contains(linkedAreas, map)), CODE:{
	[thisMapLinks			= json.get(linkedAreas, map)]
	[thisMapAreas			= json.get(getLibProperty("storedAreas","lib:EventMacros"),map)]
	<!-- distance per cell e.g. 5ft per cell then walking 2 cells will result in 10 -->
	[DpC					= json.get(json.get(getInfo("map"),"grid"),"units per cell")]
}; {
	[thisMapLinks = "{}"]
}]

<!-- LINKED PADS -->
[h:linkedPads				= json.get(getLibProperty("linkedMappedPads", "lib:EventMacros"), getCurrentMapName())]
[h,if(!json.isEmpty(linkedPads)), CODE:{
	<!-- lastLinkSettings:"currentMap=;lastLinkId=" -->
	[lastLinkSettings		= getLibProperty("lastLinkSettings","lib:EventMacros")]
	[varsFromStrProp(lastLinkSettings)]
	[startLinkId			= ""]
	[endLinkId				= ""]
	[linkedIdList			= json.fields(linkedPads)]
	[if(getCurrentMapName() != currentMap), CODE:{
		<!-- this routine only takes place when swapping from maps -->
		[currentMap			= getCurrentMapName()]
		[lastLinkId			= ""]
		[lastLinkSettings	= strPropFromVars("currentMap, lastLinkId","UNSUFFIXED")]
		[foreach(id, linkedIdList): lastLinkSettings = setStrProp(lastLinkSettings, "activated"+id, 0)]
		<!-- then make sure that the activated variables are defined -->
		[varsFromStrProp(lastLinkSettings)]
		<!-- retrieve the variables in the strproplist as a list -->
		[strPropList		= listAppend(json.fields(json.fromStrProp(lastLinkSettings)), "strPropList")]
		<!-- and add it to the settings -->
		[lastLinkSettings	= setStrProp(lastLinkSettings, "strPropList", strPropList)]
		<!-- result: currentMap=BASE ; lastLinkId= ; activated1=0 ; activated2=0 ; activated3=0 ; strPropList=lastLinkId,currentMap,activated1,activated2,activated3 -->
	}]
	[foreach(id, linkedIdList): set("activated"+id, 0)]
	['pause("activated1", "activated2", "linkedIdList")']
};{}]

<!-- retrieve current location of token, if the token has not actually moved abort if that toggle is turned off in the settings-->
[h:resetMove					= 0]
	

	[h,if(!doTriggerOnZeroMove && json.length(lastPath)==1):abort(0)]

	<!-- handle SPECIAL AREAS -->
	[h:ignoreStartPath		= json.remove(lastPath,0)]
	[h,foreach(areaName, thisMapLinks): bot_EventArea()]

	<!-- handle all starting position pads-->
	[r,foreach(padName, firstPointPadList,""):	eval("bot_"+getGroup(strfind(padName, "[A-z]+"), 1,0)+"()")]
	<!-- handle all Path related pads-->
	[r,foreach(padName, pathPadList,""):		eval("bot_"+getGroup(strfind(padName, "[A-z]+"), 1,0)+"()")]
	<!-- handle all ending position pads-->
	[r,foreach(padName, lastPointPadList,""):	eval("bot_"+getGroup(strfind(padName, "[A-z]+"), 1,0)+"()")]
	<!-- Centre of Token -->
	[h,if(doCentreOnTok):goto(getTokenX(0), getTokenY(0))]
	<!-- execute a linked event from the settings -->
	[h,if(eventMacroPostTokenMove != "<none>"), CODE:{[macro(eventMacroPostTokenMove+"@Lib:EventMacros"): json.append("", tok)]}; {}]
	[h,if(!json.isEmpty(linkedPads) && lastLinkId != endLinkId), CODE:{
		[lastLinkId			= endLinkId]
		[lastLinkSettings	= strPropFromVars(strPropList,"UNSUFFIXED")]
		[setLibProperty("lastLinkSettings", lastLinkSettings, "lib:EventMacros")]
	};{}]
['pause("linkedPads","lastLinkId","startLinkId","endLinkId","lastLinkSettings","strPropList")']

@@determineTokSize
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=10 ; color=default ; playerEditable=false ; applyToSelected=false ; group=2. onTokenMove ; tooltip= ; minWidth=90 ; 
[h:'<!-- ---------------------- DETERMINETOKSIZE--------------------------- -->']

[if(getLibProperty('vblSupport','lib:EventMacros')), CODE:{
	<!-- if new functions are allowed -->
	[h:gridSize	= json.get(json.get(getInfo("map"), "grid"), "size")]
	[xtmp	= getTokenWidth()]
	[ytmp	= getTokenHeight()]

	<!-- this is used for canopy and in that case its usefull to enlarge it by one cell  -->
	[xSize	= round(xtmp/gridSize) + 1]
	[ySize	= round(ytmp/gridSize) + 1]

	[setProperty("w42.bot.xSize", xSize,tok)]
	[setProperty("w42.bot.ySize", ySize,tok)]
};{
	<!-- if not, it has to be done manually -->
	[sizeList = "Fine=1; Diminutive=1; Tiny=1; Small=1; Medium=1; Large=2; Huge=3; Gargantuan=4; Colossal=6"]
	[xSize = getProperty("w42.bot.xSize",tok)]
	[ySize = getProperty("w42.bot.ySize",tok)]

	<!-- old method -->
	[if(xSize == ""): xSize = getProperty("w42.mtt.xSize",tok)]
	[if(ySize == ""): ySize = getProperty("w42.mtt.ySize",tok)]

	[size = getSize()]
	[if(size == ""), CODE:{
		[abort(input(
			"xSize|"+xSize+"|The size of token: "+tok+" is unknown, pls enter the width (from left to right) in number of cells",
			"ySize|"+ySize+"|The size of token: "+tok+" is unknown, pls enter the length (from top to bottom) in number of cells"
		))]		
	}; {
		[xSize = getStrProp(sizeList, size, "")]
		[ySize = getStrProp(sizeList, size, "")]
	}]

	[setProperty("w42.bot.xSize", xSize,tok)]
	[setProperty("w42.bot.ySize", ySize,tok)]
}]

@@initializeMap
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=7 ; color=default ; playerEditable=false ; applyToSelected=false ; group=2. onTokenMove ; tooltip=Show overview of special pads on map ; minWidth=90 ; 
[h:'<!-- ------------------------------------------------- initializeMap ([initialize]) --------------------------------------------------------------- -->']

[h,if(argCount() > 0): initialize	= arg(0) ; initialize = 0]

[h,if(!initialize), CODE:{
	[currentMap			= getCurrentMapName()]
	[padNameList 		= getLibProperty("padNameList", "lib:EventMacros")]
	[numericIdOnly		= getLibProperty("numericIdOnly", "lib:EventMacros")]
	[doCanopy			= 0]
	[interPadCheckList	= "{}"]
	[txtOutPut			= "<u>Found the following special pads:<br></u>"]
};{}]

[h:linkedList		= ""]
[h:linkedPadList	= ""]
[h:padCounter.json	= '{}']
[h:tokenList		= getTokenNames(",", '{layer:["TOKEN","GM","OBJECT","BACKGROUND"]}')]

<!-- check if this map is alt. initialized. If so warn the user to either exclude this map in the settings of remove the lib:coords -->
[h: libCoordName	= strformat("lib:Coords %{currentMap}")]
[h: error			= if(findToken(libCoordName) == "",0,1)]
[h,if(error): txtOutPut	= txtOutPut + "<font color='red'>Error: <u>"+libCoordName+"</u> found on map "+currentMap+". This means that the alternative initialization method is used for this map and that is NOT compatible with the normal initialization. So either:<br>- remove ALL lib:coords from this map (should only be one), which is usually located at coord 0,0. Or<br>- exclude this map from initialization in the settings --> exclusions --> check: <i>"+currentMap+"<br><br></i></font>"]

<!-- initialize list variables -->
[h, foreach(padName, padNameList), CODE:{
	[set("lst"+padName, "")]
	[set("lstName"+padName, "")]
}]
[h:newList		= ""]
[h:canopyList	= ""]

<!-- regex routine done by the_meek; few rewrites by W42
	1. create a json.array of ALL tokens on the map
	2. Loop through all special pads. Lets take 'PadStart x' as example. Keep in mind that its an array thus "","","" and the pad will thus start with "
	3. Matches checks if a search string matches with the string. If it returns 0 then there are no PadStart x on this map so you can skip this in the loop.
	4. sort the token array alphabetically in ascending order
	5. look for the current padname e.g. 'PadStart 2' 
	6. remove all items that come before PadStart 2
	7. sort in descending order
	8. again remove all items that come before Padstart 2
	9. what is left are all the 'PadStart' tokens in the list.
 -->
 
<!-- step 1. -->
[h: allTokensJson	= json.fromList(tokenList)]
[H: cleanTokenJSON	= "[]"]

<!-- step 2. -->
[H, FOREACH(padName, padNameList), CODE: {
	<!-- step 3. .*PadStart .* -->
	[tempRegex = '.*"' + padName + '\\s.*']
	[IF(matches(allTokensJson, tempRegex)), CODE:{
		<!-- step 4., 5. and 6. -->
		[tempRegex		= '\\[(.*?)("' + padName + '\\s.*)']
		[tempJSON		= replace(json.sort(allTokensJson, "a"), tempRegex, '[\$2')]
		<!-- step 7. and 8. -->
		[tempJSON		= replace(json.sort(tempJSON, "d"), tempRegex, '[\$2')]
		<!-- step 9. ; and add them to cleanTokenJSON -->
		[cleanTokenJSON	= json.sort(json.merge(cleanTokenJSON, tempJSON),"a")]
['pause("tempJSON","cleanTokenJSON","allTokensJson", "PadName", "padnamelist")']
	};{}]
}]

[h:'pause("cleanTokenJSON")']
[h:tokenList	= json.toList(cleanTokenJSON)]

[h:numToks		= listCount(tokenList)]
[h:assert(numToks <= 1000, "Fatal error: The number ("+numToks+") of special pads on map ("+currentMap+") is more than 1000. This tool can handle upto 1000 special pads. Please remove "+(numToks - 1000)+" pads from " + currentMap,0)]

[h,foreach(token,tokenList,""), CODE:{
	[pos	= indexOf(token, " ")]

	<!-- check if token exists -->
	[assert(findToken(token) != "", strformat("Error (Process aborted): could not find token <u>%{token}</u> on the current map. This might happens when you e.g. create a token with a reserverd name as partial string. For example '<b>The</b> Roof 1', will result in a token list with 'Roof 1' which does not exist, or when you accidentily use trailing spaces ' ', e.g. 'Roof 1 '. So check the map for this and correct it."),0)]
	
	[isPad	= 0]
	[if(pos != -1), CODE:{
		[padName	= substring(token, 0, pos)]
		[padId		= substring(token, pos)]
		<!-- if numericId only is checked, then only pads with a number as identifier should be parsed. The rest should be ignored -->
		[isPad		= if((isNumber(padId) || !numericIdOnly) && listContains(padNameList, padName),1,0)]
	}; {
		<!-- make sure value is initiated cause its used in one of the if statements -->
		[padName	= ""]
	}]
	
	[if(isPad && startsWith(padName, "Linked")), CODE:{
		<!-- with 'Linked 1 Canopy 2' pads you want to know that this concerns a Canopy pad -->
		<!-- Linked is a special case that requires a strict format. If this format is NOT met then isPad is set to 0 -->
		<!-- Linked 1 Roof 2, Match1 Match2 Match3 Match4 -->
		[regId		= strfind(token, "[^\\s]+")]
		[nPieces	= getFindCount(regId)]
		[error		= if(nPieces != 4, 1, 0)]
		[if(error): txtOutPut	= txtOutPut + "<font color='red'>Error: <u>"+token+"</u> found on map "+currentMap+" is incorrectly named. A linked pad should ALWAYS consist out of 4 pieces 'Linked ID PadTyp ID', e.g. 'Linked 1 Canopy 2'. This name consists out of "+nPieces+" pieces.<br></font>"]
		[if(error): PadType		= padName ; PadType = getGroup(regId, 3, 0)]
		[if(error): isPad		= 0]

		<!-- add link id to the list and also create a full list of all linked pads-->
		[if(!error): linkedList 	= listAppend(linkedList, getGroup(regId, 2, 0))]
		[if(!error): linkedPadList	= listAppend(linkedPadList, token)]
	}; {
		[PadType	= padName]
	}]

		
['pause("pos","padName","isPad","padNameList","padName","padId")']
	[if(isPad), CODE:{
		<!-- this is the main part where the json structure is build from which onTokenMove retrieves its values -->
		[tmpNum		= padId]
		[tmpLst		= eval("lst"+padName)]
		[tmpLstName	= eval("lstName"+padName)]
		
		[if(listContains(tmpLst, tmpNum)): error = 1]
		[if(listContains(tmpLst, tmpNum)): txtOutPut = txtOutPut + "<font color='red'>Error: duplicate <u>"+padName+" "+tmpNum+"</u> found on map "+currentMap+"<br></font>"]
		
		<!-- create two lists, one with numbers only one with the full names-->
		[set("lst"+padName, listAppend(tmpLst, tmpNum))]
		[set("lstName"+padName, listAppend(tmpLstName, token))]
	}; {}]
	
	[if(isPad && startsWith(padName, "Inter")), CODE:{
		<!-- interpads must be checked through all the maps: checkInterpads checks if there are 3 interpads with the same number -->
		[if(bot_inStr(token, "Drop")): fullPadName = replace(token,"Drop","Jump"); fullPadName 	= token]
		
		[bot_checkInterPads()]
		[if(json.contains(interPadCheckList, fullPadName)):	
			interPadCheckList = json.set(interPadCheckList, fullPadName, json.set(json.get(interPadCheckList, fullPadName), "map2", currentMap))
		; 
		interPadCheckList = json.set(interPadCheckList, fullPadName, json.set('{}', "map1", currentMap))
		]
	}; {}]

	[if(isPad && (padType == "Canopy") && doCanopy), CODE:{
		<!-- canopy needs extra work cause the token handout gets a trunk image assigned -->
		<!-- get an random asset id of one of the tree trunks -->
		[treeTrunkkAssetID = listGet(treeTrunkImages, roll(1,numTrunkImages) - 1)]
		[token(token): handout = getTokenHandout()]
		[token(token), if(handout == ""): setTokenHandout(treeTrunkkAssetID); canopyList = listAppend(canopyList, tmpNum)]
	}]

	[if(isPad && padName == "Roof"), CODE:{
		<!-- extra check for roofs, which should NOT be snapped to grid -->
		[if(isSnapToGrid(token)): error = 1]
		[if(isSnapToGrid(token)): txtOutPut = txtOutPut + "<font color='red'>Error: <u>"+padName+" "+tmpNum+"</u> found on map "+currentMap+" is snapped to grid. Make certain its unsnapped<br></font>"]
	}]
['pause("cleanTokenJSON","padNameList", "padName", "token", "tokenList", "isPad", "tmpLstName")']
}]

[h, if(listCount(canopyList)): txtOutPut = txtOutPut + "The following Canopy Pads already had an image in the Token Handout Section. No (new) trunk image has been set for <b><u>Canopy</u></b> : "+canopyList+"<br>"]

<!-- loop through all the special pads names and generate output to the text -->
[h:result = "<a href='macro://gotoToken@lib:OnTokenMove/none/impersonated?[&quot;%{currentMap}&quot;, &quot;%s&quot;, &quot;3&quot;, &quot;0&quot;, &quot;0&quot;]'>%s</a>"]
[h, foreach(padName, padNameList,""), CODE:{
	<!-- list of numbers of special pads found e.g. 1,2,3,etc-->
	[tmpLst = listSort(eval("lst"+padName),"N+")]
	<!-- list of full padnames e.g. Canopy 1, Canopy 2, etc -->
	[tmpLstName = listSort(eval("lstName"+padName),"N+")]
	
	[if(tmpLst != ""), CODE:{
		[txtOutPut = txtOutPut + "<b>"+padName+"</b>: "]
		[tmpURLList = ""]
		[foreach(pad, tmpLst): tmpURLList	= listAppend(tmpURLList, strformat(result, padName + " " + pad, pad))]
		[txtOutPut = txtOutPut + tmpURLList + "<br>"]
	};{}]
	<!-- build the json object, add the list of full padnames and their numbers e.g. Canopy 1, Canopy 2, etc. -->
	<!-- do not add padDrop and interDrop -->
	[isDrop = if(startsWith(padName,"PadDrop") || startsWith(padName, "InterDrop"), 1, 0)]
	[if(!isDrop):padCounter.json = json.set(padCounter.json, padName, tmpLstName)]
['pause("padNameList", "padName", "padCounter.json", "tmpLstName")']
}]

<!-- check if there are an equal amount of starting teleports and ending teleports on one map and if the numbers match -->
[h:startPads= eval("lstPadStart")]
[h:endPads	= eval("lstPadEnd")]
[h:numStart	= listCount(startPads)]
[h:numEnd	= listCount(endPads)]

[h, if(numStart != numEnd), CODE:{
	 [error = 1]
	 [txtOutPut = txtOutPut + "<font color='red'>Error: there are an unequal amount of <b>PadStart("+numStart+")</b> and <b>PadEnd("+numEnd+")</b> tokens found on map "+currentMap+"<br></font>"]
}; {
	[foreach(pad, startPads), CODE:{
		[exists = findToken("PadEnd " + pad)]
		[if(!exists): error = 1]
		[if(!exists): txtOutPut = txtOutPut + "<font color='red'>Error: <b>PadStart "+pad+"</b> does not have a <b>PadEnd "+pad+"</b> on map "+currentMap+"<br></font>"]
	}]
	[foreach(pad, endPads), CODE:{
		[exists = findToken("PadStart " + pad)]
		[if(!exists): error = 1]
		[if(!exists): txtOutPut = txtOutPut + "<font color='red'>Error: <b>PadEnd "+pad+"</b> does not have a <b>PadStart "+pad+"</b> on map "+currentMap+"<br></font>"]
	}]
}]

<!-- check if there are an equal amount of starting teleport borders and ending teleport borders on one map and if the numbers match -->
[h:startPadBorders	= eval("lstPadStartBorder")]
[h:endPadBorders	= eval("lstPadEndBorder")]
[h:numStartBorder	= listCount(startPadBorders)]
[h:numEndBorder		= listCount(endPadBorders)]

[h, if(numStart != numEnd), CODE:{
	 [error = 1]
	 [txtOutPut = txtOutPut + "<font color='red'>Error: there are an unequal amount of <b>PadStartBorder("+numStartBorder+")</b> and <b>PadEndBorder("+numEndBorder+")</b> tokens found on map "+currentMap+"<br></font>"]
}; {
	[foreach(pad, startPadBorders), CODE:{
		[exists = findToken("PadEndBorder " + pad)]
		[if(!exists): error = 1]
		[if(!exists): txtOutPut = txtOutPut + "<font color='red'>Error: <b>PadStartBorder "+pad+"</b> does not have a <b>PadEndBorder "+pad+"</b> on map "+currentMap+"<br></font>"]
	}]
	[foreach(pad, endPadBorders), CODE:{
		[exists = findToken("PadStartBorder " + pad)]
		[if(!exists): error = 1]
		[if(!exists): txtOutPut = txtOutPut + "<font color='red'>Error: <b>PadEndBorder "+pad+"</b> does not have a <b>PadStartBorder "+pad+"</b> on map "+currentMap+"<br></font>"]
	}]
}]

<!-- check if there are an equal amount of jump teleports and drop teleports on one map and if the numbers match -->
[h:jumpPads	= eval("lstPadJump")]
[h:dropPads	= eval("lstPadDrop")]
[h:numJump	= listCount(jumpPads)]
[h:numDrop	= listCount(dropPads)]

[h, if(numJump != numDrop), CODE:{
	 [error = 1]
	 [txtOutPut = txtOutPut + "<font color='red'>Error: there are an unequal amount of <b>PadJump("+numJump+")</b> and <b>PadDrop("+numDrop+")</b> tokens found on map "+currentMap+"<br></font>"]
}; {
	[foreach(pad, jumpPads), CODE:{
		[exists = findToken("PadDrop " + pad)]
		[if(!exists): error = 1]
		[if(!exists): txtOutPut = txtOutPut + "<font color='red'>Error: <b>PadJump "+pad+"</b> does not have a <b>PadDrop "+pad+"</b> on map "+currentMap+"<br></font>"]
	}]
	[foreach(pad, dropPads), CODE:{
		[exists = findToken("PadJump " + pad)]
		[if(!exists): error = 1]
		[if(!exists): txtOutPut = txtOutPut + "<font color='red'>Error: <b>PadDrop "+pad+"</b> does not have a <b>PadJump "+pad+"</b> on map "+currentMap+"<br></font>"]
	}]
}]

[h:jumpBorderPads	= eval("lstPadJumpBorder")]
[h:dropBorderPads	= eval("lstPadDropBorder")]
[h:numJumpBorder	= listCount(jumpBorderPads)]
[h:numDropBorder	= listCount(dropBorderPads)]

[h, if(numJumpBorder != numDropBorder), CODE:{
	 [error = 1]
	 [txtOutPut = txtOutPut + "<font color='red'>Error: there are an unequal amount of <b>PadJumpBorder("+numJumpBorder+")</b> and <b>PadDropBorder("+numDropBorder+")</b> tokens found on map "+currentMap+"<br></font>"]
}; {
	[foreach(pad, JumpBorderPads), CODE:{
		[exists = findToken("PadDropBorder " + pad)]
		[if(!exists): error = 1]
		[if(!exists): txtOutPut = txtOutPut + "<font color='red'>Error: <b>PadJumpBorder "+pad+"</b> does not have a <b>PadDropBorder "+pad+"</b> on map "+currentMap+"<br></font>"]
	}]
	[foreach(pad, DropBorderPads), CODE:{
		[exists = findToken("PadJumpBorder " + pad)]
		[if(!exists): error = 1]
		[if(!exists): txtOutPut = txtOutPut + "<font color='red'>Error: <b>PadDropBorder "+pad+"</b> does not have a <b>PadJumpBorder "+pad+"</b> on map "+currentMap+"<br></font>"]
	}]
}]

<!-- process linked lists -->
[h:linkedJson		= '{}']
<!-- retrieve all linked pads for this map -->
[h:allLinksList	= json.get(padCounter.json, "Linked")]
[h,if(listCount(linkedList)), CODE:{
	[foreach(linkId, linkedList), CODE:{
		[regex		= strformat("(?i)([^,]*(Linked %{linkId})[^,]*)")]
		[resultList	= ""]
		[id			= strfind(allLinksList, regex)]
		[numFound	= getFindCount(id)]
		[count(numFound):	resultList	= listAppend(resultList, getGroup(id, roll.count+1, 0))]
		[linkedJson	= json.set(linkedJson, linkId, resultList)]
	}]
};{}]

<!-- set the main json object for this map -->
[h,if(initialize):newMapsPads		= json.set(newMapsPads, currentMap, padCounter.json)]

<!-- set the linked json object for this map -->
[h,if(initialize):linkedMappedPads	= json.set(linkedMappedPads, currentMap, linkedJson)]

[h:'pause("newMapsPads","padCounter.json")']
[h, if(error): txtOutPut = txtOutPut + "Error detected, please fix first, else errors will occur on this map ("+currentMap+") will work<br>"; "No errors detected, pads have been initialized<br>"]

[h,if(!initialize), CODE:{
	<!-- create the frame -->
	[frame("Special Tokens on "+currentMap, "width=300; height=400; temporary=1"): {
		<html>
			<head>
			</head>
			<body>
				<form action='[r:macroLinkText("initializeMap@Lib:OnTokenMove", "none")]' method="json">
				[r:txtOutPut]
				<input type="submit"	name="button"	value="Refresh"	>
			</form>
			</body>
		</html>
	}]
};{}]

@@initializePads
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=6 ; color=default ; playerEditable=false ; applyToSelected=false ; group=2. onTokenMove ; tooltip= ; minWidth=90 ; 
[h:'<!-- ----------------------------- initializePads --------------------------------->']
<!-- 3 CODE LEVELS -->
[h, if(argCount()):passResult = arg(0); passResult = 0]
[h:mapList			= getAllMapNames("json")]
[h:oldMap			= getCurrentMapName()]
[h:'<!-- make certain that ward and eventpad are dealt with first!! -->']
[h:padNameList 		= getLibProperty("padNameList", "lib:EventMacros")]
[h:newMapsPads		= '{}']
[h:allMappedPads	= '{}']
[h:linkedMappedPads	= '{}']
<!-- reset the lastlinksettings so the linke activepads are rebuild when ontokenmove is used -->
[h:setLibProperty("lastLinkSettings", "currentMap=;lastLinkId=", "lib:EventMacros")]
[h:txtOutput		= "<b><u><font color='red'>INITIALIZE PADS</font></u></b><br><br>"]
[h:interPadCheckList= "{}"]
[h:treeTrunkImages	= getLibProperty("treeTrunkImages", "lib:EventMacros")]
[h:numTrunkImages	= listCount(treeTrunkImages)]
[h:doCanopy			= 0]
[h:baseMapName		= getLibProperty("baseMapName", "lib:EventMacros")]
[h:numericIdOnly	= getLibProperty("numericIdOnly", "lib:EventMacros")]

<!-- doSwitchInterMap (if set to 2 then store x/y coords of interpads on eachother)-->
[h:toggles			= getLibProperty("toggles", "lib:EventMacros")]
[h:varsFromStrProp(toggles)]

[h:tmpList			= json.toList(mapList)]
[h, if(listContains(tmpList, baseMapName)), CODE:{
	[h, if(numTrunkImages), CODE:{
		[txtOutput	= txtOutput  + "'Trunk' images have been found and are initialized<br>"] 
		[doCanopy	= 1]
	}; {
		[txtOutput	= txtOutput  + "<font color='red'><b>No 'Trunk' images have been set (Run 'Choose Trunks' do so), so 'Canopy Tokens' will not be initialized!</b></font><br>"]
	}]
}; {
	[txtOutput	= txtOutput  + "<b><font color='red'>No map called "+ baseMapName +" found, so 'Canopy Tokens' will not be initialized! Also the Token Buttons (door switches) wont work correctly (you can set the correct name in the settings.)</b></font><br>"]
}]

[h:'<!-- check all tokens on all maps -->']
[h:excludedMaps	= getLibProperty("excludedMaps", "lib:EventMacros")]
[h:txtOutput	= txtOutput  + "The following maps will not be initialized (see settings): <b><u>"+json.toList(excludedMaps)+"</b></u><br><br>"]	
[H:activeMaps	= json.difference(mapList,excludedMaps)]

[H,foreach(currentMap,activeMaps), CODE:{
<!-- 3 CODE LEVELS -->
	[setCurrentMap(currentMap)]
	[txtOutput		= txtOutput  + "<b><u>"+currentMap+"</b></u.<br>"]	
	[bot_initializeMap(1)]
	
	<!-- initializeMappedPads -->
	[allMappedPads	= json.set(allMappedPads, currentMap, lstMappedPad)]
	[txtOutput		= txtOutput  + "<br>"]	
	
	<!-- linked id are all added resulting in e.g. 1,1,1,2,2,2,3,3,3 change into 1,2,3 -->
	[h:linkedList	= json.toList(json.unique(json.fromList(linkedList)))]
	
	<!-- reset any properties concerning linked pads on the tokens -->
	[h,foreach(tok,tokenList,""), CODE:{
		[resetProperty("w42.bot.linked",		tok)]
		[resetProperty("w42.bot.linkedBridge",	tok)]
		[resetProperty("w42.bot.linkedTunnel",	tok)]
		[resetProperty("w42.bot.linkedSpecial",	tok)]
	''
	}]
	
	<!-- initialize Linked Pads -->
	<!-- create list per linked type -->
	[h,foreach(linkId, linkedList), CODE:{
		[linkedAll		= ""]
		[linkedBridge	= ""]
		[linkedTunnel	= ""]
		[linkedSpecial	= ""]
		
		[foreach(pad, linkedPadList), if(startsWith(pad, "Linked "+linkId)), CODE:{
			[linkedAll		= listAppend(linkedAll, pad)]
			[if(bot_inStr(pad, "Bridge")):	linkedBridge	= listAppend(linkedBridge, pad)]
			[if(bot_inStr(pad, "Tunnel")):	linkedTunnel	= listAppend(linkedTunnel, pad)]
			<!-- for now only work for roof, canopy and foliage. Ignore the rest -->
			[PadType	= getGroup(strfind(pad, "[^\\s]+"), 3, 0)]
			[if(listContains("roof, canopy, foliage", PadType)):	linkedSpecial	= listAppend(linkedSpecial, pad)]
		''
		};{}]
		[set("linkedAll"		+ linkId, linkedAll)]
		[set("linkedBridge"		+ linkId, linkedBridge)]
		[set("linkedTunnel"		+ linkId, linkedTunnel)]
		[set("linkedSpecial"	+ linkId, linkedSpecial)]
	''
	}]
	<!-- assign entire linked type to each linked token -->
	[h,foreach(linkId, linkedList), CODE:{
		[linkedAll		= eval("linkedAll"		+linkId)]
		[linkedBridge	= eval("linkedBridge"	+linkId)]
		[linkedTunnel	= eval("linkedTunnel"	+linkId)]
		[linkedSpecial	= eval("linkedSpecial"	+linkId)]
		
		[foreach(pad, linkedPadList), if(startsWith(pad, "Linked "+linkId)), CODE:{
			[setProperty("w42.bot.linked",			linkedAll, pad)]
			[setProperty("w42.bot.linkedBridge",	linkedBridge, pad)]
			[setProperty("w42.bot.linkedTunnel",	linkedTunnel, pad)]
			[setProperty("w42.bot.linkedSpecial",	linkedSpecial, pad)]
		''
		};{}]
	''
	}]
''
}]

[h:'<!-- initializeInterPads -->']
[h, foreach(pad, interPadCheckList), CODE:{
	[padMaps		= json.get(interPadCheckList, pad)]
	[if(json.contains(padMaps, "map1")), CODE:{
		[map1		= 1]
		[mapName1 = json.get(padMaps, "map1")]
	''
	};{[map1		= 0][error	= 1]}]

	[if(json.contains(padMaps, "map2")), CODE:{
		[map2		= 1]
		[mapName2	= json.get(padMaps, "map2")]
	''
	};{[map2		= 0][error	= 1]}]
['if(!map1 || !map2):pause("map1","map2","pad","interPadCheckList","mapName1","mapName2", "padMaps")']
	[if(!map1): txtOutPut	= txtOutPut + "<font color='red'>Error: found only one <u>"+pad+"</u> on map " + mapName2 + "<br></font>"]
	[if(!map2): txtOutPut	= txtOutPut + "<font color='red'>Error: found only one <u>"+pad+"</u> on map " + mapName1 + "<br></font>"]

	[if(map1 && map2 && doSwitchInterMap == 2), CODE:{
		<!-- doSwitchInterMap (if set to 2 then store x/y coords of interpads on eachother)-->
		[setCurrentMap(mapName1)]
		[if(findToken(pad) != ""), CODE:{
			[x1	= getTokenX(0,pad)]
			[y1	= getTokenY(0,pad)]
			<!-- get the width and height of the pad in grid cell coords (so not in Pixels per cell) -->
			[wX	= getTokenWidth(pad)]
			[w1	= bot_ppc2GridCoord(wX)]
			[h1	= bot_ppc2GridCoord(getTokenHeight(pad))]
		''
		};{[x1=0][y1=0][w1=0][h1=0] <!-- required for interjump/drop where one pad is not registered -->}]

		[setCurrentMap(mapName2)]
		[if(findToken(pad) != ""), CODE:{
			[setProperty("w42.bot.pairedMap", mapName1, pad)]
			[setProperty("w42.bot.otherPadX", x1, pad)]
			[setProperty("w42.bot.otherPadY", y1, pad)]
			[setProperty("w42.bot.otherPadW", w1, pad)]
			[setProperty("w42.bot.otherPadH", h1, pad)]
			[x2	= getTokenX(0,pad)]
			[y2	= getTokenY(0,pad)]
			[w2	= bot_ppc2GridCoord(getTokenWidth(pad))]
			[h2	= bot_ppc2GridCoord(getTokenHeight(pad))]
		''
		};{[x2=0][y2=0][w2=0][h2=0] <!-- required for interjump/drop where one pad is not registered -->}]

		[setCurrentMap(mapName1)]
		[if(findToken(pad) != ""), CODE:{
			[setProperty("w42.bot.pairedMap", mapName2, pad)]
			[setProperty("w42.bot.otherPadX", x2, pad)]
			[setProperty("w42.bot.otherPadY", y2, pad)]
			[setProperty("w42.bot.otherPadW", w2, pad)]
			[setProperty("w42.bot.otherPadH", h2, pad)]
		''
		};{}]
	''
	};{}]
	
	[if(map1 && map2 && doSwitchInterMap != 2), CODE:{
		[setCurrentMap(mapName1)]
		[if(findToken(pad) != ""):setProperty("w42.bot.pairedMap", mapName2, pad)]
		[setCurrentMap(mapName2)]
		[if(findToken(pad) != ""):setProperty("w42.bot.pairedMap", mapName1, pad)]
	''
	};{}]
}]

[h:'<!-- initializeMappedPads -->']
<!-- build input string (allMappedPads contains all the mappedPads)-->
[h,FOREACH(mapJSON, allMappedPads), CODE:{
	[setCurrentMap(mapJSON)]
	[lstMapped	= json.get(allMappedPads, mapJSON)]
	<!-- get user input -->
	[inputStr	= "[]"]
	[inputStr	= json.append(inputStr,"junk|<html><b>Map the pads for map: "+mapJSON+"</b></html>|-|LABEL|SPAN=TRUE")]
	[inputStr	= json.append(inputStr,"junk|<html><b>enter numbers or dicerolls only!!</b></html>|-|LABEL|SPAN=TRUE")]
	[foreach(iMap, lstMapped), CODE:{
		[MappedPad	= getProperty("w42.bot.MappedPad", "MappedPad "+iMap)]
		[inputStr	= json.append(inputStr, "MappedPad"+iMap+"|"+MappedPad+"|Link MappedPad "+iMap+" to which other MappedPad")]
	}]
	[if(lstMapped != ""):hasInput = abort(input(json.toList(inputStr,"##")))]
	<!-- store the chosen values onto the pads -->
	[foreach(iMap, lstMapped):	setProperty("w42.bot.MappedPad", eval("MappedPad"+iMap), "MappedPad "+iMap)]
}]
[h:'<!-- return to original map and set the lib token var -->']
[h:setCurrentMap(oldMap)]

[h:'<!-- optimize the lists per map for fast processing on onTokenMove, this will destroy the json structure per padtype and makes lists from them -->']
[h:'<!-- newMapsPads is the entire json structure -->']
[h:oldMapsPads	= newMapsPads]
[h,FOREACH(mapJSONKey, oldMapsPads), CODE:{
	[pathPadList	= ""]
	[mapJSON		= json.get(oldMapsPads, mapJSONKey)]
	[foreach(padType, padNameList), CODE:{
		[tmpList	= json.get(mapJSON, padType)]
		[if(tmpList != ""): pathPadList	= listAppend(pathPadList, tmpList)]
	}]
	[newMapsPads	= json.set(newMapsPads, mapJSONKey, pathPadList)]
}]
[h:'pause("newMapsPads","oldMapsPads")']
[h:'<!-- if the initialize is run onCampaignLoad, it must only be set on the map where the lib token is currently situated, thus pass the result instead of setting it -->']
[h, if(passResult), CODE:{
	[macro.return = newMapsPads]
};{
	[setLibProperty("allMapsPads", newMapsPads,"lib:EventMacros")]
	[setLibProperty("allMapsPadsJson", oldMapsPads,"lib:EventMacros")]
	[setLibProperty("linkedMappedPads", linkedMappedPads,"lib:EventMacros")]
}]

[r,if(bot_isFullScreen()), CODE:{
	[r,dialog("Initialization result","input=1")	:{[r:txtOutPut]}]
};{
	[r,frame("Initialization result")				:{[r:txtOutPut]}]
}]

@@moveVBLToken
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=15 ; color=default ; playerEditable=false ; applyToSelected=false ; group=2. onTokenMove ; tooltip= ; minWidth=90 ; 
[h:'<!-- ---------------------------- moveVBLToken ---------------------------------------->']
<!-- NO NEW SCOPE -->
[H: id = arg(0)]
[H: path = arg(1)]
[H: switchToken(id)]
[H: pathLength = json.length(path)]
[H: hasVision = if(isPC(),1,0)]
<!-- Calc Size and center of token -->
<!-- Test FreeSize and make sure it works correctly -->
[H: tokenSizes = json.append("","Medium","Large","Huge","Gargantuan","FreeSize","Colossal")]
[H: tokenSizeMod = max(1,json.indexOf(tokenSizes,getSize(id))+1)]
[H: gridSize = json.get(json.get(getInfo("map"),"grid"),"size")]
[H: sizeInPixels = gridSize * tokenSizeMod]
[H: offset = round(sizeInPixels/2)]

<!-- Move token to first position -->
[H: firstPosition = json.get(path,0)]
[H: x = json.get(firstPosition,"x")]
[H: y = json.get(firstPosition,"y")]
[H: moveToken(x,y,1,id)]

<!-- Check if map clears soft fog on move -->
[H: clearSoftFog = doResetFoW]

<!-- loop through each step to verify it can be seen -->
[H: canSee = 1]
[H: counter = 0]
[H: movementStopped = -1]
[H, while(canSee && movementStopped), code: {
   [H, if(counter < pathLength): next = json.get(path,counter)]
   [H: x = json.get(next,"x")]
   [H: y = json.get(next,"y")]
   [H: canSee = isVisible(x+offset,y+offset)]
   [H, if(canSee), code: {
      [H: moveToken(x,y,1,id)]
      [H, if(hasVision): exposeFOW()]
   }; {
      [H, if(counter < pathLength): movementStopped = counter]
   }]
   [H, if(counter >= pathLength): canSee = 0]
   [H: counter = counter + 1]
}]

<!-- Check to teleport token to last position for GM move -->
[H: tport = 0]
[H: hasInput = 0]
[H, if(isGM() && movementStopped >= 0 && isPC()): hasInput = input(
	strformat("header|<html><font size=+3><b>%s</b></font></html> %s||LABEL|SPAN=TRUE ICON=TRUE",getName(),getTokenImage()),
	strformat("tip|<html><HR /><font size=+2 color=blue><b>&nbsp; &nbsp; &nbsp; &nbsp; Movement was stopped at step %{movementStopped}&nbsp; &nbsp; &nbsp; &nbsp; </b></font><HR /><BR /></html>||LABEL|SPAN=TRUE"),
	"tport|<html><font size=+1 color=red><b>NO</b></font>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </html>,<html><font size=+1 color=green><b>YES</b></font></html>|<html><font size=+1><b>T-port to final position?</b></html>|RADIO|ORIENT=H SELECT=1",
	strformat("clearSoftFog|<html><font size=+1 color=red><b>NO</b></font>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </html>,<html><font size=+1 color=green><b>YES</b></font></html>|<html><font size=+1><b>Clear Soft Fog on T-port?</b></html>|RADIO|ORIENT=H SELECT=%{clearSoftFog}")
)]
[H, if(tport && hasInput && isPC()), code: {
   [H: lastPosition = json.get(path,pathLength-1)]
   [H: x = json.get(lastPosition,"x")]
   [H: y = json.get(lastPosition,"y")]
   [H: moveToken(x,y,1,id)]
   [H, if(hasVision), code: {
      [H, if(clearSoftFog): exposePCOnlyArea(); exposeFOW()]
   }; {}]
}; {
    [H, if(isNPC() && isGM()), code: {
      <!-- Force NPCs to final location -->
      [H: lastPosition = json.get(path,pathLength-1)]
      [H: x = json.get(lastPosition,"x")]
      [H: y = json.get(lastPosition,"y")]
      [H: moveToken(x,y,1,id)]
   }; {}]
   [H, if(clearSoftFog && isPC() && hasVision): exposePCOnlyArea()]
}]

[H, if(movementStopped != -1 && ! isGM()): broadcast("<b>Movement stopped by VBL.  Try using [spacebar] to set way points.  You can not clip corners.</b>")]

<!-- This is needed to override the tokens.denyMove when using moveToken (draw order problem) -->
[H: z = eval("0"+getProperty("elevation"))]
<!-- set draw order based on x, y, z and token size -->
[H: drawOrder = (y + offset) * 1000 + (x + offset) - (tokenSizeMod -1) * gridSize + floor(z/5) * gridSize]
[H: setTokenDrawOrder(drawOrder,id)]

@@onMultipleTokensMove
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=2 ; color=red ; playerEditable=false ; applyToSelected=false ; group=2. onTokenMove ; tooltip= ; minWidth=193 ; 
[h:'<!-- ----------------------------- onMultipleTokenMove - this macro is run automatically if ONE token is moved ---------------------------------------------- -->']
[h: toks 				= macro.args]
[h: tok					= getName(json.get(toks, 0))]

[h:'<!-- retrieve: movementLock, doVBLCheck, doSwitchInterMap, doScaleTeleport, roofHaloColor, doResetFoW -->']
[h:toggles				= getLibProperty("toggles", "lib:EventMacros")]
[h:varsFromStrProp(toggles)]

[h:'<!-- execute a linked event from the settings -->']
[h, if(eventMacroPreTokenMove != "<none>"), CODE:{[macro(eventMacroPreTokenMove+"@Lib:EventMacros"): json.append("", tok)]}; {}]

[h:'<!-- check Lock if Lock Movement is on tokens.denymove does not work cause then all the tokens are moved back.-->']
[h,if(doLockMovement), CODE:{
	[tmpToks	= "[]"]
	[foreach(id, toks), CODE:{
		[token(id),if(getProperty("w42.bot.lockMovement", id)==1): moveToken(json.get(json.get(getLastPath(), 0),"x"), json.get(json.get(getLastPath(), 0),"y"))]
		[if(getProperty("w42.bot.lockMovement", id)!=1):tmpToks	= json.append(tmpToks, id)]
	}]
	[toks	= tmpToks]
};{}]

[h:'<!-- abort if a special pad was moved (only check first token) -->']
[h: abort(!listContains(excludePropertyTypes, getPropertyType(tok)))]

[h:'<!-- when using AMs VBL check, the movement of the tokens need to be reset and the redone with the vblMove macro -->']
[h: map					= getCurrentMapName()]
[h: libCoordName		= strformat("lib:Coords %{map}")]
[h: isAltInit			= if(findToken(libCoordName) == "",0,1)]
[h: doAbort				= 0]

[h:'<!-- buld a list of variables that contains the path info for each token -->']
[h: arguments 			= strPropFromVars("toks,map,libCoordName,isAltInit,doAbort","UNSUFFIXED")]
[h,foreach(tok, toks, ""), CODE:{
	[h: switchToken(tok)]
	[h: lastPath 		= getLastPath(1)]
	[h: startingLocation= json.toList(json.get(lastPath,0,0))]
	[h: currentLocation	= json.toList(json.get(lastPath,-1,-1))]
	[h:	usedMove		= getMoveCount()]

	[h: set("tok"				+roll.count, getName(tok))]
	[h: set("lastPath"			+roll.count, lastPath)]
	[h: set("startingLocation"	+roll.count, startingLocation)]
	[h: set("currentLocation"	+roll.count, currentLocation)]
	[h: set("usedMove"			+roll.count, usedMove)]
	[h, if(isAltInit): 
		set("lastPPath"			+roll.count, getLastPath(0))
	; 
		set("lastPPath"			+roll.count, "[]")
	]
	[h: tmpStrprop		= strPropFromVars(strformat("tok%{roll.count}, lastPath%{roll.count}, startingLocation%{roll.count}, currentLocation%{roll.count}, usedMove%{roll.count}"), "UNSUFFIXED")]
	[h: arguments		= listAppend(arguments, tmpStrProp, "; ")]
	[h:'<!-- movement limiter (uses doAbort) -->']
	[h,if(limitMovement):bot_limitMovement()]
}]
[h:'<!-- when using AMs VBL check, the movement of the tokens need to be reset and the redone with the vblMove macro -->']
[H, if(doVBLCheck): tokens.denyMove = 1]
[h, if(movementLock && !isGM() || doAbort), CODE:{
	[tokens.denyMove	= 1]
	[if(!doAbort): broadcast("<b>Movement is locked by GM.</b>")]
}; {
	<!-- restore FoW, this is also checked in doVBLCheck -->
	[if(doResetFoW && !doVBLCheck):exposePCOnlyArea()]
	[link				= macroLinkText("deferOnMultipleTokensMove@"+getMacroLocation(),"none",json.append("",arguments,toggles))]
	[execLink(link,1)]
}]

@@onTokenMove
@PROPS@ fontColor=yellow ; autoExecute=true ; fontSize=1.00em ; sortBy=1 ; color=red ; playerEditable=false ; applyToSelected=false ; group=2. onTokenMove ; tooltip= ; minWidth=193 ; 
[h:'<!-- ----------------------------- ONTOKENMOVE - this macro is run automatically if ONE token is moved ---------------------------------------------- -->']
[h,if (tokens.moveCount > 1): abort(0)]
[h:'<!-- @@@@ bug in getSelected: leading 0 in numerical id are discarded. So use getselectednames until fixed -->']
[h: tokId					= getSelectedNames()]
[h:'<!-- retrieve: movementLock, doVBLCheck, doSwitchInterMap, doScaleTeleport, roofHaloColor, doResetFoW -->']
[h:toggles				= getLibProperty("toggles", "lib:EventMacros")]
[h:varsFromStrProp(toggles)]

[h:'<!-- execute a linked event from the settings -->']
[h, if(eventMacroPreTokenMove != "<none>"), CODE:{[macro(eventMacroPreTokenMove+"@Lib:EventMacros"): json.append("", tok)]}; {}]

[h:'<!-- check Lock if Lock Movement is on -->']
[h,if(doLockMovement && getProperty("w42.bot.lockMovement")==1), CODE:{
	[moveToken(json.get(json.get(getLastPath(), 0),"x"), json.get(json.get(getLastPath(), 0),"y"))]
	[abort(0)]
};{}]

[h:'<!-- draw area toggle is ON -->']
[h, if(drawArea), CODE:{
	[token(tokId):area	= getLastPath(1)]
	<!-- dont draw the last entry (or the drawing token will get drowned-->
	[area			= json.get(area, 0,-2)]
	[area			= json.unique(area)]

	<!-- remove all coords which already have been drawn -->
	[tmpDraWArea	= getLibProperty("tmpDraWArea", "lib:EventMacros")]
	[area			= json.difference(area, tmpDrawArea)]
	<!-- store the new coords in a tmp -->
	[setLibProperty("tmpDraWArea", json.union(area, tmpDrawArea), "lib:EventMacros")]

	[layer			= getLayer(tokId)]
	[areaToken		= getLibProperty("drawTokenName", "lib:EventMacros")]
	[drawTokenMap	= getLibProperty("drawTokenMap", "lib:EventMacros")]
	[drawTokenName	= getLibProperty("drawTokenName", "lib:EventMacros")]
	
	[assert(!json.isEmpty(area), "that area contains no coordinates",0)]
	<!-- show all coords in the chat-->
	[h:broadcast("Area coordinates are: "+json.indent(area,2))]

	<!-- put an drawTokenName on each coord for visualisation-->
	<!-- create json splices to prevent the 1000 loop limit (-1 is the last entry in an array)-->
	[splices			= bot_createSplices(area)]
	<!-- loop through the splices and copy a token on each coord -->
	[foreach(splice, splices, ""), CODE:{
		[foreach(coord, splice, ""): lastCopy = copyToken(drawTokenName, 1, drawTokenMap, json.set(coord,"useDistance", 1, "layer", layer))]
	}]
	<!-- quit -->
	[abort(0)]
}]

[h:'<!-- abort excluded property type is moved -->']
[h: abort(!listContains(excludePropertyTypes, getPropertyType(tokId)))]

[h:'<!-- when using AMs VBL check, the movement of the tokens need to be reset and the redone with the vblMove macro -->']
[h: map					= getCurrentMapName()]
[h: libCoordName		= strformat("lib:Coords %{map}")]
[h: isAltInit			= if(findToken(libCoordName) == "",0,1)]
[h: doAbort				= 0]

	[h: lastPath		= getLastPath(1)]
	[h: startingLocation= json.toList(json.get(lastPath,0,0))]
	[h: currentLocation	= json.toList(json.get(lastPath,-1,-1))]
	[h:	usedMove		= getMoveCount()]

	[h, if(isAltInit): lastPPath = getLastPath(0); lastPPath = "[]"]

	[h:'<!-- movement limiter (uses doAbort) -->']
	[h,if(limitMovement):bot_limitMovement()]

[h:'<!-- when using AMs VBL check, the movement of the tokens need to be reset and the redone with the vblMove macro -->']
[H, if(doVBLCheck): tokens.denyMove = 1]
[h, if(movementLock && !isGM() || doAbort), CODE:{
	[tokens.denyMove 	= 1]
	[if(!doAbort): broadcast("<b>Movement is locked by GM.</b>")]
}; {
	<!-- restore FoW, this is also checked in doVBLCheck -->
	[if(doResetFoW && !doVBLCheck):exposePCOnlyArea()]
	[tok				= getName(tokId)]
	[link				= macroLinkText("deferOnTokenMove@"+getMacroLocation(),"none",json.append("",strPropFromVars("tok,tokId,map,libCoordName,lastPath,isAltInit,lastPPath,usedMove,doAbort,startingLocation,currentLocation","UNSUFFIXED"),toggles))]
	[execLink(link,1)]
}]

@@path2pads
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=13 ; color=default ; playerEditable=false ; applyToSelected=false ; group=2. onTokenMove ; tooltip= ; minWidth=90 ; 
[h:'<!-- PATH2PADS -->']
<!-- NO NEW SCOPE, IGNORE OUTPUT -->
<!-- this macro is fed by the path of the token and returns all the pads the token walked over in chronological order -->
[h:'<!-- turn lastpath, e.g.: [{"x":-1,"y":0},{"x":-1,"y":1},{"x":-1,"y":2}] into an array, with - replaced for _, e.g.: ["X_1Y0","X_1Y1","X_1Y2"] -->']
[h:lastPathJson		= replace(arg(0), '-', '_')]
[h:lastPathJson		= replace(lastPathJson, '\\{"x":(.*?),"y":(.*?)\\}', '"X\$1Y\$2"') ] 

<!-- then extract only the coords from the lastpath where a special pad is mapped -->
[h:pathIntersect	= json.intersection(allCoordsArray, lastPathJson)]

[h:'<!-- turn the json arrary path (pathIntersection) into an executable json object e.g. ["X_1Y0","X_1Y1","X_1Y2"] into ["[r:X_1Y0]","[r:X_1Y1]","[r:X_1Y2]"] -->']
[h:pathResult		= replace(pathIntersect, 		'"(.*?)"', '[r:\$1]')] 
[h:pathResult		= replace(pathResult,			'\\[\\[(.*?)\\]\\]', '["[\$1]"]')] 

<!-- execute json and filter out any double found special pads -->
[h:pathResult		= json.evaluate(pathResult)]
[h:pathResult		= replace(pathResult,		',', '","')]
[h:macro.return		= json.toList(json.unique(pathResult))]

@@animateMove
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=1 ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Animate Move ; tooltip= ; minWidth=90 ; 
[h:'<!-- --------------------------- animateMove --------------------------------------------->']
<!-- animateToken(OPTIONAL: 0.tokenID, 1.x, 2y, 3.relative,4.stopOnImpact(-1:bounce; 0=continue; 1=stop),5.layer(json.object),6.vbl(1; 0),7.delay(ms),8.distance,9.macroName (to run after 1 move),10.macroNameFinal (to run when animation is done),11.degrees rotation, 12.rotation steps, 13.move steps(in pixels, 0=in grid cells), 14.snap token to grid when done   ) -->
[h, if(argCount()>0):me				= arg(0); me			= getSelected()]
[h:assert(listCount(me)==1, "Make sure (only) one token is selected",0)]
[h:switchToken(me)]
[h, if(argCount()>3):relative		= arg(3); relative		= 0]
[h, if(argCount()>4):stopOnImpact	= arg(4); stopOnImpact	= 0]
[h, if(argCount()>5):layer			= arg(5); layer			= '["token","object"]']
[h, if(argCount()>6):vbl			= arg(6); vbl			= 0]
[h, if(argCount()>7):delay			= arg(7); delay			= 0]
[h, if(argCount()>8):distance		= arg(8); distance		= 0][h:'<!-- set a distance to travel regardless of end postition. -->']
[h, if(argCount()>9):runMacro		= arg(9); runMacro		= 0] 
[h, if(argCount()>10):runMacroFinal	= arg(10); runMacroFinal= 0] 
[h, if(argCount()>11):dr			= arg(11); dr			= 0] 
[h, if(argCount()>12):rStep			= arg(12); rStep		= 5] 
[h, if(argCount()>13):dStep			= arg(13); dStep		= 0] 
[h, if(argCount()>14):snap2Grid		= arg(14); snap2Grid	= 0] 

[h:'<!-- this arg runs a macro after EVERY move step. With this you can plug in stuff like e.g scan area after move or move other tokens as well. Note that any output of this macro is ignored. Use broadcast if you want to send something to the chat the macro string should be a standard [runthis(arg, arg)] -->']
[h, if(runMacro == ""):			runMacro		= 0]
[h, if(runMacroFinal == ""):	runMacroFinal	= 0]

[h, if(argCount()>2), CODE:{
	<!-- if dStep = 0 get Grid Coord, is <> 0 get pixel coord -->
	[x1  = if(relative, arg(1) + getTokenX(dStep), arg(1))]	  
	[y1  = if(relative, arg(2) + getTokenY(dStep), arg(2))]	  
}; {
	[abort(input(	
					"junk|<html><b>You have the following options, the Token travels:<br>- to the given coords (relative unchecked; distance=0)<br>- the relative distance (relative checked; distance=0)<br>- in the direction of the exact coords to distance=n (relative unchecked)<br>- in the direction of the relative coords to distance=n (relative checked)<br></b></html>|-|LABEL|SPAN=TRUE",
					"x1|0|<html><b>X</b> New coordinate of token (in grid coords if D-stepsize=0, else in pixel coords)",
					"y1|0|<html><b>Y</b> New coordinate of token (dito X)",
					"dStep|0|<html><b>D-Stepsize</b> 0=step per cell, >0=per that many pixels",
					"dr|180|<html><b>R</b> Degrees it rotates",
					"rStep|5|<html><b>R-Stepsize</b> Degrees per step (the higher the faster)",
					"distance|0|<html><b>Distance</b> the token travels",
					"relative|1|<html><b>Relative</b> to current position|CHECK",
					"snap2Grid|0|<html><b>Snap token</b> to grid when done|CHECK",
					"stopOnImpact|Bounce, Continue, Stop|What should it do when it hits something|RADIO|SELECT=1",
					"delay|0|Set delay per step",
					"junk|<html><b>Which layers should be checked for bounce or stop on impact?</b><br><i>Note that checking the four 'Token' layers can slow the animation<br>down considerably</html>|-|LABEL|SPAN=TRUE",
					"Token|0|Token Layer|CHECK",
					"Hidden|0|Hidden Layer|CHECK",
					"Object|0|Object Layer|CHECK",
					"Background|0|Background Layer|CHECK",
					"vbl|1|Vision Blocking Layer (Token MUST have vision!!)|CHECK"
	))]
	[stopOnImpact	= stopOnImpact - 1]
	[layer 			= "[]"]
	[if(Token):			layer = json.append(layer, "Token")]
	[if(Hidden):		layer = json.append(layer, "Hidden")]
	[if(Object):		layer = json.append(layer, "Object")]
	[if(Background):	layer = json.append(layer, "Background")]

	[if(relative), CODE:{
		[x1  = x1 + getTokenX(dStep))]	  
		[y1  = y1 + getTokenY(dStep))]	  
	}; {}]
}]

[h:x0		= getTokenX(dStep)]	  
[h:y0		= getTokenY(dStep)]
[h:r0		= bot_getTokenFacing(me, 1)]
[h:dx		= abs(x1 - x0)]
[h:dy		= abs(y1 - y0)]
[h:x		= x0]
[h:y		= y0]
[h:r		= r0]
[h:n 		= if(!distance, 1 + dx + dy, 0)]
[h:xInc		= if(x1 > x0, max(1, dStep - 1), -max(1, dStep - 1))]
[h:yInc		= if(y1 > y0, max(1, dStep - 1), -max(1, dStep - 1))]
[h:error	= dx - dy]
[h:dx		= 2 * dx]
[h:dy		= 2 * dy]
[h:direction= ""]
[h:lastDiag	= 0]
[h:steps	= 0]
[h,if(dr && !rStep): dr = 0]

[h:check = if(dx < dy, "X", "Y")]
[h:'<!-- set lastTime to 0 so that each client will get its own time!! -->']
[h:lastTime = 0]
[h:gridSize = json.get(json.get(getInfo("map"),"grid"),"size")]

[h:'<!-- initialize the animation on every pc/client/user -->']
[h:onlinePlayers		= getAllPlayerNames()]
[h:initiator			= getPlayerName()]
[h:animationPerClient	= getLibProperty("animationPerClient", "lib:EventMacros")]
[h:oldOwners 			= isOwnedByAll()]
[h,if(oldOwners): oldOwners = json.fromList(onlinePlayers); oldOwners = json.fromList(getOwners())]

[h,if(animationPerClient), CODE:{
	[otherPlayers = listDelete(onlinePlayers, listFind(onlinePlayers, initiator))]
	[setOwner(initiator, me)]
	[setOwnerOnlyVisible(1, me)]
}; {
	[otherPlayers = ""]
}]
[h:mainMe = ""]

[h:args = strPropFromVars("me, mainMe, initiator, oldOwners, n, x, y, r, dx, dy, dr, dStep, rStep, xInc, yinc, steps, distance, lastDiag, check, direction, error, stopOnImpact, layer, vbl, gridSize, delay, runMacro, runMacroFinal, lastTime, snap2Grid", "UNSUFFIXED")]

[h,macro('deferAnimateMove@'+getMacroLocation()): args]

[h:mainMe = me]
[h,foreach(user, otherPlayers), CODE:{
	[me		= getName(copyToken(mainMe))]
	[setOwnerOnlyVisible(1, me)]
	[setOwner(user, me)]
	[args	= strformat(argString)]	
	[broadcast(macroLink("<color='white'>", 'deferAnimateMove@'+getMacroLocation(), 'none', args,user))]
}]

@@animateMove BCK
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=1 ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Animate Move ; tooltip= ; minWidth=90 ; 
[h:'<!-- --------------------------- animateMove --------------------------------------------->']
[h:'<!-- animateToken([0.tokenID [,1.x, 2y[, 3.relative[,4.stopOnImpact(-1:bounce; 0=continue; 1=stop)[,5.layer(json.object)[,6.vbl(1; 0)[,7.delay(ms)[,8.distance[,9.macroName (to run after 1 move)[,10.macroNameFinal (to run when animation is done)[,11.rotation]]]]]]]]]) -->']
[h, if(argCount()>0):me				= arg(0); me			= getSelected()]
[h:assert(listCount(me)==1, "Make sure (only) one token is selected",0)]
[h:switchToken(me)]
[h, if(argCount()>3):relative		= arg(3); relative		= 0]
[h, if(argCount()>4):stopOnImpact	= arg(4); stopOnImpact	= 0]
[h, if(argCount()>5):layer			= arg(5); layer			= '["token","object"]']
[h, if(argCount()>6):vbl			= arg(6); vbl			= 0]
[h, if(argCount()>7):delay			= arg(7); delay			= 0]
[h, if(argCount()>8):distance		= arg(8); distance		= 0][h:'<!-- set a distance to travel regardless of end postition. -->']
[h, if(argCount()>9):runMacro		= arg(9); runMacro		= 0] 
[h, if(argCount()>10):runMacroFinal	= arg(10); runMacroFinal= 0] 
[h, if(argCount()>11):dr			= arg(11); dr			= 0] 
[h, if(argCount()>12):rStep			= arg(12); rStep		= 5] 

[h:'<!-- this arg runs a macro after EVERY move step. With this you can plug in stuff like e.g scan area after move or move other tokens as well. Note that any output of this macro is ignored. Use broadcast if you want to send something to the chat the macro string should be a standard [runthis(arg, arg)] -->']
[h, if(runMacro == ""): runMacro = 0]
[h, if(runMacroFinal == ""): runMacroFinal = 0]

[h, if(argCount()>2), CODE:{
	[h: x1  = if(relative, arg(1) + getTokenX(0), arg(1))]	  
	[h: y1  = if(relative, arg(2) + getTokenY(0), arg(2))]	  
}; {
	[abort(input(	
					"junk|<html><b>You have the following options, the Token travels:<br>- to the given coords (relative unchecked; distance=0)<br>- the relative distance (relative checked; distance=0)<br>- in the direction of the exact coords to distance=n (relative unchecked)<br>- in the direction of the relative coords to distance=n (relative checked)<br></b></html>|-|LABEL|SPAN=TRUE",
					"x1|0|<html><b>X</b> Coordinate of token",
					"y1|0|<html><b>Y</b> Coordinate of token",
					"dr|180|<html><b>R</b> Degrees it rotates",
					"rStep|5|<html><b>R-Stepsize</b> Degrees per step (the higher the faster)",
					"distance|0|<html><b>Distance</b> the token travels",
					"relative|1|<html><b>Relative</b> to current position|CHECK",
					"stopOnImpact|Bounce, Continue, Stop|What should it do when it hits something|RADIO|SELECT=1",
					"delay|0|Set delay per step",
					"junk|<html><b>Which layers should be checked for bounce or stop on impact?</b><br><i>Note that checking the four 'Token' layers can slow the animation<br>down considerably</html>|-|LABEL|SPAN=TRUE",
					"Token|0|Token Layer|CHECK",
					"Hidden|0|Hidden Layer|CHECK",
					"Object|0|Object Layer|CHECK",
					"Background|0|Background Layer|CHECK",
					"vbl|1|Vision Blocking Layer (Token MUST have vision!!)|CHECK"
	))]
	[stopOnImpact	= stopOnImpact - 1]
	[layer 			= "[]"]
	[if(Token):			layer = json.append(layer, "Token")]
	[if(Hidden):		layer = json.append(layer, "Hidden")]
	[if(Object):		layer = json.append(layer, "Object")]
	[if(Background):	layer = json.append(layer, "Background")]

	[if(relative), CODE:{
		[x1  = x1 + getTokenX(0))]	  
		[y1  = y1 + getTokenY(0))]	  
	}; {}]
}]

[h:x0		= getTokenX(0)]	  
[h:y0		= getTokenY(0)]
[h:r0		= bot_getTokenFacing(me, 1)]
[h:dx		= abs(x1 - x0)]
[h:dy		= abs(y1 - y0)]
[h:x		= x0]
[h:y		= y0]
[h:r		= r0]
[h:n 		= if(!distance, 1 + dx + dy, 0)]
[h:xInc		= if(x1 > x0, 1, -1)]
[h:yInc		= if(y1 > y0, 1, -1)]
[h:error	= dx - dy]
[h:dx		= 2 * dx]
[h:dy		= 2 * dy]
[h:direction= ""]
[h:lastDiag	= 0]
[h:steps	= 0]
[h,if(dr && !rStep): dr = 0]

[h:check = if(dx < dy, "X", "Y")]
[h:'<!-- set lastTime to 0 so that each client will get its own time!! -->']
[h:lastTime = 0]
[h:gridSize = json.get(json.get(getInfo("map"),"grid"),"size")]

[h:'<!-- initialize the animation on every pc/client/user -->']
[h:onlinePlayers		= getAllPlayerNames()]
[h:initiator			= getPlayerName()]
[h:animationPerClient	= getLibProperty("animationPerClient", "lib:EventMacros")]
[h:oldOwners 			= isOwnedByAll()]
[h,if(oldOwners): oldOwners = json.fromList(onlinePlayers); oldOwners = json.fromList(getOwners())]

[h,if(animationPerClient), CODE:{
	[otherPlayers = listDelete(onlinePlayers, listFind(onlinePlayers, initiator))]
	[setOwner(initiator, me)]
	[setOwnerOnlyVisible(1, me)]
}; {
	[otherPlayers = ""]
}]
[h:mainMe = ""]

[h:args = strPropFromVars("me, mainMe, initiator, oldOwners, n, x, y, r, dx, dy, dr, rStep, xInc, yinc, steps, distance, lastDiag, check, direction, error, stopOnImpact, layer, vbl, gridSize, delay, runMacro, runMacroFinal, lastTime", "UNSUFFIXED")]

[h,macro('deferAnimateMove@'+getMacroLocation()): args]

[h:mainMe = me]
[h,foreach(user, otherPlayers), CODE:{
	[me = getName(copyToken(mainMe))]
	[setOwnerOnlyVisible(1, me)]
	[setOwner(user, me)]
	[args = strformat(argString)]	
	[broadcast(macroLink("<color='white'>", 'deferAnimateMove@'+getMacroLocation(), 'none', args,user))]
}]

@@animateText
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=6 ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Animate Move ; tooltip= ; minWidth=90 ; 
[h:'<!-- animateText (text[, title, position, html-header, width, height, delay, upper]) -->']
[h:numArgs = argCount()]
[h:assert(numArgs, "This function requires at least one parameter:<br>animateText <i>(text[, title, position, html-header, width, height, delay, upper])",0)]

[h:'<!-- the text to animate -->']
[h:txt 							= arg(0)]
[h:lastCharPos = length(txt)-1]

[h:'<!-- This title will appear at the top of the frame, it will also be the name of the frame -->']
[h, if(numArgs > 1): title		= arg(1); title		= "Message"] 

[h:'<!-- From which position in the text should the text animation start, the number you fill in is the amount of characters that will immediately appear in the frame, the rest of the text is animated -->']
[h, if(numArgs > 2): position	= arg(2); position	= 0]
[h:position = min(lastCharPos, position)]

[h:'<!-- a html header which enables you to make up the frame -->']
[h, if(numArgs > 3): html		= arg(3); html		= "<html><head></head><body text='#00CC00' style='font-family:Courier' bgcolor = 'black'><table padding=3><font face='Courier'>"]
[h, if(html == "Default"): html = "<html><head></head><body text='#00CC00' style='font-family:Courier' bgcolor = 'black'><table padding=3><font face='Courier'>"]

[h:'<!-- dimensions of the frame -->']
[h, if(numArgs > 4): width		= arg(4); width		= 640]
[h, if(numArgs > 5): height		= arg(5); height	= 480]

[h:'<!-- how many ms between each printed character -->']
[h, if(numArgs > 6): delay		= arg(6); delay		= 15]

[h:'<!-- print the while text in upper case -->']
[h, if(numArgs > 7): upper		= arg(7); upper		= 0]

[h,if(upper): txt = upper(txt)]

[h:output	= html + substring(txt, position, position+1)]
[if(bot_isFullScreen()), CODE:{
	[dialog(title, "width="+width+"; height="+height+"; temporary=1; input=1"): {[r:output]}]
};{
	[frame(title, "width="+width+"; height="+height+"; temporary=1"): {[r:output]}]
}]

[H:currentTime = json.get(getInfo("client"),"timeInMs")]
[h:ok=0]
[h,while (!ok), CODE:{
	[newTime = json.get(getInfo("client"),"timeInMs")]
	[if(currentTime+delay < newTime):ok=1]
}]

[h:position = min(lastCharPos, position + 1)]

[h:varList = "title, html, txt, position, delay"]
[h:args = strPropFromVars(varList, "UNSUFFIXED")]

[h:link = macroLinkText("deferAnimateText@"+getMacroLocation(),"none",args)]
[h:execLink(link,1)]

<!-- broadcast to the players -->
[h:initiator			= getPlayerName()]
[h:onlinePlayers		= getAllPlayerNames()]
[h:otherPlayers			= listDelete(onlinePlayers, listFind(onlinePlayers, initiator))]
[h,foreach(user, otherPlayers), CODE:{
	[broadcast(macroLink("<color='white'>", 'deferAnimateText@'+getMacroLocation(), 'none', args,user))]
}]

@@animateTextInput
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=5 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Animate Move ; tooltip= ; minWidth=193 ; 
[h:lastSettings	= getLibProperty("lastAnimatedTextSettings", "lib:EventMacros")]
[h:varsFromStrProp(lastSettings)]

[h:abort(input(
	strformat("Animated text|text=%{text}; title=%{title}; html=%{html}||PROPS|SPAN=TRUE SETVARS=UNSUFFIXED"), 
	"position|"+position+"|Start position of animation", 
	"width|"+width+"|Width of the frame", 
	"height|"+height+"|Heigth of the frame", 
	"delay|"+delay+"|Delay per character (in ms)", 
	"upper|"+upper+"|Print text in upper class?|CHECK")
)]

[h:bot_animateText(text, title, position, html, width, height, delay, upper)]

[h:varList 		= "text, title, position, html, width, height, delay, upper"]
[h:lastSettings = strPropFromVars(varList, "UNSUFFIXED")]
[h:setLibProperty("lastAnimatedTextSettings", lastSettings, "lib:EventMacros")]

@@defOwners
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=3 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Animate Move ; tooltip= ; minWidth=90 ; 
[h:'<!-- defOwners-->']
[h:varsFromStrProp(macro.args)]
[h:setOwnerOnlyVisible(0, mainMe)]
[h:setOwner(oldOwners, mainMe)]

@@deferAnimateMove
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=0.95em ; sortBy=2 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Animate Move ; tooltip= ; minWidth=90 ; 
[h:'<!-- deferAnimateMove -->']
[h:abort(1)]
[h:varsFromStrProp(macro.args)]
[h:switchToken(me)]
[h:setHasSight(1)]
[h:xMove = 0]
[h:yMove = 0]
[h:'broadcast(macro.args)']

<!-- skip a step to prevent staircasing -->
[h,if(direction != check), CODE:{
	<!-- if stop on impact or bounce, check if something is blocking the path, if so, quit -->
	<!-- getBlockType -->
	
	<!-- Initialize -->
	[xB 			= 0]
	[yB 			= 0]
	[cB 			= 0]
	[blockType		= ""]

	<!-- ------------------------------------------------------------------------------------>
	<!-- ---------------------------------STOP ON IMPACT CHECKS------------------------------>
	<!-- ------------------------------------------------------------------------------------>
	[if(stopOnImpact), CODE:{
		[if(vbl), CODE:{
			<!-- check for vision blocking layer isVisible only uses gridsize and looks at the actual give coordinates-->
			[if(xInc > 0):	xOffset = gridSize*1.5*xInc); xOffset = gridSize*0.5*xInc)]
			[if(yInc > 0):	yOffset = gridSize*1.5*yInc); yOffset = gridSize*0.5*yInc)]
			[if(dx): 		xB		= if(isVisible( getTokenX(1) + xOffset, getTokenY(1)			), 0,1)]
			[if(dy): 		yB		= if(isVisible( getTokenX(1), 			getTokenY(1) + yOffset	), 0,1)]
			[if(dx && dy):	cB		= if(isVisible( getTokenX(1) + xOffset,	getTokenY(1) + yOffset	), 0,1)]
		''
		}]
		
		[if(!json.isEmpty(layer)), CODE:{
			<!-- check for tokens on the different layers gettokens looks at the area offset to the current position of the token-->
			[if(dx && !xB): 		xB	= listCount(getTokens(",", strformat("{'layer':%{layer},'area':{'token':'%{me}','offsets':[{'x':%{xInc},'y':0}]}}")))]
			[if(dy && !yB): 		yB	= listCount(getTokens(",", strformat("{'layer':%{layer},'area':{'token':'%{me}','offsets':[{'x':0,'y':%{yInc}}]}}")))]
			[if(dx && dy && !cB):	cB	= listCount(getTokens(",", strformat("{'layer':%{layer},'area':{'token':'%{me}','offsets':[{'x':%{xInc},'y':%{yInc}}]}}")))]
		''
		}]

		[if(xB || yB || cB), CODE:{
			<!-- process blocking results -->
			<!-- x=left/right y=up/down c=corner -->
			[if(xB && !yB):blockType	= "x"]
			[if(yb && !xB):blockType	= "y"]
			[if((cB&&!xB&&!yB)||(!cB&&xB&&yB)||(cB&&xB&&yB)):blockType = "c"]

			<!-- stop on impact -->
			[if(stopOnImpact > 0 && blockType != ""), CODE:{
				[abort(0)]
			''
			};{
				<!-- Bounce -->
				[if(blockType == 'x' || blockType == 'c'), CODE:{
					[xInc = -xInc]
					[x = x + 2*xInc]
				''
				}]
				[if(blockType == 'y' || blockType == 'c'), CODE:{
					[yInc = -yInc]
					[y = y + 2*yInc]
				''
				}]
			''
			}]

		''
		}]
	''
	}]
	<!-- ------------------------------------------------------------------------------------>
	<!-- ---------------------------------THE ACTUAL MOVE------------------------------------>
	<!-- ------------------------------------------------------------------------------------>
	
	<!-- skip the move if there is a block type OR if x AND y dont change or if n is 0 or smaller -->
	<!-- if dStep = 0 get Grid Coord, is <> 0 get pixel coord -->
	[xMove = x - getTokenX(dStep)]
	[yMove = y - getTokenY(dStep)]
	[h, if((xMove || yMove) && n > 0), CODE:{
		<!-- delay -->
		[if(!lastTime):lastTime = json.get(getInfo("client"),"timeInMs") - 2*delay]
		[continue = if(json.get(getInfo("client"),"timeInMs") < (lastTime + delay),0,1)]
		[while(!continue): continue = if(json.get(getInfo("client"),"timeInMs") < (lastTime + delay),0,1)]

		<!-- the actual animation -->
		<!-- if dStep = 0 get Grid Coord, is <> 0 get pixel coord -->
		[moveToken(x,y,dStep)]
		<!-- clock for the next delay -->
		[lastTime = json.get(getInfo("client"),"timeInMs")]
		<!-- count the distance travelled -->
		[steps = steps + max(1, dStep - 1)]
	''
	}]
''
};{
	<!-- if this is a 2nd time diagonal step is taken count an extra step and toggle the lastDiag -->
	[if(lastDiag): steps = steps + max(1, dStep - 1)]
	[lastDiag = 1- lastDiag]
''
}]

	<!-- ------------------------------------------------------------------------------------>
	<!-- ---------------------------------ROTATION ANIMATION--------------------------------->
	<!-- ------------------------------------------------------------------------------------>
[h, if(dr > 0), CODE:{
	['pause("rStep", "r", "dr")']
	[dr	= dr - rStep]
	[r	= r + rStep + if(dr<0, dr,0)]
	[bot_setTokenFacing(r, me, 1)]
	[if(dr<0):dr=0]
};{
	[if(dr < 0), CODE:{
		[dr	= dr + rStep]
		[r	= r - rStep - if(dr>0, dr,0)]
		[bot_setTokenFacing(r, me, 1)]
		[if(dr>0):dr=0]
		['pause("rStep", "r", "dr")']
	}]
}]

<!-- ------------------------------------------------------------------------------------>
<!-- ---------------------------------SET NEW DIRECTION --------------------------------->
<!-- ------------------------------------------------------------------------------------>
[h,if(error>0), CODE:{
	[x			= x+xInc]
	[error		= error-dy]
	[direction	= "X"]
}; {
	[y			= y+yInc]
	[error		= error+dx]
	[direction	= "Y"]
}]

<!-- optionally run a macro after each step, this macro can be given as an argument in the call -->
[h,if((runMacro != 0 && runMacro != "") && (xMove || yMove)): evalMacro(strformat(runMacro))]

[h:n = n - max(1, dStep - 1)]
[h,if(n > 0 || steps < distance || dr != 0), CODE:{
	<!-- ------------------------------------------------------------------------------------>
	<!-- ----------------CONTINUE until either n (==dx+dy) is 0 or #steps == distance ------->
	<!-- ------------------------------------------------------------------------------------>
	[args = strPropFromVars("me, mainMe, initiator, oldOwners, n, x, y, r, dx, dy, dr, rStep, dStep, xInc, yinc, steps, distance, lastDiag, check, direction, error, stopOnImpact, layer, vbl, gridSize, delay, runMacro, runMacroFinal, lastTime, snap2Grid", "UNSUFFIXED")]
	[link = macroLinkText("deferAnimateMove@"+getMacroLocation(),"none",args)]
	[execLink(link,1)]
}; {
	<!-- ------------------------------------------------------------------------------------>
	<!-- --------------------------------- FINISHED ----------------------------------------->
	<!-- ------------------------------------------------------------------------------------>
	<!-- delete the animated token and make the main token visible again. but not if you are the initiator in which case me = main me and mainMe = "" -->
	[if(mainMe != ""), CODE:{
		[args = strformat("mainMe = %{mainMe}; oldOwners = %{oldOwners}")]
		<!-- broadcast an update to the initiator to set the token owners back to previous setting -->
		[broadcast(macroLink("<color='white'>", 'defOwners@'+getMacroLocation(), 'none', args, initiator))]
		[removeToken(me)]
	};{
		<!-- if your the initiator, snap mainme to grid (if required) -->
		[if(snap2Grid): bot_snapToGrid(me)]
	}]
	[if((runMacroFinal != 0)): evalMacro(strformat(runMacroFinal))]
}]

@@deferAnimateMove BCK
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=0.95em ; sortBy=2 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Animate Move ; tooltip= ; minWidth=90 ; 
[h:'<!-- --------------------------- animateMove --------------------------------------------->']
[h:'<!-- animateToken([0.tokenID [,1.x, 2y[, 3.relative[,4.stopOnImpact(-1:bounce; 0=continue; 1=stop)[,5.layer(json.object)[,6.vbl(1; 0)[,7.delay(ms)[,8.distance[,9.macroName (to run after 1 move)[,10.macroNameFinal (to run when animation is done)[,11.rotation]]]]]]]]]) -->']
[h, if(argCount()>0):me				= arg(0); me			= getSelected()]
[h:assert(listCount(me)==1, "Make sure (only) one token is selected",0)]
[h:switchToken(me)]
[h, if(argCount()>3):relative		= arg(3); relative		= 0]
[h, if(argCount()>4):stopOnImpact	= arg(4); stopOnImpact	= 0]
[h, if(argCount()>5):layer			= arg(5); layer			= '["token","object"]']
[h, if(argCount()>6):vbl			= arg(6); vbl			= 0]
[h, if(argCount()>7):delay			= arg(7); delay			= 0]
[h, if(argCount()>8):distance		= arg(8); distance		= 0][h:'<!-- set a distance to travel regardless of end postition. -->']
[h, if(argCount()>9):runMacro		= arg(9); runMacro		= 0] 
[h, if(argCount()>10):runMacroFinal	= arg(10); runMacroFinal= 0] 
[h, if(argCount()>11):dr			= arg(11); dr			= 0] 
[h, if(argCount()>12):rStep			= arg(12); rStep		= 5] 
[h, if(argCount()>13):dStep			= arg(13); dStep		= 0] 

[h:'<!-- this arg runs a macro after EVERY move step. With this you can plug in stuff like e.g scan area after move or move other tokens as well. Note that any output of this macro is ignored. Use broadcast if you want to send something to the chat the macro string should be a standard [runthis(arg, arg)] -->']
[h, if(runMacro == ""):			runMacro		= 0]
[h, if(runMacroFinal == ""):	runMacroFinal	= 0]

[h, if(argCount()>2), CODE:{
	<!-- if dStep = 0 then get grid coord, else get pixel coord -->
	[x1  = if(relative, arg(1) + getTokenX(dStep), arg(1))]	  
	[y1  = if(relative, arg(2) + getTokenY(dStep), arg(2))]	  
}; {
	[abort(input(	
					"junk|<html><b>You have the following options, the Token travels:<br>- to the given coords (relative unchecked; distance=0)<br>- the relative distance (relative checked; distance=0)<br>- in the direction of the exact coords to distance=n (relative unchecked)<br>- in the direction of the relative coords to distance=n (relative checked)<br></b></html>|-|LABEL|SPAN=TRUE",
					"x1|0|<html><b>X</b> New coordinate of token (in grid coords if D-stepsize=0, else in pixel coords)",
					"y1|0|<html><b>Y</b> New coordinate of token (dito X)",
					"dStep|0|<html><b>D-Stepsize</b> 0=step per cell, >0=per that many pixels",
					"dr|180|<html><b>R</b> Degrees it rotates",
					"rStep|5|<html><b>R-Stepsize</b> Degrees per step (the higher the faster)",
					"distance|0|<html><b>Distance</b> the token travels",
					"relative|1|<html><b>Relative</b> to current position|CHECK",
					"stopOnImpact|Bounce, Continue, Stop|What should it do when it hits something|RADIO|SELECT=1",
					"delay|0|Set delay per step",
					"junk|<html><b>Which layers should be checked for bounce or stop on impact?</b><br><i>Note that checking the four 'Token' layers can slow the animation<br>down considerably</html>|-|LABEL|SPAN=TRUE",
					"Token|0|Token Layer|CHECK",
					"Hidden|0|Hidden Layer|CHECK",
					"Object|0|Object Layer|CHECK",
					"Background|0|Background Layer|CHECK",
					"vbl|1|Vision Blocking Layer (Token MUST have vision!!)|CHECK"
	))]
	[stopOnImpact	= stopOnImpact - 1]
	[layer 			= "[]"]
	[if(Token):			layer = json.append(layer, "Token")]
	[if(Hidden):		layer = json.append(layer, "Hidden")]
	[if(Object):		layer = json.append(layer, "Object")]
	[if(Background):	layer = json.append(layer, "Background")]

	[if(relative), CODE:{
		[x1  = x1 + getTokenX(dStep))]	  
		[y1  = y1 + getTokenY(dStep))]	  
	}; {}]
}]

[h:x0		= getTokenX(dStep)]	  
[h:y0		= getTokenY(dStep)]
[h:r0		= bot_getTokenFacing(me, 1)]
[h:dx		= abs(x1 - x0)]
[h:dy		= abs(y1 - y0)]
[h:x		= x0]
[h:y		= y0]
[h:r		= r0]
[h:n 		= if(!distance, 1 + dx + dy, 0)]
[h:xInc		= if(x1 > x0, max(1, dStep - 1), -max(1, dStep - 1))]
[h:yInc		= if(y1 > y0, max(1, dStep - 1), -max(1, dStep - 1))]
[h:error	= dx - dy]
[h:dx		= 2 * dx]
[h:dy		= 2 * dy]
[h:direction= ""]
[h:lastDiag	= 0]
[h:steps	= 0]
[h,if(dr && !rStep): dr = 0]

[h:check = if(dx < dy, "X", "Y")]
[h:'<!-- set lastTime to 0 so that each client will get its own time!! -->']
[h:lastTime = 0]
[h:gridSize = json.get(json.get(getInfo("map"),"grid"),"size")]

[h:'<!-- initialize the animation on every pc/client/user -->']
[h:onlinePlayers		= getAllPlayerNames()]
[h:initiator			= getPlayerName()]
[h:animationPerClient	= getLibProperty("animationPerClient", "lib:EventMacros")]
[h:oldOwners 			= isOwnedByAll()]
[h,if(oldOwners): oldOwners = json.fromList(onlinePlayers); oldOwners = json.fromList(getOwners())]

[h,if(animationPerClient), CODE:{
	[otherPlayers = listDelete(onlinePlayers, listFind(onlinePlayers, initiator))]
	[setOwner(initiator, me)]
	[setOwnerOnlyVisible(1, me)]
}; {
	[otherPlayers = ""]
}]
[h:mainMe = ""]

[h:args = strPropFromVars("me, mainMe, initiator, oldOwners, n, x, y, r, dx, dy, dr, dStep, rStep, xInc, yinc, steps, distance, lastDiag, check, direction, error, stopOnImpact, layer, vbl, gridSize, delay, runMacro, runMacroFinal, lastTime", "UNSUFFIXED")]

[h,macro('deferAnimateMove@'+getMacroLocation()): args]

[h:mainMe = me]
[h,foreach(user, otherPlayers), CODE:{
	[me		= getName(copyToken(mainMe))]
	[setOwnerOnlyVisible(1, me)]
	[setOwner(user, me)]
	[args	= strformat(argString)]	
	[broadcast(macroLink("<color='white'>", 'deferAnimateMove@'+getMacroLocation(), 'none', args,user))]
}]

@@deferAnimateText
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=0.95em ; sortBy=7 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Animate Move ; tooltip= ; minWidth=90 ; 
[h:'<!-- deferAnimateText -->']
<!-- MORE THEN THREE CODE LEVELS 3 CODE LEVELS -->
[debug = 0]

[h:varsFromStrProp(macro.args)]

[h,if(debug), CODE:{
	[args	= macro.args]
	[bot_debugInfo("position, txt, args",0)]
};{}]

[h,if(position <= length(txt)), CODE:{
	[h:output	= html + substring(txt, 0, position)]

	[if(bot_isFullScreen()), CODE:{
		[dialog(title, "width=215; height=460; temporary=0; input=1"): {
			[r:output]
		[h:'']
		}]
	''
	};{
		[frame(title, "width=215; height=460; temporary=0"): {
			[r:output]
		[h:'']
		}]
	''
	}]
	
	[h:currentTime = json.get(getInfo("client"),"timeInMs")]
	[h:ok=0]
	[h,while (!ok), CODE:{
		[newTime = json.get(getInfo("client"),"timeInMs")]
		[if(currentTime+delay < newTime):ok=1]
	''
	}]

	[h:position = position + 1]
	
	[h:varList = "title, html, txt, position, delay"]
	[h:args = strPropFromVars(varList, "UNSUFFIXED")]
	
	[link = macroLinkText("deferAnimateText@"+getMacroLocation(),"none",args)]
	[execLink(link,1)]
''
}; {}]

@@delay
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=4 ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Animate Move ; tooltip= ; minWidth=90 ; 
[h:delay = arg(0)]
[H:currentTime = json.get(getInfo("client"),"timeInMs")]
[h:ok=0]
[h,while (!ok), CODE:{
	[newTime = json.get(getInfo("client"),"timeInMs")]
	[if(currentTime+delay < newTime):ok=1]
}]

@@assignArea
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Event Area Macros ; tooltip=<html>With this macro you can link predefined Areas to Event Macros and to the Limit Movement macro<br>The Event Macro will be triggered when a token moves over the Area. The handling of this is left<br>to the macro itself ; minWidth=90 ; 
[h:'<!-- --------------------- Assign Area----------------------------------------------------------------------->']
<!-- ignore output, new scope -->
<!-- <html>With this macro you can link predefined Areas to Event Macros and to the Limit Movement macro<br>The Event Macro will be triggered when a token moves over the Area. The handling of this is left<br>to the macro itself -->

<!-- ------------------------------- initialize values -------------------->
[h:oldMap			= getCurrentMapName()]
[h:setCurrentMap(getLibProperty("baseMapName", "lib:EventMacros"))]
[h:macroList		= getMacros(",","lib:EventMacros")]
[h:setCurrentMap(oldMap)]
[h:assert(macroList != "","First create at least one macro on the lib:EventMacro token with which this event area can be associated",0)]

<!-- ----------------------------------the areas -------------------------->
[h:storedAreas		= getLibProperty("storedAreas", "Lib:EventMacros")]
[h:assert(!json.isEmpty(storedAreas), "No areas have been defined", 0)]
[h:linkedAreas		= getLibProperty("linkedAreas", "Lib:EventMacros")]
[h:mapNames			= json.fields(storedAreas)]
[h:macroList		= listAppend("<None>", macroList)]

<!-- first time use -->
[h, if(json.type(linkedAreas) == "UNKNOWN"): linkedAreas = "{}"]

[h:triggerTypeList	= "movedOn, movedOff, movedOver, movedNot, movedReturn, movedRemain"]

<!-- ---------------------------------Generate Input Screen based on found Areas -------------------->
[h:tabNr		= 0]
[h:inputStr		= ""]

[h,foreach(mapName, mapNames), CODE: {
	<!-- create tabs with the areas sorted per mapName -->
	[inputStr 	= json.append(inputStr, 'tab'+tabNr+' |'+mapName+'|| TAB')]
	[inputStr	= json.append(inputStr, 'junk|<html><b>LINK EVENT MACRO TO AN EVENT AREA</b><br></html></span></html>|-|LABEL|SPAN=TRUE')]

	[if(json.contains(linkedAreas, mapName)): 				thisMapLinks	= json.get(linkedAreas, mapName)			 ; thisMapLinks = "{}"]
	[if(json.contains(linkedAreas, mapName+".W42.Limit")):	thisMapLimits	= json.get(linkedAreas, mapName+".W42.Limit") ; thisMapLimits = "{}"]

	[areaList	= json.fields(json.get(storedAreas, mapName))]
	[listLength = listCount(areaList)-1]
	[i = 0]
	[foreach(area, areaList), CODE:{
		[if(json.type(thisMapLinks) == "OBJECT"):		strPropVars = json.get(thisMapLinks, area); strPropVars = ""]
		<!-- define:  "eventMacro, eventTriggerList" -->
		[if(strPropVars != ""):						varsFromStrProp(strPropVars)]
		[if(strPropVars != ""):						oldSelection = listFind(macroList, eventMacro) ; oldSelection = 0]
		[if(json.type(thisMapLimits) == "OBJECT"):	oldSelection = max(oldSelection,listFind(macroList, json.get(thisMapLimits, area)))					]
		[inputStr 	= json.append(inputStr, 'assignedArea_'+tabNr+'_'+i+'|'+macroList+'|<html><span title="<html>When you move over a predefined Area you can have a certain<br>macro (event) triggered. Here you can link an Event Macro to<br>the predefined areas. The areas are sorted per map (in tabs).<br><br>Note that <i>Limit Movement</i> is a special and reserved<br>macro that is run BEFORE the pads are checked and based on<br>this outcome (and whether its turned on) the path of the<br>token is shortened to the maximum allowed steps.<br><br><b>Therefore the Event Triggers will be IGNORED for LIMIT MOVEMENT</b><br><br>You can turn <i>Limit Movement</i> on in the settings.</html>"><b><font color=#FF0000>'+area+'</b></font></html></span></html>|LIST|SELECT='+oldSelection+' VALUE=STRING')]

		[varsFromStrProp("movedOn=0; movedOff=0; movedOver=0; movedNot=0; movedReturn=0; movedRemain=0")]
		[if(strPropVars == ""):	eventTriggerList = ""]
		[foreach(event, eventTriggerList): set(event, 1)]
		
		[inputStr 	= json.append(inputStr, 'junk|<html><i>Which actions trigger this event area (all events are mutual exclusive):</i></html>|-|LABEL|SPAN=TRUE')]
		[inputStr 	= json.append(inputStr, 'movedOn_'+tabNr+'_'+i+'|'		+movedOn+		'|<html><span title="<html><b>When checked:</b> The macro associated with this area,<br>will be triggered when a token <b>moves onto this area</b>.</html>">Token moves onto area</html></span></html>|CHECK')]
		[inputStr 	= json.append(inputStr, 'movedOff_'+tabNr+'_'+i+'|'	+movedOff+		'|<html><span title="<html><b>When checked:</b> The macro associated with this area,<br>will be triggered when a token <b>leaves this area.</html>">Token moves off area</html></span></html>|CHECK')]
		[inputStr 	= json.append(inputStr, 'movedOver_'+tabNr+'_'+i+'|'	+movedOver+		'|<html><span title="<html><b>When checked:</b> The macro associated with this area,<br>will be triggered when a token <b>moves over this area.</html>">Token moves over area</html></span></html>|CHECK')]
		[inputStr 	= json.append(inputStr, 'movedNot_'+tabNr+'_'+i+'|'	+movedNot+		'|<html><span title="<html><b>When checked:</b> The macro associated with this area,<br>will be triggered when a token <b>on this area is moved<br>from and back to the same postion on this area<br>without using waypoints.</b><br>Note that zero move is turned off per default in the<br>settings, in which case this event will never occur.</html>">Token does zero move on area</html></span></html>|CHECK')]
		[inputStr 	= json.append(inputStr, 'movedReturn_'+tabNr+'_'+i+'|'	+movedReturn+	'|<html><span title="<html><b>When checked:</b> The macro associated with this area,<br>will be triggered when a token <b>moves off this area<br>and back onto it, using waypoints.</html>">Token leaves and returns onto area</html></span></html>|CHECK')]
		[inputStr 	= json.append(inputStr, 'movedRemain_'+tabNr+'_'+i+'|'	+movedRemain+	'|<html><span title="<html><b>When checked:</b> The macro associated with this area,<br>will be triggered when a token <b>is moved but remains<br>on the area the entire move.</html>">Token moves but remains on area</html></span></html>|CHECK')]
		[if(i < listLength):inputStr 	= json.append(inputStr, 'junk|<html>_____________________________________________________</html>|-|LABEL|SPAN=TRUE')]
		[i = i + 1]
	}]
	[tabNr		= tabNr +1]
}]

<!-- -----------------------------------ask for input ------------------------------------->
[H: abort(input(json.toList(inputStr,"##")))]

<!-- --------------------------------- assign the events to the areas -------------------->
[h:linkedAreas = "{}"]
[h:tabNr = 0]
[h,foreach(mapName, mapNames), CODE: {
	[areaList		= json.fields(json.get(storedAreas, mapName))]
	[thisMapLinks	= "{}"]
	[thisMapLimits	= "{}"]
	[i = 0]
	[foreach(area, areaList), CODE:{
		[eventMacro = eval("assignedArea_"+tabNr+"_"+i)]
		[if(eventMacro == "Limit Movement"): thisMapLimits	= json.set(thisMapLimits, area, eventMacro)]

		[eventTriggerList = ""]
		[foreach(trigger, triggerTypeList), if(eval(trigger+'_'+tabNr+'_'+i)): eventTriggerList = listAppend(eventTriggerList, trigger)]
		<!-- only store if NOT liked to limit movement -->
		[if(eventMacro != "Limit Movement"): thisMapLinks = json.set(thisMapLinks, area, strPropFromVars("eventMacro, eventTriggerList","UNSUFFIXED"))]
		[i = i + 1]
	}]
	[linkedAreas	= json.set(linkedAreas, mapName, thisMapLinks, mapName+".W42.Limit", thisMapLimits)]
	[tabNr			= tabNr + 1]
}]

[h:setLibProperty("linkedAreas", linkedAreas, "Lib:EventMacros")]
[h:broadcast("The Event links have been created")]

@@defineArea
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Event Area Macros ; tooltip=<html>With this macro you can define an Event Area which you then can link to an event macro, to be triggered when a token moves over this area. ; minWidth=90 ; 
[h:'<!-- -------------------------------- defineArea ------------------------------------ -->']
<!-- ignore output, new scope -->
<!-- <html>With this macro you can define an Event Area which you then can link to an event macro, to be triggered when a token moves over this area. -->

[h:stateList = getTokenStates()]
[h,if(listContains(stateList, "Special Area")): selectedState = listFind(stateList, "Special Area") ; selectedState = 0]
[h:abort(input(
	'junk|<html><b>DEFINE EVENT AREA</b></html>|-|LABEL|SPAN=TRUE',
	'areaName|<enter name of area>|<html><span title="<html>Here you can enter the name of the area to which the<br>coords will be linked. Use alphanumeric characters only</html>">Name of Area</html></span></html>',
	'junk|<html><b>Choose one of the below two methods:<br>____________________________________________________<br>Method 1: Use coords of tokens on map</b><br></html>|-|LABEL|SPAN=TRUE',
	'areaState|'+stateList+'|<html><span title="<html>This is part of the first method. The macro will look<br>for ALL tokens that meet ALL the conditions you set here<br>and will use their coordinates to define the area.<br>You can use any state you like. After this macro is<br>done the tokens are no longer needed and you can<br>delete them if you wish to do so.</html>">Name of Token State</html></span></html>|LIST|VALUE=STRING SELECT='+selectedState,
	'areaLayer|TOKEN, OBJECT, HIDDEN, BACKGROUND|<html><span title="<html>This is part of the first method. The macro will look<br>for ALL tokens that meet ALL the conditions you set here<br>and will use their coordinates to define the area.<br>You can use any layer you like. After this macro is<br>done the tokens are no longer needed and you can<br>delete them if you wish to do so.</html>">Name of layer</html></span></html>|LIST|VALUE=STRING SELECT=0',
	'deleteTokens|0|<html><span title="<html>Note that if you choose NOT to delete them, then the<br>only way to remove them is to manually delete them.<br>Or run this macro again and then check this box.</html>">Delete tokens when done</html></span></html>|CHECK',
	'junk|<html>____________________________________________________<br><b>Method 2: Use coords of lastpath of a token</b><br><i>Checking the checkbox will result in method 2</i><br></html>|-|LABEL|SPAN=TRUE',
	'useLastPath|0|<html><span title="<html>The other method is using the last path of a token.<br>For this you can drag a token over the area you wish<br>to mark. You can use the space bar to set waypoints.<br>Note that if you go twice over one cell that the coord<br>will only be stored once. Also note that you can later<br>edit this area by using the <i>Show Area</i> macro,<br>move, add, remove the areaTokens and then redefine the<br>area using the other method.<br><br><b>When you check this checkbox it will ignore the other method!</b></html>">Use the last path of a token</html></span></html>|CHECK',
	'lastPathName|<Token Name>|<html><span title="<html>Enter the name of the token of which the last<br>path you wish to use</html>">If checked give name of token</html></span></html>'
))]

[h,if(useLastPath), CODE:{
	[assert(findToken(lastPathName)!="", "Can't find: "+lastPathName,0)]
	[token(lastPathName):area = getLastPath(0)]
}; {
	[conditions		= json.set("{}","layer",areaLayer,"setStates",areaState)]
	[tokList		= getTokens(",",conditions)]
	[assert(listCount(tokList)>0, "No tokens have been found that match your criteria. Check whether the LAYER and the NAME are correct", 0)]
	[if(deleteTokens): bot_removeTokens(tokList)]
	<!-- create json splices to prevent the 1000 loop limit (-1 is the last entry in an array)-->
	[splices		= bot_createSplices(tokList)]
	
	<!-- loop through the splices and create an array of the coords of all the tokens -->
	[area			= "[]"]
	[h, foreach(splice, splices, ""), code: {
		[foreach(tok, splice, ""):  area = json.append(area, "{'x':"+getTokenX(1,tok)+",'y':"+getTokenY(1,tok)+"}")]
	}]
}]

<!-- clean up any double entries -->
[h:area					= json.unique(area)]

[h:mapName				= getCurrentMapName()]
[h:storedAreas			= getLibProperty("storedAreas", "Lib:EventMacros")]

<!-- first time use -->
[h, if(json.type(storedAreas) == "UNKNOWN"): storedAreas = "{}"]

[h,if(json.contains(storedAreas, mapName)): thisMapAreas = json.get(storedAreas, mapName) ; thisMapAreas = "{}"]
[h:thisMapAreas			= json.set(thisMapAreas, areaName, area)]
[h:storedAreas			= json.set(storedAreas, mapName, thisMapAreas)]
[h:setLibProperty("storedAreas", storedAreas, "Lib:EventMacros")]

<!-- show all coords in the chat-->
[h:broadcast("The Area: "+areaName+" has been defined.<br> The coordinates are:<br>"+json.indent(area,2))]

@@fillArea
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Event Area Macros ; tooltip=<html>This macro fills a predefined area with tokens</html> ; minWidth=90 ; 
[h:'<!-- -------------------------------- fillArea ------------------------------------ -->']
[h:'<!-- 
<html>This macro fills a predefined area with tokens</html>
-->']

<!-- create list of overlay tokens, this function also defines the baseMapName variable -->
[h:bot_getValidTokens(0, "{}", 0, "Area ")]
<!-- Make sure Area Marker is the first in the list -->
[h: index = listFind(allList, "Area Marker")]
[h, if(index != -1), CODE:{
	[allList		= listDelete(allList,index)]
	[allList		= listAppend("Area Marker",allList)]
	[fancyIt		= listGet(fancyAllList, index)]
	[fancyAllList	= listDelete(fancyAllList,index)]
	[fancyAllList	= listAppend(fancyIt,fancyAllList)]
}; {}]

<!-- IF a token is selected use that token to define the x and y coord and set it as default choice. -->
[h:selToks = getSelectedNames()]
[h:assert(listCount(selToks)<=2, "Make sure you have maximum two tokens selected",0)]
[h,if(selToks != ""), CODE:{
	[me	= listGet(selToks,0)]
	[x1 = getTokenX(0,me)]
	[y1 = getTokenY(0,me)]
	[if(listCount(selToks) == 2), CODE:{
		[me2	= listGet(selToks,1)]
		[x2		= getTokenX(0,me2)]
		[y2		= getTokenY(0,me2)]
		[xC		= min(x1,x2)]
		[yC		= min(y1,y2)]
		[xL 	= max(x1,x2) - xC+1]
		[yL 	= max(y1,y2) - yC+1]
	};{
		[xC		= x1]
		[yC		= y1]
		[xL 	= 10]
		[yL 	= 10]
	}]
	[allList		= listAppend(me, allList)]
	[token(me): fancyAllList = listAppend(me + getTokenImage(60), fancyAllList)]
}; {
	[xC	= 0]
	[yC	= 0]
	[xL = 10]
	[yL = 10]
}] 

[h:inputStr		= "[]"]
[h:inputStr		= json.append(inputStr, "junk|<html><b>FILL AREA</b><br>This macro fills a predefined area with tokens<br>This functions works differently depending on the selected tokens:<br><b>No tokens selected</b>: a list of area tokens will appear from which you can pick.<br><b>One token selected</b>: the selected token will be added to the top of the list AND<br>its coordinates are used for the upper left corner.<br><b>Two tokens selected: </b> same as one token but now the width and length of the area<br>is also pre set, derived from the coordinates of the lower right selected token</html>|-|LABEL|SPAN=TRUE")]
[h:inputStr 	= json.append(inputStr, "areaTok|" + fancyAllList + "|Token|LIST|ICON=TRUE ICONSIZE=30")]
[h:inputStr		= json.append(inputStr, "layer|Token, Object, Hidden, Background|Layer|LIST|SELECT=3 VALUE=STRING")]
[h:inputStr		= json.append(inputStr, "xC|"+xC+"|X coord of upper left corner")]
[h:inputStr		= json.append(inputStr, "yC|"+yC+"|Y coord of upper left corner")]
[h:inputStr		= json.append(inputStr, "xL|"+xL+"|How many cells right")]
[h:inputStr		= json.append(inputStr, "yL|"+yL+"|How many cells down")]

<!-- ask for input -->
<!-- put local variables in input form -->
[H: inputStr = json.evaluate(inputStr)]
<!-- get user input -->
[H:abort(input(json.toList(inputStr,"##")))]

<!-- process choices -->
<!-- get the AreaToken of the BASE map -->
[h:areaToken	= listGet(allList, areaTok)]
[h,if(me != "" && areaTok == 0): baseMapName	= getCurrentMapName()]
[h:areaToks		= ""]
[h,for(x, xC, xC+xL), CODE: {
	[h,for(y, yC, yC+yL):  areaToks = listAppend(areaToks, copyToken(areaToken, 1, baseMapName, json.set("{}","useDistance", 0, "layer", layer, "x", x, "y", y)))]
}]
[h:broadcast("<br><b>Overlay tokens have been placed</b>")]
[h,if(me != ""): selectTokens(json.fromList(selToks),0,"json")]

@@showArea
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Event Area Macros ; tooltip=<html>This macro shows predefined areas by putting token in the cells that are part of the Area.<br>When you run this macro again the tokens are removed again.<br><br>Hence this macro can be used to change pre defined area. To do this first run this macro<br>for the area you wish to change. The map will then be filled with tokens. Then move these<br>tokens around, delete them, copy them until youre happy. Then run <i>Define Area</i> and<br>enter a name for the new Area (can be the same as the original in which case it will be<br>overwritten) and click ok. A new Area is now defined. Finally you can run Show Area again<br>to remove the tokens. Note that is you created new tokens that these will NOT be removed by<br>this macro. ; minWidth=90 ; 
[h:'<!-- -------------------------------- showArea ------------------------------------ -->']
[h:'<!-- THREE CODE LEVELS METHOD USED -->']

<!-- ignore output, new scope -->
<!-- <html>This macro shows predefined areas by putting token in the cells that are part of the Area.<br>When you run this macro again the tokens are removed again.<br><br>Hence this macro can be used to change pre defined area. To do this first run this macro<br>for the area you wish to change. The map will then be filled with tokens. Then move these<br>tokens around, delete them, copy them until youre happy. Then run <i>Define Area</i> and<br>enter a name for the new Area (can be the same as the original in which case it will be<br>overwritten) and click ok. A new Area is now defined. Finally you can run Show Area again<br>to remove the tokens. Note that is you created new tokens that these will NOT be removed by<br>this macro. -->

[h:mapName			= getCurrentMapName()]
[h:storedAreas		= getLibProperty("storedAreas", "Lib:EventMacros")]
[h:showAreaTokens	= getLibProperty("showAreaTokens", "Lib:EventMacros")]
[h,if(json.type(showAreaTokens) == "UNKNOWN"): showAreaTokens = "{}"]
[h, if(!json.contains(showAreaTokens, mapName)):thisMapAreaTokens = "{}"; thisMapAreaTokens = json.get(showAreaTokens, mapName)]

[h:assert(json.contains(storedAreas, mapName), "This map contains no predefined areas",0)]
[h:thisMapAreas		= json.get(storedAreas, mapName)]
[h:thisMapAreaNames	= listSort(json.fields(thisMapAreas),"N+")]

<!-- create list of Areas on map -->
[h:inputStr			= "[]"]
[h:shownAreas		= json.fields(thisMapAreaTokens)]
<!-- create list of overlay tokens -->
[h:bot_getValidTokens(0, "{}", 0, "Area ")]
<!-- Make sure Area Marker is the first in the list -->
[h: index = listFind(allList, "Area Marker")]
[h, if(index != -1), CODE:{
	[allList		= listDelete(allList,index)]
	[allList		= listAppend("Area Marker",allList)]
	[fancyIt		= listGet(fancyAllList, index)]
	[fancyAllList	= listDelete(fancyAllList,index)]
	[fancyAllList	= listAppend(fancyIt,fancyAllList)]
}; {}]

[h,if(listCount(thisMapAreaNames)), CODE:{
	[inputStr		= json.append(inputStr, "junk|<html><b>(Un)Check areas to (Un)Show them on the map</b></html>|<html>Here you can show or remove special areas with the use of overlay tokens OR you can delete areas.<br>If you check one or more areas then those area will be filled with overlay tokens which you can<br>choose from the drop down box. These overlay tokens will be copied on layer you can select from<br>the other drop down box. Areas that are already checked (and thus shown on the map) remain <br>unchanged. So only CHANGES in the checkboxes will be processed. The exception for this is the <br>deletion checkbox. If you check that one, then ALL THE CHECKED AREAS will be deleted.<br><br>Note that the overlay list is created from ALL token on the BASE map which name starts with <i>'Area '</i><br>(note the space). So you can add your own by simply dropping overlay tokens on the BASE map and<br>renaming them such that they start with <i>'Area '</i><br><br><b>IMPORTANT NOTE:</b><br>When you UNCHECK an area (thus effectively REMOVE the overlay tokens), make sure that the<br><u><i>Impersonated</i></u> panel IS CLOSED. Due to a bug in MT it will take EXTREMELY long (minutes)<br>to remove these tokens when that panel is open.|LABEL|SPAN=TRUE")]
	[foreach(area, thisMapAreaNames): inputStr = json.append(inputStr, "area"+roll.count+"|"+if(listContains(shownAreas, area),1,0)+"|"+area+"|CHECK")]
	[inputStr		= json.append(inputStr, "junk|______________________________________________|-|LABEL|SPAN=TRUE")]
	[inputStr		= json.append(inputStr, "layer|Token, Object, Hidden, Background|Layer|LIST|SELECT=3 VALUE=STRING")]
	[inputStr 		= json.append(inputStr, "areaTok|" + fancyAllList + "|Overlay|LIST|ICON=TRUE ICONSIZE=30")]
	[inputStr		= json.append(inputStr, "junk|______________________________________________|-|LABEL|SPAN=TRUE")]
	[inputStr		= json.append(inputStr, "junk|<html><b>OR Delete checked areas</b><br>When you check the delete box then the all the areas<br>you have selected (checked) as well will be deleted.</html>|<html>When you check this checkbox, ALL THE CHECKED AREAS will be removed|LABEL|SPAN=TRUE")]
	[inputStr		= json.append(inputStr, "deleteArea|0|Delete|CHECK")]
}; {
	[broadcast("<html><b>No special areas found on map</b></html>")]
	[abort(0)]
}]

<!-- ask for input -->
<!-- put local variables in input form -->
[H: inputStr	= json.evaluate(inputStr)]
<!-- get user input -->
[H: abort(input(json.toList(inputStr,"##")))]

<!-- process choices -->
<!-- create list of selected area -->
[h:chosenAreas	= ""]
[h,foreach(areaName, thisMapAreaNames), if(eval("area"+roll.count)): chosenAreas = listAppend(chosenAreas, areaName)]
<!-- get the AreaToken of the BASE map -->
[h:areaToken	= listGet(allList, areaTok)]

[h,if(deleteArea), CODE:{
	[foreach(areaName, chosenAreas),CODE:{
		[thisMapAreas	= json.remove(thisMapAreas, areaName)]
		[storedAreas	= json.set(storedAreas, mapName, thisMapAreas)]
		[setLibProperty("storedAreas", storedAreas, "Lib:EventMacros")]

		<!-- remove any event links to this area as well -->
		[linkedAreas	= getLibProperty("linkedAreas", "Lib:EventMacros")]
		[thisMapLinks	= json.get(linkedAreas, mapName)]
		[if(json.type(thisMapLinks) == "OBJECT"):	thisMapLinks	= json.remove(thisMapLinks, areaName)]

		[thisMapLimits	= json.get(linkedAreas, mapName+".W42.Limit")]<br>
		[if(json.type(thisMapLimits) == "OBJECT"):	thisMapLimits	= json.remove(thisMapLimits, areaName)]

		[linkedAreas	= json.set(linkedAreas, mapName, thisMapLinks, mapName+".W42.Limit", thisMapLimits)]
		[setLibProperty("linkedAreas", linkedAreas, "Lib:EventMacros")]

		<!-- finally check if there are still showAreaTokens ids store in the json and if so, remove these as well. -->
		[areaToks			= json.get(thisMapAreaTokens, areaName)]
		<!-- clear the list on the Lib:EventMacros -->
		[thisMapAreaTokens	= json.remove(thisMapAreaTokens, areaName)]
		[showAreaTokens		= json.set(showAreaTokens, mapName, thisMapAreaTokens)]
		[setLibProperty("showAreaTokens", showAreaTokens, "Lib:EventMacros")]
		
		[broadcast("The store area: "+areaName+" has been removed.")]
	}]
}; {}]

[h,foreach(areaName, thisMapAreaNames), if(!deleteArea), CODE:{
	<!-- if checkbox of area is changed to UNCHECKED then remove area overlay tokens -->
	[if(listContains(shownAreas, areaName) && !listContains(chosenAreas, areaName)), CODE:{
		[areaToks			= json.get(thisMapAreaTokens, areaName)]
		<!-- check whether the first token is actually on the map (as a safety check) -->
		[areaIsShown = findToken(listGet(areaToks,0))]
		[if(areaIsShown != ""):	bot_removeTokens(areaToks)]
		
		<!-- clear the list on the Lib:EventMacros -->
		[thisMapAreaTokens	= json.remove(thisMapAreaTokens, areaName)]
		[showAreaTokens		= json.set(showAreaTokens, mapName, thisMapAreaTokens)]
		
		[setLibProperty("showAreaTokens", showAreaTokens, "Lib:EventMacros")]
		[broadcast("<br><b>Overlay tokens of area: "+areaName+" have been removed</b>")]
	''
	}]

	
	<!-- if checkbox of area is changed to CHECKED copy area overlay tokens in area -->
	[if(!listContains(shownAreas, areaName) && listContains(chosenAreas, areaName)), CODE:{
		[area = json.get(thisMapAreas, areaName)]
		[assert(!json.isEmpty(area), "that area contains no coordinates",0)]
		<!-- show all coords in the chat-->
		[broadcast("Area coordinates are: "+json.indent(area,2))]

		<!-- put an AreaToken on each coord for visualisation-->
		<!-- create json splices to prevent the 1000 loop limit (-1 is the last entry in an array)-->
		[splices			= bot_createSplices(area)]

		<!-- loop through the splices and copy a token on each coord -->
		[areaToks	= ""]
		
		[foreach(splice, splices, ""), CODE: {
			[foreach(coord, splice, ""):  areaToks = listAppend(areaToks, copyToken(areaToken, 1, baseMapName, json.set(coord,"useDistance", 1, "layer", layer)))]
		''
		}]

		[thisMapAreaTokens	= json.set(thisMapAreaTokens, areaName, areaToks)]
		[showAreaTokens		= json.set(showAreaTokens, mapName, thisMapAreaTokens)]
		
		[setLibProperty("showAreaTokens", showAreaTokens, "Lib:EventMacros")]
		[broadcast("<br><b>Overlay tokens for area "+areaName+" have been placed</b>")]
	''
	}]
''	
}]

@@toggleAreaDraw
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Event Area Macros ; tooltip=<html>This macro will turn on 'token drawing'. You can select a token to be drawn. When you ove ANY token on the map then the chosen token will be copied in its path ; minWidth=90 ; 
[h:'<!-- -------------------------------- toggleAreaDraw ------------------------------------ -->']

[h:toggles	= getLibProperty("toggles", "lib:EventMacros")]
[h:drawArea	= getStrProp(toggles, "drawArea")]

[h,if(drawArea), CODE:{
	<!-- active, so turn it off -->

	[drawArea		= 0]
	[toggles		= setStrProp(toggles, "drawArea", drawArea)]
	[setLibProperty("toggles", toggles, "lib:EventMacros")]
	[setLibProperty("tmpDraWArea", "[]", "lib:EventMacros")]
	[setLibProperty("drawTokenMap", "", "lib:EventMacros")]
	[broadcast("<font color=red>TOKEN DRAWING IS TURNED OFF")]
};{
	<!-- inactive, so turn it on -->

	<!-- FRIST SELECT DRAW TOKEN -->
	<!-- create list of overlay tokens -->
	[bot_getValidTokens(0, "{}", 0, "Area ")]
	[me = getSelected()]
	<!-- Make sure Area Marker is the first in the list -->
	[index = listFind(allList, "Area Marker")]
	[if(index != -1), CODE:{
		[allList		= listDelete(allList,index)]
		[allList		= listAppend("Area Marker",allList)]
		[fancyIt		= listGet(fancyAllList, index)]
		[fancyAllList	= listDelete(fancyAllList,index)]
		[fancyAllList	= listAppend(fancyIt,fancyAllList)]
	}; {}]
	<!-- Make sure Area Marker is the first in the list -->
	<!-- if any token is currently Selected add that as first entry -->
	[selTok = listGet(getSelectedNames(),0)]
	[if(selTok != ""), CODE:{
		[allList		= listAppend(selTok, allList)]
		[token(selTok): fancyAllList = listAppend(selTok + getTokenImage(60), fancyAllList)]
	};{}]
	
	[inputStr		= json.append("[]", "junk|<html><b>Pick token which will be used to draw</b></html>|-|LABEL|SPAN=TRUE")]
	[inputStr 		= json.append(inputStr, "areaTok|" + fancyAllList + "|Overlay|LIST|ICON=TRUE ICONSIZE=30")]

	<!-- ask for input -->
	<!-- put local variables in input form -->
	[inputStr = json.evaluate(inputStr)]
	<!-- get user input -->
	[abort(input(json.toList(inputStr,"##")))]
	[baseMap		= getLibProperty("baseMapName", "lib:EventMacros")]
	[drawTokenName	= listGet(allList, areaTok)]
	[if(me!=""), CODE:{
		[x	= getTokenX(0,listGet(me,0))]
		[y	= getTokenY(0,listGet(me,0))]
	};{
		[x	= 0]
		[y	= 0]
	}]
	[if(findToken(drawTokenName)==""):copyToken(drawTokenName,1,baseMap,strformat('{"x":%{x},"y":%{y}}'))]
	<!-- the selected token is on the current map, the overlay tokena are on the BASE map -->
	[drawTokenMap	= if(areaTok || selTok == "", baseMap, getCurrentMapName())]

	[drawArea	= 1]
	[toggles	= setStrProp(toggles, "drawArea", drawArea)]
	[setLibProperty("drawTokenName", drawTokenName, "lib:EventMacros")]
	[setLibProperty("drawTokenMap", drawTokenMap, "lib:EventMacros")]
	[setLibProperty("toggles", toggles, "lib:EventMacros")]
	[setLibProperty("tmpDraWArea", "[]", "lib:EventMacros")]
	[broadcast("<font color=red>TOKEN DRAWING IS TURNED ON, CLICK THE TOGGLE MACRO AGAIN TO TURN IT OFF</font><br>This means that ANY token you drag over the map will leave a trail of 'drawing tokens' in its trail")]
}]

[h:setLibProperty("toggles", toggles,"lib:EventMacros")]

@@assignPads
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=1 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=7. Assigned Pads ; tooltip=<html>With this macro you can assign token that are on the TOKEN or HIDDEN layer to Assignpads.<br>Tokens assigned to Assignpads will be moved onto their assigned pad when you run Execute<br>Assignpads<br> ; minWidth=90 ; 
[h:'<!-- --------------------- Assign Pads----------------------------------------------------------------------->']
<!-- <html>With this macro you can assign token that are on the TOKEN or HIDDEN layer to Assignpads.<br>Tokens assigned to Assignpads will be moved onto their assigned pad when you run Execute<br>Assignpads<br> -->
<!-- ----------------------------------find all assigned pads and filter them into seperate lists -------------------------->
[h:conditions	= json.set("{}", "layer", json.append("[]", "TOKEN", "HIDDEN", "OBJECT", "BACKGROUND"))]
[h:assPads		= listSort(getTokenNames(",",conditions),"A+")]
[h:allPads		= ""]
[h:padTypeList	= ""]
[h:padType		= ""]
[h:lstPads		= ""]

[h,foreach(tok,assPads),CODE:{
	[if(startsWith(tok, "AssignedPad ")), CODE:{
		<!-- make a list of all the pads -->
		[allPads	= listAppend(allPads, tok)]
		<!-- check if a group is defined eg AssignedPad Red 5 -->
		[hasPadType	= if(getFindCount(strfind(tok, "\\s"))==2, 1,0)]
		<!-- if a group is defined eg AssignedPad Red 5, retrieve the type, in this case Red-->
		[if(hasPadType): padType = trim(getGroup(strfind(tok, "\\s.*\\s"),1,0)) ; padType = "")]
		<!-- get the name of the pad, in this ex. 5 -->
		[padName	= trim(getGroup(strfind(tok,"^.*?(\\w+)\\Z"),1,1))]
		<!-- check if the padType is already defined as a list -->
		[newType	= if(hasPadType && !listContains(padTypeList, padType), 1,0)]
		<!-- if the padType is not already defined add it to the type list -->
		[if(newType): padTypeList = listAppend(padTypeList, padType)]

		<!-- one list with ungrouped pads called lstPads -->
		[if(padType == "")				: lstPads = listAppend(lstPads, padName)]

		<!-- and one list per group type eg red, green or blue called lstPadRed, lstPadBlue etc. -->
		[if(newType)					: set("lstPad"+padType, padName)]
		[if(padType != "" && !newType)	: set("lstPad"+padType, listAppend(eval("lstPad"+padType), padName))]
['pause("assPads", "tok", "padType", "padName", "newType", "lstPad"+padType, "lstPads")']
	}; {}] 
}]
[h:assert(listCount(allPads), "No AssignedPads found on map", 0)]

<!-- ----------------------------------find all tokens on map to assign to the pads -------------------------->
[h:conditions	= json.set("{}", "layer", json.append("[]", "TOKEN", "HIDDEN"))]
[h:tokens		= getTokenNames(",",conditions)]
[h:tokList		= "<none>"]

[h,foreach(tok,tokens),CODE:{
	[if(!startsWith(tok, "AssignedPad ")): tokList = listAppend(tokList, tok)]
}]
[h:tokList = listSort(tokList, "A+")]

[h:assert(listCount(tokList), "No tokens found on map", 0)]

<!-- ---------------------------------Generate Input Screen based on found pads-------------------->
[h:tabNr = 0]
[h,if(listCount(padTypeList)), CODE: {
	[inputStr = ""]
	<!-- create tabs with the pads sorted per type, starting with the ungrouped pads -->
	[h,if(listCount(lstPads)), CODE:{
		<!-- the next tab contains the individual checkboxes for ungrouped pads -->
		[inputStr		= listAppend(inputStr,"tab"+tabNr+" |Ungrouped|| TAB", "##")]
		[tabNr			= tabNr +1]
		[inputStr		= listAppend(inputStr,"junk|<html><b>Assign the tokens to the pads</b></html>|-|LABEL|SPAN=TRUE", "##")]
		[foreach(pad, lstPads): inputStr = listAppend(inputStr, "AssignedPad_"+pad+"|"+tokList+"|"+pad+" |LIST|SELECT="+listFind(tokList, getProperty("w42.bot.linkedToken", "AssignedPad "+pad))+" VALUE=STRING", "##")]
	}; {}]
	
	<!-- and then the grouped pads -->
	[h,foreach(padType, padTypeList), CODE:{
		[inputStr		= listAppend(inputStr,"tab"+tabNr+" |"+padType+"|| TAB", "##")]
		[tabNr			= tabNr +1]
		[inputStr		= listAppend(inputStr,"junk|<html><b>Assign the tokens to the pads</b></html>|-|LABEL|SPAN=TRUE", "##")]

		[lstGroupPads	= eval("lstPad"+padType)]
		[foreach(pad, lstGroupPads): inputStr = listAppend(inputStr, "AssignedPad_"+padType+"_"+pad+"|"+tokList+"|"+pad+" |LIST|SELECT="+listFind(tokList, getProperty("w42.bot.linkedToken", "AssignedPad "+padType+" "+pad))+" VALUE=STRING", "##")]
	}]
}; {
	<!-- if there are only ungrouped pads then create a single input listing all assigned pads-->
	[inputStr			= "junk|<html><b>Check the Pads to execute </b></html>|-|LABEL|SPAN=TRUE"]
	[foreach(pad, lstPads): inputStr = listAppend(inputStr, "AssignedPad_"+pad+"|1|"+pad+" | CHECK", "##")]
}]

<!-- ask for input -->
[h: inputStr			= listFormat(inputStr, "input( %list )", " ' %item ' ", ", ", "##")]
[H: abort(eval(inputStr))]

<!-- --------------------------------- assign the tokens to the pads-------------------->
[h, foreach(pad, lstPads): setProperty("w42.bot.linkedToken", eval("AssignedPad_"+pad), "AssignedPad "+pad )]
[h,foreach(padType, padTypeList), CODE:{
	[lstGroupPads	= eval("lstPad"+padType)]
	[foreach(pad, lstGroupPads): setProperty("w42.bot.linkedToken", eval("AssignedPad_"+padType+"_"+pad), "AssignedPad "+padType+" "+pad )]
}]

@@execAssignPads
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=1 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=7. Assigned Pads ; tooltip= ; minWidth=90 ; 
[h:'<!-- ---------------------Execute Assigned Pads----------------------------------------------------------------------->']
[h:debug = 0]

<!-- optional argument: 1 to autoexec ALL -->
[h,if(argCount()):		execAll	= arg(0); execAll = 0]
[h,if(argCount() > 1):	group	= arg(1); group = ""]

[h:conditions	= json.set("{}", "layer", json.append("[]", "TOKEN", "HIDDEN", "OBJECT", "BACKGROUND"))]
[h:assPads		= listSort(getTokenNames(",",conditions),"A+")]
[h:allPads		= ""]
[h:padTypeList	= ""]
[h:padType		= ""]
[h:lstPads		= ""]

<!-- ----------------------------------find all assigned pads and filter them into seperate lists -------------------------->
[h,foreach(tok,assPads),CODE:{
	[linkedToken = getProperty("w42.bot.linkedToken", tok)]
	[if(startsWith(tok, "AssignedPad ") &&  linkedToken != "<none>" && linkedToken != ""), CODE:{
		<!-- make a list of all the pads -->
		[allPads	= listAppend(allPads, tok)]
		<!-- check if a group is defined eg AssignedPad Red 5 -->
		[hasPadType	= if(getFindCount(strfind(tok, "\\s"))==2, 1,0)]
		<!-- if a group is defined eg AssignedPad Red 5, retrieve the type, in this case Red-->
		[if(hasPadType): padType = trim(getGroup(strfind(tok, "\\s.*\\s"),1,0)) ; padType = "")]
		<!-- get the name of the pad, in this ex. 5 -->
		[padName	= trim(getGroup(strfind(tok,"^.*?(\\w+)\\Z"),1,1))]
		<!-- check if the padType is already defined as a list -->
		[newType	= if(hasPadType && !listContains(padTypeList, padType), 1,0)]
		<!-- if the padType is not already defined add it to the type list -->
		[if(newType): padTypeList = listAppend(padTypeList, padType)]

		<!-- one list with ungrouped pads called lstPads -->
		[if(padType == "")				: lstPads = listAppend(lstPads, padName)]

		<!-- and one list per group type eg red, green or blue called lstPadRed, lstPadBlue etc. -->
		[if(newType)					: set("lstPad"+padType, padName)]
		[if(padType != "" && !newType)	: set("lstPad"+padType, listAppend(eval("lstPad"+padType), padName))]

		[if(debug): bot_debugInfo("tok, padType, padName, newType, lstPads",1)]

		}; {}] 
}]

[h:assert(listCount(allPads), "No AssignedPads found on map", 0)]

<!-- special case if the macro is called with the arg = 1 -->
[h,if(execAll), CODE:{
	[foreach(pad, allPads), CODE:{
		[switchToken(pad)]
		[hasPadType	= if(getFindCount(strfind(pad, "\\s"))==2, 1,0)]
		[if(hasPadType): padType = trim(getGroup(strfind(pad, "\\s.*\\s"),1,0)) ; padType = "")]
		[linkedToken	= getProperty("w42.bot.linkedToken")]
		[if(group == "" || group == padType): moveToken(getTokenX(0), getTokenY(0), 0, linkedToken)]
	}]
	<!-- make sure no more code runs after this without using abort -->
	[padTypeList = ""]
	[lstPads = ""]
}]

<!-- ---------------------------------Generate Input Screen based on found pads-------------------->
[h:tabNr = 0]
[h,if(listCount(padTypeList)), CODE: {
	<!-- if there are pads with a group type e.g. red, green, blue. Then create a front tab where you can check/uncheck entire groups -->
	[inputStr			= "tab"+tabNr+" |Groups|| TAB"]
	[tabNr				= tabNr +1]
	[inputStr			= listAppend(inputStr,"junk|<html><b>Check the Groups to execute </b></html>|-|LABEL|SPAN=TRUE")]
	<!-- ungrouped pads -->
	[if(listCount(lstPads)): inputStr = listAppend(inputStr, "ungroupedPads|1|Ungrouped pads|CHECK") ; ungroupedPads = 0]
	<!-- grouped pads -->
	[foreach(padType, padTypeList): inputStr = listAppend(inputStr, "group"+padType+"|1|"+padType+" | CHECK")]
	
	<!-- next create tabs with the pads sorted per type, starting with the ungrouped pads -->
	[if(listCount(lstPads)), CODE:{
		<!-- the next tab contains the individual checkboxes for ungrouped pads -->
		[inputStr		= listAppend(inputStr,"tab"+tabNr+" |Ungrouped|| TAB")]
		[tabNr			= tabNr +1]
		[inputStr		= listAppend(inputStr,"junk|<html><b>Check the Pads to execute </b></html>|-|LABEL|SPAN=TRUE")]
		[foreach(pad, lstPads): inputStr = listAppend(inputStr, "AssignedPad_"+pad+"|1|"+pad+" | CHECK")]
	}; {}]
	
	<!-- and then the grouped pads -->
	[foreach(padType, padTypeList), CODE:{
		[inputStr		= listAppend(inputStr,"tab"+tabNr+" |"+padType+"|| TAB")]
		[tabNr			= tabNr +1]
		[inputStr		= listAppend(inputStr,"junk|<html><b>Check the Pads to execute </b></html>|-|LABEL|SPAN=TRUE")]

		[lstGroupPads	= eval("lstPad"+padType)]
		[foreach(pad, lstGroupPads): inputStr = listAppend(inputStr, "AssignedPad_"+padType+"_"+pad+"|1|"+pad+" | CHECK")]
	}]
}; {
	<!-- if there are only ungrouped pads then create a single input listing all assigned pads-->
	[ungroupedPads = 1]
	[inputStr			= "junk|<html><b>Check the Pads to execute </b></html>|-|LABEL|SPAN=TRUE"]
	[foreach(pad, lstPads): inputStr = listAppend(inputStr, "AssignedPad_"+pad+"|1|"+pad+" | CHECK")]
}]

<!-- ask for input -->
[h: inputStr			= listFormat(inputStr, "input( %list )", " ' %item ' ", ",")]
[H, if(!execAll): abort(eval(inputStr))]

<!-- ---------------------------------Execute assigned pads-------------------->
[h,if(ungroupedPads), CODE:{
	[foreach(pad, lstPads), CODE:{
		[switchToken("AssignedPad "+pad)]
		[if(eval("AssignedPad_"+pad)):moveToken(getTokenX(0), getTokenY(0), 0, getProperty("w42.bot.linkedToken"))]
	}]
}; {}]

[h,foreach(padType, padTypeList), if(eval("group"+padType)), CODE:{
	[lstGroupPads	= eval("lstPad"+padType)]
	[foreach(pad, lstGroupPads), CODE:{
		[switchToken("AssignedPad "+padType+" "+pad)]
		[if(eval("AssignedPad_"+padType+"_"+pad)):moveToken(getTokenX(0), getTokenY(0), 0, getProperty("w42.bot.linkedToken"))]
	}]
}]

@@autoDisguiseButton
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=4 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Aliasmask Usediguise ; tooltip=<html>When you click this, a text box will appear with<br>a token property you can add to your Campaign<br>Property token properties to automatically<br>add the <i>Use Disguise</i> button to tokens.</html> ; minWidth= ; 
[h:'<!-- -------------------------------------- autoDisguiseButton -------------------------------------------------------- -->']
<!--
<html>When you click this, a text box will appear with<br>a token property you can add to your Campaign<br>Property token properties to automatically<br>add the <i>Use Disguise</i> button to tokens.</html>
-->
[H, if(json.isEmpty(macro.args)), CODE: {
	[propText		= '*autoDisguiseButton:[macro("autoDisguiseButton@lib:disguise"): currentToken()]']
	[input(
		"label|<html><b>Copy text in to Token Property to auto load Disguise Button:</b><br></html>||LABEL|SPAN=TRUE",
		strformat("Text|%{propText}||TEXT|SPAN=TRUE WIDTH=50")
	)]
};{
	[id				= json.get(macro.args,0)]
	[switchToken(id)]
	[disguiseMacro	= getLibProperty("am.bot.disguiseMacro",getMacroLocation())]
	[setProperty("autoDisguiseButton","")]
	[if(!hasMacro("Use Disguise")): createMacro(disguiseMacro)]
}]

@@useDisguise
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=5 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Aliasmask Usediguise ; tooltip=<html> - Clicking the <i>Use Disguise</i> button will add the current token image to your disguise list.<br> - Changing your image and clicking the button again will add a new image to list.<br> OR<br> - Selecting <i>image:tokens</i> together with the token will add those images to the disguise<br>list of the token<br><br>- A list will be shown for all the possible images you have loaded.<br> - You have the option to Change or Delete an image from your list.<br> - On the lib file, if you click <i>autoDisguiseButton</i> a text box will appear with a token<br>property you can add to your Campaign Property token properties to automatically add the<br> <i>Use Disguise</i> button to tokens.</html> ; minWidth=90 ; 
[h:'<!-- -------------------------------------- useDisguise (optional; tablename) -------------------------------------------------------- -->']

[h:'<!-- 
<html> - Clicking the <i>Use Disguise</i> button will add the current token image to your disguise list.<br> - Changing your image and clicking the button again will add a new image to list.<br> OR<br> - Selecting <i>image:tokens</i> together with the token will add those images to the disguise<br>list of the token<br><br>- A list will be shown for all the possible images you have loaded.<br> - You have the option to Change or Delete an image from your list.<br> - On the lib file, if you click <i>autoDisguiseButton</i> a text box will appear with a token<br>property you can add to your Campaign Property token properties to automatically add the<br> <i>Use Disguise</i> button to tokens.</html> 
-->']
[h, if(argCount() > 1): tTableName = arg(1); tTableName = "Polymorph" ]

[h:toks		= getSelected()]

[h:imgList	= ""]
[h, if(bot_inStr(toks, "image")), CODE:{
	[me		= ""]
	[foreach(tok, toks), CODE:{
		[if(bot_inStr(tok, "image")): imgList	= listAppend(imgList, getImage(tok)) ; me = listAppend(me,tok)]
	}]
	[toks	= me]
};{}]

[h:assert(listCount(toks)==1, "Make sure (only) one token (other then an 'image:token') is selected",0)]
[h:switchToken(toks)]

[h: jTables		= json.get(getInfo("campaign"),"tables") ]
[h: hasTable	= json.contains(jTables,tTableName) ]
[h: jAll		= "[]"]
[h, if(hasTable): cntAll = table(tTableName, 0); cntAll = 0]
[h, if(hasTable), for(i,1,cntAll+1): jAll = json.append(jALL, tableimage(tTableName, i))]

[h: jVis		= "[]"]
[h: tTokens		= json.difference(getVisibleTokens("json"), json.fromList(toks))]
[h, foreach( tok, tTokens ),CODE: {
	[TOKEN(tok): jVis = json.append(jVis, getTokenImage()) ]
}]
[jvis	= json.unique(jvis)]

[h: disguises	= getProperty("am.bot.disguise")]
[h, if(json.isEmpty(disguises)): disguises	= "[]"]
[h, if(listCount(imgList)): disguises = json.union(disguises, json.fromList(imgList))]

[h: tokenImg	= getTokenImage()]
[h: inputStr	= "Images available on selected token | Disguise | | TAB"]
[h, if(!json.contains(disguises,tokenImg)), CODE: {
	[disguises	= json.append(disguises,tokenImg)]
	[inputStr	= json.append(inputStr,
		"label|<html><b>Token Image added to Disguise List:</b></html>||LABEL|SPAN=TRUE",
		strformat("tip|<html>%{tokenImg}</html>||LABEL|SPAN=TRUE ICONSIZE=100 ICON=TRUE")
	)]
};{
	[inputStr	= json.append(inputStr,"label|<html><b>Change Token Image to add to Diguise List</b></html>||LABEL|SPAN=TRUE")]
}]

[h: nSelect		= json.indexOf(disguises, tokenImg)]
[h: menu		= -1]

[h, if(json.length(disguises) > 1): inputStr	= json.append(inputStr,
	strformat("Menu|Change Image, Delete Image||RADIO|SPAN=TRUE SELECT=%{menu}")
)]

[h: inputStr	= json.append(inputStr,strformat("image|%s||LIST|ICON=TRUE SPAN=TRUE ICONSIZE=40 VALUE=STRING SELECT="+nSelect,json.toList(disguises)),
	"label|<html><br><font color=red><i><b>Hit Cancel to close...</b></i></font></html>||LABEL|SPAN=TRUE")]

[H, if(! json.isEmpty(jVis)): 
	inputStr = json.append(
		inputStr,"Images from tokens visible on this map | Visible Map Images | | TAB",
	   strformat("image2|%s||LIST|ICON=TRUE SPAN=TRUE VALUE=STRING",(" ,"+json.toList(jVis))),
	   'label|<html><br><font color=red><i><b>Hit "Cancel" to close...</b></i></font></html>||LABEL|SPAN=TRUE'
	)
]

[h:image3		= ""]
[h, if(hasTable): 
	inputStr	= json.append(
		inputStr, "Images from the table 'Polymorph' | " + tTableName + " Table Images | | TAB",
		strformat("image3|%s||LIST|ICON=TRUE SPAN=TRUE VALUE=STRING",(" ,"+json.toList(jAll))),
		"label|<html><br><font color=red><i><b>Hit Cancel to close...</b></i></font></html>||LABEL|SPAN=TRUE"
	)
;
	inputStr	= json.append(
		inputStr, "Images from the table 'Polymorph' | " + tTableName + " Table Images | | TAB",
		strformat("label|<html>The table 'Polymorph' does not exist. You will need to create it first:<br>- open panel: menu-->window-->tables<br>- create new table Polymorph<br>- first entry 'range':0 'value': enter total nr of images in table<br>- the rest start with 'range' 1, leave 'value' blank and add an image.<br><br><font color=red><i><b>Hit Cancel to close...</b></i></font></html>||LABEL|SPAN=TRUE")
	)
]

[h: hasInput	= input(json.toList(inputStr,"##"))]

[h, if(hasInput), CODE: {
	[if(image2 != ""):									image		= image2; "" ]
	[if(image3 != ""):									image		= image3; "" ]
	[if(menu == 0 || image2 != "" || image3 != "" ):	setTokenImage(image)]
	[if(menu == 0):										setTokenImage(image)]
	[if(menu == 1):										disguises	= json.difference(disguises,json.append("",image))]
	[if(!json.isEmpty(disguises)):						setProperty("am.bot.disguise",json.difference(disguises,json.append("","")))]
	[macro("useDisguise@lib:OnTokenMove"): ""]
};{
	[if(!json.isEmpty(disguises)):						setProperty("am.bot.disguise",json.difference(disguises,json.append("","")))]
}]

@@bringToFront
@PROPS@ fontColor=darkgray ; autoExecute=true ; fontSize=1.00em ; sortBy=12 ; color=default ; playerEditable=false ; applyToSelected=false ; group=9. Order ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------- bringToFront (Current Selection) --------------------------------------->']

<!-- bring current selection to front -->
[h:ids			= getSelectedNames("json")]
[h:idsJson		= bot_createSplices(ids)]
[h:jsonOrder	= "[]"]
[h,foreach(group, idsJson), CODE:{
	[foreach(tok, group), CODE:{
		[jsonOrder	= json.append(jsonOrder, json.set("{}","id", tok, "order", getTokenDrawOrder(tok)))]
	}]
}]
<!-- sort the json according to the current order -->
[h:jsonOrder	= json.sort(jsonOrder,"a","order")]
<!-- bring first entry to front, after that a deferred loop is required cause the z order is updated AFTER the routine is finished -->
[h:bringToFront(json.get(json.get(jsonOrder, 0),"id"))]

<!-- start deferred loop -->
[h: link = macroLinkText("deferBtF@lib:OnTokenMove", "none", jsonOrder)]
[h: execLink(link,1)]

@@bringToFront
@PROPS@ fontColor=darkgray ; autoExecute=true ; fontSize=1.00em ; sortBy=12 ; color=default ; playerEditable=false ; applyToSelected=false ; group=9. Order ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------- bringToFront (Current Selection) --------------------------------------->']

<!-- bring current selection to front -->
[h:ids			= getSelectedNames("json")]
[h:idsJson		= bot_createSplices(ids)]
[h:jsonOrder	= "[]"]
[h,foreach(group, idsJson), CODE:{
	[foreach(tok, group), CODE:{
		[jsonOrder	= json.append(jsonOrder, json.set("{}","id", tok, "order", getTokenDrawOrder(tok)))]
	}]
}]
<!-- sort the json according to the current order -->
[h:jsonOrder	= json.sort(jsonOrder,"a","order")]
<!-- bring first entry to front, after that a deferred loop is required cause the z order is updated AFTER the routine is finished -->
[h:bringToFront(json.get(json.get(jsonOrder, 0),"id"))]

<!-- start deferred loop -->
[h: link = macroLinkText("deferBtF@lib:OnTokenMove", "none", jsonOrder)]
[h: execLink(link,1)]

@@decDrawOrder
@PROPS@ fontColor=darkgray ; autoExecute=true ; fontSize=1.00em ; sortBy=11 ; color=default ; playerEditable=false ; applyToSelected=false ; group=9. Order ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------- decDrawOrder (Current Selection) --------------------------------------->']

<!-- bring current selection to front -->
[h:ids			= getSelected("json")]
[h:idsJson		= bot_createSplices(ids)]
[h:jsonOrder	= "[]"]
[h,foreach(group, idsJson), CODE:{
	[foreach(tok, group), CODE:{
		[jsonOrder	= json.append(jsonOrder, json.set("{}","id", tok, "order", getTokenDrawOrder(tok)))]
	}]
}]

<!-- sort the json according to the current order -->
[h:jsonOrder	= json.sort(jsonOrder,"a","order")]

<!-- bring current selection to front -->
[h:idsJson	= bot_createSplices(jsonOrder)]
[h,foreach(group, idsJson), CODE:{
	[foreach(item, group): setTokenDrawOrder(json.get(item,"order")-1,json.get(item,"id"))]
}]

[h:broadcast("Selected tokens draw order have been increased with one step")]

@@incDrawOrder
@PROPS@ fontColor=darkgray ; autoExecute=true ; fontSize=1.00em ; sortBy=10 ; color=default ; playerEditable=false ; applyToSelected=false ; group=9. Order ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------- incDrawOrder (Current Selection) --------------------------------------->']

<!-- bring current selection to front -->
[h:ids			= getSelected("json")]
[h:idsJson		= bot_createSplices(ids)]
[h:jsonOrder	= "[]"]
[h,foreach(group, idsJson), CODE:{
	[foreach(tok, group), CODE:{
		[jsonOrder	= json.append(jsonOrder, json.set("{}","id", tok, "order", getTokenDrawOrder(tok)))]
	}]
}]

<!-- sort the json according to the current order -->
[h:jsonOrder	= json.sort(jsonOrder,"a","order")]

<!-- bring current selection to front -->
[h:idsJson	= bot_createSplices(jsonOrder)]
[h,foreach(group, idsJson), CODE:{
	[foreach(item, group): setTokenDrawOrder(json.get(item,"order")+1,json.get(item,"id"))]
}]

[h:broadcast("Selected tokens draw order have been increased with one step")]

@@openOrderFrame
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy=1 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=9. Order ; tooltip=<html>This opens a 'group select' frame which is required for the 'Select Group' to function.<br>When this panel is closed you can still group and ungroup, but the 'auto select' will only<br>work when this frame is active. ; minWidth=90 ; 
[h:'<!------------------------------------- openOrderFrame ------------------------------------------------>']
<!-- <html> Turns on door switches at selected players. This will allow players to use doorswitches -->
[h:assert(isGM(),"This macro can only be run by the GM",0)]
[h:userList	= getAllPlayerNames()]

[h,if(listCount(userList) != 1), CODE:{
	[h:'<!-- input string -->']
	[h:inputStr	= "junk|<html><b>Turn on door switches for selected players<br></html>|-|LABEL|SPAN=TRUE"]
	[H,FOREACH(player, userList): inputStr = listAppend(inputStr, "player"+roll.count+"|1|"+player+"|CHECK","@")]

	[h:'<!-- ask for input-->']
	[h:abort(eval(listFormat(inputStr, "input( %list )", " ' %item ' ", ",", "@")))]

	[h:playerList = ""]
	[H,FOREACH(player, userList), CODE:{
		[if(eval("player"+roll.count)): playerList = listAppend(playerList, player)]
	}]
};{
	[h:playerList = userList]
}]

<!-- need to make certain that this value is initialized on lib eventmacros -->
[h:bot_resetTimer(3)]
[h:bot_execAllPlayers("orderFrame@lib:OnTokenMove","", playerList)]

@@orderFrame
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy=1 ; color=default ; playerEditable=false ; applyToSelected=false ; group=9. Order ; tooltip= ; minWidth=90 ; 
[h:'<!-- ------------------ orderFrame ----------------------------------->']
[h:debug = 0]

[h: doShape	= getLibProperty('vblSupport','lib:EventMacros')]

<!-- first order the selection in ascending z-order -->
[h:currentSelection	= getSelected("json")]

<!-- retrieve current layer -->
[h:token		= ""]
[h:hidden		= ""]
[h:object		= ""]
[h:background	= ""]

<!-- retrieve last setting -->
[h:degrees		= getLibProperty('w42.bot.processOrder.degrees','lib:EventMacros')]
[h,if(!isNumber(degrees)): degrees = 90]

[h,if(json.length(currentSelection)):layer		= getLayer(json.get(currentSelection,0));layer="TOKEN"]
[h,switch(layer):
	case "TOKEN":		token		= "selected";
	case "HIDDEN":		hidden		= "selected";
	case "OBJECT":		object		= "selected";
	case "BACKGROUND":	background	= "selected";
	default:			token		= "selected";
]

<!-- retrieve current shape (first token only) b89+ -->
[h,if(doShape),CODE:{
	[h:TOPDOWN	= ""]
	[h:CIRCLE	= ""]
	[h:SQUARE	= ""]

	[h,if(json.length(currentSelection)):shape		= getTokenShape(json.get(currentSelection,0));shape="TOPDOWN"]
	[h,switch(shape):
		case "Top down":	TOPDOWN		= "selected";
		case "Circle":		CIRCLE		= "selected";
		case "Square":		SQUARE		= "selected";
		default:			TOPDOWN		= "selected";
	]
};{}]]

<!-- sort the json according to the current order -->
[h:jsonOrder		= "[]"]
[h,foreach(tok, currentSelection), CODE:{
	[jsonOrder		= json.append(jsonOrder, json.set("{}","id", tok, "order", getTokenDrawOrder(tok)))]
}]
[h,if(debug): bot_debugInfo("jsonOrder")]
[h:jsonOrder		= json.sort(jsonOrder,"a","order")]
<!-- create list of tokens with their order and find the lowest and highest value -->
[h:orderString		= "<table border=1><tr><td>Token</td><td>Img</td><td>Z-Order"]
[h:numSelect		= json.length(jsonOrder)]
[h,if(numSelect), CODE:{
	[minOrder			= json.get(json.get(jsonOrder,0), "order")]
	[maxOrder			= json.get(json.get(jsonOrder,numSelect-1), "order")]
	[foreach(tok, jsonOrder), CODE:{
		[tokId	= json.get(tok,"id")]
		[token(tokId): orderString	= listAppend(orderString, strformat("%s</td><td><img height='20' width='20' src='%s'></img></td><td><input size='5' type='text' name=%{tokId} value=%s>", getName(tokId), getTokenImage(), getTokenDrawOrder(tokId)), "</td></tr><tr><td>")]
	}]
};{
	[minOrder			= ""]
	[maxOrder			= ""]
}]
[h:orderString		= orderString + "</td></tr></table>"]
[h,if(isFrameVisible("Group Select Panel")), CODE:{
	[link		= "" ]
	[groupTxt	= "<font color='red'>When you close the <b><u>Group Select Panel</u></b> you need to restart this order panel or it won't work</font>"]
};{
	[link		= macroLinkText("orderHandler@Lib:OnTokenMove", "none")]
	[groupTxt	= ""]
}]

<!-- create the frame -->
[frame("Draw Order", "width=70; height=4; temporary=1"): {
	<html>
		<head>
			<!-- only onchangeselect if the group order panel is NOT open. Else the group order panel will call this function itself -->
			<link rel='onChangeSelection' type='macro' href='[r: link]'>
		</head>
		<body>
			<form action='[r:macroLinkText("processOrder@Lib:OnTokenMove", "none")]' method="json">
			<table  cellpadding='0' cellspacing='0'>
				<tr><td>
						<input type="submit" name="button" value="-1"	>
					</td><td>
						<input type="submit" name="button" value="-10"	>
					</td><td>
						<input type="submit" name="button" value="-100"	>
					</td><td>
						<input type="submit" name="button" value="-1000">
				</td></tr><tr><td>
						<input type="submit" name="button" value="+1"	>
					</td><td>
						<input type="submit" name="button" value="+10"	>
					</td><td>
						<input type="submit" name="button" value="+100"	>
					</td><td>
						<input type="submit" name="button" value="+1000">
				</td></tr><tr><td colspan=4 width=196>
						<input type="submit" name="button" value="Reorder Selection"	>&nbsp;
						<input type="submit" name="button" value="Reorder ALL"	>
				</td></tr>
			</table>
			<table border=1><tr><td>min</td><td>[r:minOrder] </td><td>max</td><td>[r:maxOrder] </td><td>Total</td><td>[r:numSelect] </td><td><input type="submit" name="button" value="Help"	></td></tr></table>

			<table cellpadding='0' cellspacing='0'><tr><td align="right">
					<input type="submit"	name="button"	value="<- Rotate Tokens"	>&nbsp;
				</td><td>
					Degr:
				</td><td>
					<input type="submit"	name="button"	value="Rotate Tokens ->"	>
			</td></tr><tr><td align="right">
					<input type="submit"	name="button"	value="<- Rotate Group"		>&nbsp;
				</td><td>
					<input type="text"		name="degrees"	value="[r:degrees]"	size="3">&nbsp;
				</td><td>
					<input type="submit"	name="button"	value="Rotate Group ->"		>
			</td></tr><tr><td align="right">
					<input type="submit"	name="button"	value="Rotate Random"			>&nbsp;
				</td><td>
				</td><td>
					<input type="submit"	name="button"	value="Remove Rotation"			>
			</td></tr><tr><td colspan="3" align="center">
					________________________________
			</td></tr><tr><td>
					<input type="submit" name="button" value="Submit Change"	>
				</td><td>
				</td><td>
					<input type="submit" name="button" value="Reset Change"		>
			</td></tr><tr><td>
					Layer
				</td><td>
				</td><td>
					Shape
				</td></tr><tr><td>
					<select name="layer" size="1">
						<option "[r:TOKEN]">TOKEN</option>
						<option "[r:HIDDEN]">HIDDEN</option>
						<option "[r:OBJECT]">OBJECT</option>
						<option "[r:BACKGROUND]">BACKGROUND</option>
					</select>
				</td><td>
				</td><td>
					[r,if(doShape),CODE:{
						<select name="shape" size="1">
							<option "[r:TOPDOWN]">TOP DOWN</option>
							<option "[r:CIRCLE]">CIRCLE</option>
							<option "[r:SQUARE]">SQUARE</option>
						</select>
					};{b89+ only}]
			</td></tr></table>
			<!--	getTokenShape()
					setTokenShape(Shape) -->
			
			[r:orderString]
			[r:groupTxt]
		</form>
		</body>
	</html>
}]

@@orderHandler
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=2 ; color=default ; playerEditable=false ; applyToSelected=false ; group=9. Order ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------- orderHandler () --------------------------------------->']
[h:maxOrderSelect	= getLibProperty('maxOrderSelect','lib:EventMacros')]
[h:currentSelection	= getSelected("json")]
[h:numSelect		= json.length(currentSelection)]
[h,if(numSelect > maxOrderSelect), CODE:{
	[bot_orderWarning(numSelect)]
	[abort(0)]
};{}]

[h, if(bot_timeOut(3)), CODE:{
	[bot_resetTimer(3)]
	[bot_orderFrame()]
	[bot_resetTimer(3)]
};{}]

@@orderWarning
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy=2 ; color=default ; playerEditable=false ; applyToSelected=false ; group=9. Order ; tooltip= ; minWidth=90 ; 
[h:'<!-- ------------------ orderFrameWarning ----------------------------------->']
[h: tooMany	= arg(0)]

[h,if(isFrameVisible("Group Order Panel")): link = "" ; link = macroLinkText("orderHandler@Lib:OnTokenMove", "none")]

[frame("Group Order", "width=70; height=4; temporary=1"): {
	<html>
		<head>
			<link rel='onChangeSelection' type='macro' href='[r: link]'>
		</head>
		<body>
			You have currently too many tokens selected: [r:tooMany]
		</body>
	</html>
}]

@@processOrder
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=3 ; color=default ; playerEditable=false ; applyToSelected=false ; group=9. Order ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------- processOrder () --------------------------------------->']
[h:doShape	= getLibProperty('vblSupport','lib:EventMacros')]
[h:result		= macro.args]
['pause("result")']
[h:toks		= json.fields(result)]

<!-- remove the no tokens arguments results -->
[h:toks		= listDelete(toks, listFind(toks,"degrees"))]
[h:toks		= listDelete(toks, listFind(toks,"button"))]
[h:toks		= listDelete(toks, listFind(toks,"layer"))]
[h:toks		= listDelete(toks, listFind(toks,"shape"))]

[h:output		= ""]
[h:degrees	= json.get(result, "degrees")]
[h:setLibProperty('w42.bot.processOrder.degrees',degrees, 'lib:EventMacros')]

<!-- set layer -->
[h:layer		= json.get(result, "layer")]
[h,if(listCount(toks)):oldLayer = getLayer(listGet(toks,0)) ; oldLayer = layer]
[h,if(layer != oldLayer), CODE:{
	[foreach(tok, toks): setLayer(layer, tok)]
};{}]

<!-- set shape -->
[h,if(doShape), CODE:{
	[shape		= json.get(result, "shape")]
	[if(listCount(toks)):oldShape = getTokenShape(listGet(toks,0)) ; oldShape = shape]
	[if(shape != oldShape), CODE:{
		[foreach(tok, toks), CODE:{ 
			[token(tok):setTokenShape(shape)]
		''
		}]
	''
	};{}]
''
};{}]

<!-- do the buttons -->
[h:button	= json.get(result, "button")]

<!-- apply new draw order -->
[h,if(isNumber(button)), CODE:{
	[foreach(tok, toks): setTokenDrawOrder(json.get(result, tok)+button, tok)]
};{
	<!-- apply the other stuff -->
	[switch(button),code:
	case "Reorder Selection": {
		[selected	= getSelected("json")]
		[bot_reOrderTokens(selected)]
		[selectTokens(selected, 0, "json")]
	};
	case "Reorder ALL": {
		[selected	= getSelected("json")]
		[bot_reOrderTokens()]
		[selectTokens(selected, 0, "json")]
	};
	case "<- Rotate Tokens" : {
		[foreach(tok, toks): bot_setTokenFacing(bot_getTokenFacing(tok)+degrees, tok)]
	};
	case "Rotate Tokens ->" : {
		[foreach(tok, toks): bot_setTokenFacing(bot_getTokenFacing(tok)-degrees, tok)]
	};
	case "<- Rotate Group" : {
		[bot_rotateCCW()]
	};
	case "Rotate Group ->" : {
		[bot_rotateCW()]
	};
	case "Rotate Random" : {
		[stepSize	= round(360/degrees,0)]
		[foreach(tok, toks): bot_setTokenFacing(roll(1,stepSize)*degrees, tok)]
	};
	case "Remove Rotation" : {
		[foreach(tok, toks): removeTokenFacing(tok)]
	};
	case "Submit Change": {
		[foreach(tok, toks): setTokenDrawOrder(json.get(result, tok), tok)]
	};
	case "Reset Change": {
	};
	case "Help": {
		[output	= "
		This panel can be used for reordering the draw order (aka z-order) of the tokens on the map. If you select a couple of tokens you will notice that they appear below. Some pointers:<br>
		<br>
		<table><tr><td width='100'>
			<b>MIN/MAX/Total</b>		</td><td>The min/max shows the minimum and maximum draw order of the current selection. </td></tr><tr><td>
			<b>Z-ORder</b>				</td><td>You can enter a draw order number directly next to the token. When you click 'submit change' it will be applied</td></tr><tr><td>
			<b>reset change</b>			</td><td>resets the changes you've just made (but does not undo applied changes)</td></tr><tr><td>
			<b>+/- 1/10/100/1000</b>	</td><td>adds that number to the z-order of the current selection</td></tr><tr><td>
			<b>reorder all</b>			</td><td>orders ALL TOKENS ON ALL LAYERS in consecutive order, starting at 0. Their relative order remains intact</td></tr><tr><td>
			<b>reorder selection</b>	</td><td>orders all currently selected tokens consecutively, starting at the lowest value order. Their relative order remains intact. </td></tr><tr><td>
			<b>&lt;- Rotate Tokens</b>	</td><td>Rotates the individual tokens the give amount of degrees Counter Clockewise</td></tr><tr><td>
			<b>Rotate Tokens -></b>		</td><td>Rotates the individual tokens the give amount of degrees Clockewise</td></tr><tr><td>
			<b>&lt;- Rotate Group</b>	</td><td>Rotates the entire selected group 45 (unsnapped) or 90 (snapped) degrees Counter Clockewise</td></tr><tr><td>
			<b>Rotate Group -></b>		</td><td>Rotates the entire selected group 45 (unsnapped) or 90 (snapped) degrees Clockewise</td></tr><tr><td>
			<b>Rotate Random</b>		</td><td>Rotates the individual tokens the give amount of degrees in random steps. So e.g. 90 degrees will rotate a token either 0,90,180,270 degrees</td></tr><tr><td>
			<b>Remove Rotations</b>		</td><td>Clears token facing</td></tr><tr><td>
			<b>Layer</b>				</td><td>Will set ALL selected tokens to the layer of your choice</td></tr><tr><td>
			<b>Shape</b>				</td><td>(b89+) Will set ALL selected tokens to the shape of your choice.
		</td></tr><table>
		"]
	};
	default: {}]

}]
[h,if(output != ""), CODE:{
	[frame("Group Order Help", "width=500; height=100; temporary=1"): {[r:output]}]
};{}]

[h:bot_orderFrame()]

@@reOrderTokens
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=4 ; color=default ; playerEditable=false ; applyToSelected=false ; group=9. Order ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------- reOrderTokens ([array of tokens]) --------------------------------------->']

<!-- 
get all tokens from map and store them in a json array as json objects with id and current order 
OR
get all the tokens currently fed to the function
-->
[h: hasArg	= argCount()]
[h,if(hasArg): ids	= arg(0) ; ids = getTokens("json", json.set("{}", "layer", json.append("[]","TOKEN","HIDDEN","OBJECT","BACKGROUND")))]

[h:idsJson		= bot_createSplices(ids)]
[h:jsonOrder	= "[]"]
[h,foreach(group, idsJson), CODE:{
	[foreach(tok, group), CODE:{
		[jsonOrder	= json.append(jsonOrder, json.set("{}","id", tok, "order", getTokenDrawOrder(tok)))]
	}]
}]

<!-- sort the json according to the current order -->
[h:jsonOrder	= json.sort(jsonOrder,"a","order")]

<!-- set the new draw orders for all the tokens -->
[h:idsJson	= bot_createSplices(jsonOrder)]
<!-- if its a selection that needs to be reordered then start with the lowest entry of the selection. Else start at 0 -->
[h:i		= if(hasArg, json.get(json.get(jsonOrder, 0), "order"), 0)]
[h,foreach(group, idsJson), CODE:{
	[foreach(item, group), CODE:{
		[id	= json.get(item, "id")]
		[setTokenDrawOrder(i,id)]
		[i	= i + 1]
	}]
}]

<!-- broadcast the old order -->
[output	= if(hasArg, "The z-order of the selected tokens have been reordered", "The z-order of ALL the tokens on the entire map have been reordered")]
[h:broadcast(output)]

@@sendToBack
@PROPS@ fontColor=darkgray ; autoExecute=true ; fontSize=1.00em ; sortBy=13 ; color=default ; playerEditable=false ; applyToSelected=false ; group=9. Order ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------- sendToBack (Current Selection) --------------------------------------->']

<!-- bring current selection to front -->
[h:ids			= getSelected("json")]
[h:idsJson		= bot_createSplices(ids)]
[h:jsonOrder	= "[]"]
[h,foreach(group, idsJson), CODE:{
	[foreach(tok, group), CODE:{
		[jsonOrder	= json.append(jsonOrder, json.set("{}","id", tok, "order", getTokenDrawOrder(tok)))]
	}]
}]

<!-- sort the json according to the current order -->
[h:jsonOrder	= json.sort(jsonOrder,"a","order")]

<!-- bring current selection to front -->
[h:idsJson	= bot_createSplices(jsonOrder)]
[h,foreach(group, idsJson), CODE:{
	[foreach(item, group): sendToBack(json.get(item,"id"))]
}]

[h:broadcast("Selected tokens have been send to back")]

@@buildField
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy=43 ; color=default ; playerEditable=true ; applyToSelected=false ; group=Scatter ; tooltip= ; minWidth=90 ; 
[h: '<!-- --------------------------------------- buildField --------------------------------------------------- -->']

[h:closeDialog("Map Editor")]
[H:layer	= json.get(macro.args, "layer")]
[h:removeToken(json.get(macro.args, "bound1"))]
[h:removeToken(json.get(macro.args, "bound2"))]

[h:xmin	= getLibProperty("mapField.xMin", "lib:EventMacros")]
[h:ymin	= getLibProperty("mapField.yMin", "lib:EventMacros")]
[h:xmax	= getLibProperty("mapField.xMax", "lib:EventMacros")]
[h:ymax	= getLibProperty("mapField.yMax", "lib:EventMacros")]
[h:BASE	= getLibProperty("baseMapName", "lib:EventMacros")]

[h:fieldToks	= ""]
[h,for(x, xmin, xmax+1), CODE:{
	[for(y, ymin, ymax+1), CODE:{
		[lastCopy	= copyToken("GridCoordMarker", 1, BASE, json.set("{}", "x", x, "y", y, "layer", layer))]
		[fieldToks	= json.append(fieldToks, lastCopy)]
	}]
}]

[h:setLibProperty("fieldToks", fieldToks, "lib:EventMacros")]
[h:selectTokens(lastCopy)]
[h:bot_fieldEditDialog()]

@@buildForest
@PROPS@ fontColor=green ; autoExecute=true ; fontSize=1.00em ; sortBy=21 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Scatter ; tooltip= ; minWidth=90 ; 
[h: '<!-- ------------------------------------- buildForest ------------------------------------------------------------------- -->']
<!-- <html>Select a one ore more images of a Tree top (Canopy) and click this button to randomly spread them over an area</html> -->
[h: '<!-- check if tokens are selected -->']
[h: tokList = getSelected()]
[h: assert(tokList != "", "No token(s) have been selected")]
[h: maxDensity = 20]
[h: '<!-- input asking type of token to scatter (defaults to Canopy) has also the option NOT to use a special token -->']
[h: '<!-- input also asks for several settings like size of area, rotation on off, density of tokens in that area -->']
[h:specNameList = "No special token, Canopy, Foliage, Roof, Ward, EventPad, MappedPad, PadStart, PadEnd, InterPad, PadStartBorder, PadEndBorder, InterPadBorder, PadJumpBorder, PadDropBorder, InterJumpBorder, InterDropBorder, PadJump, PadDrop, InterJump, InterDrop"]

[h:densityList = ""]
[h,count(maxDensity):densityList = listAppend(densityList,roll.count+1)]
[h:layerList = "TOKEN, HIDDEN, OBJECT, BACKGROUND"]

[h:'<!-- first check if the special token is freesize or not. If freesize retrieve its w42.size, if thats not set, set it to 1 -->']
[h:tokChkList = ""]
[h:i = 0]
[h,foreach(tok, tokList), CODE:{
	[size = getSize(tok)]
	[if(size == ""), CODE:{
		[tokChkList = listAppend(tokChkList, tok)]
		[xSize = getProperty("w42.bot.xSize", tok)]
		[ySize = getProperty("w42.bot.ySize", tok)]
		[if(isNumber(xSize)):set("xSize" + i, xSize); set("xSize" + i, 1)]
		[if(isNumber(ySize)):set("ySize" + i, ySize); set("ySize" + i, 1)]
		[i = i + 1]
	}; {
		[switchToken(tok)]
		[bot_determineTokSize()]
	}]
}]

[h:'<!-- set the tok ids into names -->']
[h:tokNameList = bot_ids2Names(tokChkList)]

[h:'<!-- build the entire input string and ask for the token sizes IF theyre freesize-->']
[h:inputStr = ""]
[h:inputStr = listAppend(inputStr, 	"junk|<html><b>make sure that freesize images are NOT snapped to grid!!</b></html>|-|LABEL|SPAN=TRUE", "@")]
[h:inputStr = listAppend(inputStr, 	"tokenName|"+specNameList+"|Type of token to scatter over the map?|LIST|VALUE=STRING SELECT=1", "@")]
[h:inputStr = listAppend(inputStr, 	"areaWidth|75|Width of designated area", "@")]
[h:inputStr = listAppend(inputStr, 	"areaLength|75|Length of designated area", "@")]
[h:inputStr = listAppend(inputStr, 	"density|"+densityList+"|Choose the density of the area (20 is the most dense)?|LIST|VALUE=STRING SELECT=14", "@")]
[h:inputStr = listAppend(inputStr, 	"layer|"+layerList+"|Choose the layer where the tokens are scattered?|LIST|VALUE=STRING SELECT=2", "@")]
[h:inputStr = listAppend(inputStr, 	"rotate|1|Rotate images when scattering?|CHECK", "@")]

[h, if(listCount(tokNameList)): inputStr	= listAppend(inputStr, "junk|<html><b>Set Size (in Cells) of Images<br></html>|-|LABEL|SPAN=TRUE", "@")]
[H,FOREACH(tok, tokNameList), CODE:{
	[varNameX = "xSize"+roll.count]
	[varNameY = "ySize"+roll.count]
	[ inputStr = listAppend(inputStr, varNameX+"|"+eval(varNameX)+"|Set size width (left to right)(in number of cells) of token: "+tok, "@") ]
	[ inputStr = listAppend(inputStr, varNameY+"|"+eval(varNameY)+"|Set size length (top to bottom)(in number of cells) of token: "+tok, "@") ]
}]

[h:'<!-- create the dialog string -->']
[h:inputStr 	= listFormat(inputStr, "input( %list )", " ' %item ' ", ",", "@")]

[h:'<!-- ask for input-->']
[h:abort(eval(inputStr))]

[H,FOREACH(tok, tokNameList), CODE:{
	[varNameX = "xSize"+roll.count]
	[varNameY = "ySize"+roll.count]
	[setProperty("w42.bot.xSize", eval(varNameX), tok)]
	[setProperty("w42.bot.ySize", eval(varNameY), tok)]

}]

[h: '<!-- rename selected tokens to "Canopy n" -->']
[h, if(tokenName == "No special token"): tokenName = ""]
[h, foreach(tok, tokList), CODE:{
	[token(tok), if(tokenName != ""): token.name = tokenName + " " + token.name]
}]
[h:bot_renumberToks(tokenName, tokList)]

[h: '<!-- calculate dialog settings for scatter function based on settings -->']
[h: area = areaWidth * areaLength]
[h: numToks = listCount(tokList)]

[h: numCopies	= floor(  area * (density / maxDensity) * (1 / numToks) * 1/4    )]
[h: spread		= maxDensity + 1 - density]
[h: distNorth	= floor(areaLength /2)]
[h: distSouth	= ceil(areaLength /2)]
[h: distEast	= floor(areaWidth /2)]
[h: distWest	= ceil(areaWidth /2)]
[h: ids			= json.fromList(tokList)]
[h: multiToken	= "ofEach"]
[h: rotation	= if(rotate, "Free", "None")]
[h: sizeRange	= -1]

[h: '<!-- run scatter with selected and calculated settings -->']
[h:args = json.set("{}", "numCopies", numCopies, "distNorth", distNorth, "distEast", distEast, "distSouth", distSouth, "distWest", distWest, "ids", ids, "spread", spread, "layer", layer, "rotation", rotation, "multiToken", multiToken, "sizeRange", sizeRange, "tokenName", tokenName)]
[r,macro("scatterImages@this"): args]

@@chooseCrowd
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy=13 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Scatter ; tooltip=<html>This will show a form where you can select or deselect crowd tokens images<br>which are on the BASE map. The checked images will be (randomly) used for<br>the <i>Create Crowd</i> macro.</html> ; minWidth=90 ; 
[H: '<!-- ------------------------------ chooseCrowd ---------------------------------------------- -->']
<!-- 
	<html>This will show a form where you can select or deselect crowd tokens images<br>which are on the BASE map. The checked images will be (randomly) used for<br>the <i>Create Crowd</i> macro.</html> 
-->
[h, if(argCount() > 0): useCurrentMap = arg(0); useCurrentMap = 0]

[h:'<!-- no new scope -->']
[h: bot_getValidCrowd(useCurrentMap)]

[h:'<!-- build the entire input string -->']
[h:inputStr	= "junk|<html><b>Choose the images you wish to use<br></html>|-|LABEL|SPAN=TRUE"]
[H,FOREACH(tok, fancyCrowdList), CODE:{
	[ inputStr = listAppend(inputStr, 'junk|________________________________________|-|LABEL|SPAN=TRUE',"@")]
	[ inputStr = listAppend(inputStr, "tok"+roll.count+"|1|"+tok+"|CHECK","@")]
}]

[h:'<!-- create the dialog string, this is interesting cause I have little clue what exactly happens here -->']
[h:inputStr 	= listFormat(inputStr, "input( %list )", " ' %item ' ", ",", "@")]

[h:'<!-- ask for input-->']
[h:abort(eval(inputStr))]

[h:crowd.tokens = "[]"]
[H,FOREACH(id, crowdTokens), CODE:{
	[if(eval("tok"+roll.count)): crowd.tokens = json.append(crowd.tokens, id)]
}]

[h:setLibProperty("crowd.tokens", crowd.tokens,"lib:EventMacros")]

@@chooseTrunks
@PROPS@ fontColor=green ; autoExecute=true ; fontSize=1.00em ; sortBy=22 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Scatter ; tooltip=<html>This will show a form where you can select or deselect tree trunk images<br>which are on the BASE map. The checked images will be (randomly) used for the <i>Canopy</i> pads</html> ; minWidth=90 ; 
[H: '<!-- chooseTrunks -->']
<!-- "html>This will show a form where you can select or deselect tree trunk images<br>which are on the BASE map. The checked images will be (randomly) used for the <i>Canopy</i> pads</html> -->
[h, if(argCount() > 0): useCurrentMap = arg(0); useCurrentMap = 0]

[h:'<!-- no new scope -->']
[h: bot_getValidTrunks(useCurrentMap)]

[h:'<!-- build the entire input string -->']
[h:inputStr	= "junk|<html><b>Choose the trunks you wish to use<br></html>|-|LABEL|SPAN=TRUE"]
[H,FOREACH(treeTrunk, fancyTrunkList), CODE:{
	[ inputStr = listAppend(inputStr, 'junk|________________________________________|-|LABEL|SPAN=TRUE',"@")]
	[ inputStr = listAppend(inputStr, "image"+roll.count+"|1|"+treeTrunk+"|CHECK","@")]
}]

[h:'<!-- create the dialog string, this is interesting cause I have little clue what exactly happens here -->']
[h:inputStr 	= listFormat(inputStr, "input( %list )", " ' %item ' ", ",", "@")]

[h:'<!-- ask for input-->']
[h:abort(eval(inputStr))]

[h:treeTrunkImages = ""]
[H,FOREACH(id, treeTrunkImageList), CODE:{
	[if(eval("image"+roll.count)): treeTrunkImages = listAppend(treeTrunkImages, id)]
}]

[h:setLibProperty("treeTrunkImages", treeTrunkImages,"lib:EventMacros")]

@@createCrowd
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy=11 ; color=darkgray ; playerEditable=true ; applyToSelected=false ; group=Scatter ; tooltip=<html>Use this macro to create a square filled with tokens (a crowd),<br>that can later be dispersed by using the 'move crowd' macro</html> ; minWidth=90 ; 
[dialog("Create Crowd", "temp=1; closebutton=0; width=300; height=450"): {
    [macro("crowdDialog@this"): ""]
}]

@@crowdDialog
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy=12 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Scatter ; tooltip= ; minWidth=90 ; 
[h: '<!-- CrowdDialog -->']
[h: '<!-- this macro is based on Craigs Scatter Drop-in -->']

[h:selList		= getLibProperty("crowd.tokens", "lib:EventMacros")]
[h:boundaryToks	= getSelected("json")]
[h:boundaryChk	= if(json.length(boundaryToks) == 2, 1,0)]

[h,if(boundaryChk), CODE:{
	[boundaryTok0	= json.get(boundaryToks, 0)]
	[boundaryTok1	= json.get(boundaryToks, 1)]
	[x0				= getTokenX(0, boundaryTok0)]
	[y0				= getTokenY(0, boundaryTok0)]
	[x1				= getTokenX(0, boundaryTok1)]
	[y1				= getTokenY(0, boundaryTok1)]
};{
	[boundaryTok0	= ""]
	[boundaryTok1	= ""]
	[x0				= 0]
	[y0				= 0]
	[x1				= 0]
	[y1				= 0]
}]

[h:xmin			= min(x0,x1)]
[h:ymin			= min(y0,y1)]
[h:xmax			= max(x0,x1)]
[h:ymax			= max(y0,y1)]

[h:setLibProperty("crowd.xMin", xmin, "lib:EventMacros")]
[h:setLibProperty("crowd.yMin", ymin, "lib:EventMacros")]
[h:setLibProperty("crowd.xMax", xmax, "lib:EventMacros")]
[h:setLibProperty("crowd.yMax", ymax, "lib:EventMacros")]

<!-- upper left token -->
[h:tokUL		= if(xmin == x0, boundaryTok0, boundaryTok1) ]
<!-- assert if upper left is actually upper left and not lower left -->

[h:distNorth	= 0]
[h:distWest		= 0]

[h:distEast		= xmax - xmin]
[h:distSouth	= ymax - ymin]

<html>
	<head>
		Create Crowd
		<link rel='stylesheet' type='text/css' 
		<link rel='onChangeSelection' type='macro' 
					href='[r:macroLinkText("createCrowd@this")]'>
	</head>
	<body>
	<form name=in action=[r:macroLinkText("scatterImages@this")] method="json">
		<input type="hidden" name="distNorth"		value='[r:distNorth]'>	</input>
		<input type="hidden" name="distEast"		value='[r:distEast]'>	</input>
		<input type="hidden" name="distSouth"		value='[r:distSouth]'>	</input>
		<input type="hidden" name="distWest"		value='[r:distWest]'>	</input>
		<input type="hidden" name="ids"				value='[r:selList]'>	</input>
		<input type="hidden" name="boundaryToks"	value='[r:boundaryToks]'></input>
		<input type="hidden" name="multiToken"		value='randomlySelected'></input>
		<input type="hidden" name="map"				value='[r:getLibProperty("baseMapName","Lib:EventMacros")]'></input>
		<input type="hidden" name="centreTok"		value='[r:tokUL]'>		</input>
		<input type="hidden" name="sizeRange"		value='0'>				</input>
		<input type="hidden" name="macro"			value='createCrowd'>	</input>
		<table>
			<tr>
				<th width=70% align='right'>
					<label for="numCopies">How many people:</label>
				</th>
				<td width=30%>
					<input name="numCopies" value="100"></input>
				</td>
			</tr>
			<tr>
				<th align='right'>
					<label for="rotation">Facing of the crowd:</label>
				</th>
				<td width=70>
					<select name="rotation">
						<option value="Free" selected="selected">Free</option>
						<option value="SquareEdges">Square (Edges)</option>
						<option value="Square">Square</option>
						<option value="VHexEdges">Vertical Hex (Edges)</option>
						<option value="VHex">Vertical Hex</option>
						<option value="HHexEdges">Horizontal Hex (Edges)</option>
						<option value="HHex">Horizontal Hex</option>
						<option value="None">None</option>
					</select>
				</td>
			</tr>
			<tr>
				<th align='right'>
					<div title="This is my tooltip"><label for="layer">Layer to place crowd:</label></div>
				</th>
				<td>
					[h,if(json.isEmpty(boundaryToks)), code: {
						[lyr=""]
					} ; {
						[h: obj = json.get(boundaryToks, 0)]
						[lyr=getLayer(obj)]
					}]
					<select name="layer">
						<option value="Token"[r: if(lyr=="TOKEN", " selected='selected'", "")]>Token</option>
						<option value="Hidden"[r: if(lyr=="GM", " selected='selected'", "")]>Hidden</option>
						<option value="Object"[r: if(lyr=="OBJECT", " selected='selected'", "")]>Object</option>
						<option value="Background"[r: if(lyr=="BACKGROUND", " selected='selected'", "")]>Background</option>
					</select>
				</td>
			</tr>
			
			<tr>
				<th align='right'>
					<label for="spread">Spreading:</label>
				</th>
				<td width=70>
					<input name="spread" value = 0></input>
				</td>
			</tr>

			<tr>
				<th align='right'>
					<label for="speed">Flee Speed (#cells):</label>
				</th>
				<td width=70>
					<input name="speed" value = 2d6></input>
				</td>
			</tr>

			<tr>
				<th align='right'>
					<label for="antagonist">Antagonists:</label>
				</th>
				<td width=70>
					<input name="antagonist" value = '<enter list of tokens>'></input>
				</td>
			</tr>
			
			[r,if(json.length(boundaryToks) == 2), CODE:{
				[r,if(getTokenY(0,tokUL) != ymax && xmin != xmax), CODE:{
					<tr><td align='right'>Upper Left:		</td><td>([r:xmin],[r:ymin])</td></tr>
					<tr><td align='right'>Lower Right:	</td><td>([r:xmax],[r:ymax])</td></tr>
					<tr><td align='right'>Covered Area:	</td><td>([r:distEast],[r:distSouth]) cells</td></tr>
				};{
					<tr><td colspan=2><b><font color='red' size=3>Make sure that one of the selected boundary tokens is in the UPPER LEFT and the other token is LOWER RIGHT (this is currently NOT the case)</td></tr>
				}]
			};{
				<tr><td colspan=2><b><font color='blue' size=3>Make sure you have exactly TWO tokens selected. These two tokens form the boundary of the crowd scene.</td></tr>
			}]
		</table>
		<table width=33% align=center>
			<tr>
				<td>
					[r,if(json.isEmpty(selList) != 1), code: {
						<input type=submit name=go value="Build Crowd"></input>
					};{
						<font color='red'>No crowd tokens found. Use 'Choose Crowd' macro in the setup panel.</font>
					}]
				</td>
			</tr>
		</table>
		<b>Short Manual</b><br>
		You can typically use this to emulate a square or bar where (e.g.) a 'fight goes down'. Especially if people start throwing grenades, the general public has the tendancy to move itself in the exact opposite direction.<br><br>
		Alternatively you can emulate a <i>Zombie Fest</i> where the the crowd is moving TOWARDS the event instead of away.<br>
		That is what this tool does.<br><br>
		The steps:<br>
		1. Put two tokens in the corners of the square you wish to populate (make sure that they are UPPER LEFT and LOWER RIGHT). Select (only!) the two tokens.<br>
		2. Enter the fields explained below<br>
		3. Hit the 'Move Crowd' or 'Move Crowd +' button on the campaign panel (or BoT panel) <br>
		The former simply moves the crowd to the border or the area. The latter does the same but more intelligently. E.g A token stops when running into another and has 50% chance to fall prone (hence the requirement of the prone state). It also is removed when it crosses the border. Prone tokens stand up the next round.<br>
		In terms of time: on an average computer it takes roughly 0.5 seconds to do 100 tokens with 'Move Crowd', while the '+' version takes about 13 seconds for the same 100 tokens. Both buttons can be used at all times, also alternately. They just calculate the current crowd differently. 
		<br><br>
		<b>Note</b> that for now only ONE crowd per CAMPAIGN is allowed (so NOT per map), if you create a second crowd either on the same or other map, the original crowd settings will be overwritten.<br><br>
		
		<b>Explanation of the fields</b>
		<table border=1 cellpadding=2>
		<tr><td valign='top'>How many:					</td><td>	is simply the amount of tokens that will populate the square. Keep the number below 1000 !!.			</td></tr>
		<tr><td valign='top'>Facing:					</td><td>	when the tokens are distributed there facing (rotation) can be set randomly. Determine the method.	</td></tr>
		<tr><td valign='top'>Layer to place the crowd:	</td><td>	I guess thats evident.																				</td></tr>
		<tr><td valign='top'>Spreading:					</td><td>	<b>-1</b> means, just drop the n tokens and leave them.<br>
																	<b>0</b> means that tokens that are on top of eachother are removed.<br>
																	<b>1 and higher</b> are the number of cells that will AT LEAST be between two tokens.<br><br>
																	This is achieved by REMOVING tokens that are too close. Which means that if you don't enter -1 its most likely that the total crowd will consist out of less then the number you entered in the 'How Many' box.
														</td></tr>
		<tr><td valign='top'>Flee Speed: 				</td><td>	When everything is setup, you can hit the 'Move Crowd' macro that will move each individual token a number of cells equal to the given number here. This CAN be code, like 2d6.<br><br>
																	<b>Note:</b><br>
																	if you want to emulate a <i>'Zombie Fest'</i>, that is have the crowd move TOWARDS the antagonists, simply enter a negative number, e.g. -3d4.
														</td></tr>
		<tr><td valign='top'>Antagonist: 				</td><td>	Here you enter one or more names of the token(s) from which 'The Crowd' is running from.<br><br>
																	<b>Notes:</b><br>
																	- you can move this/these tokens during the crowd movement, which WILL influence their path!!<br>
																	- If you enter multiple token names, seperate their names by comma ",". E.g. <i>Dragon, Dragon 1, Dragon 2, etc.</i>
														</td></tr>
		</table>
	</form>
	</body>
</html>

@@deferFinishScatter
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=0.95em ; sortBy=33 ; color=default ; playerEditable=true ; applyToSelected=false ; group=Scatter ; tooltip= ; minWidth=90 ; 
[h: '<!-- deferFinishScatter -->']

[h: tokenName		= arg(0)]
<!-- either createCrowd or scatterToken -->
[h: macro			= arg(1)]
[h: remainingCopies = arg(2)]

[h,if(macro == "scatterToken"), CODE:{
	[if(tokenName != 0): bot_renumberToks(tokenName)]
	[bot_initializePads()]
};{
	[setLibProperty("crowd", remainingCopies, "lib:EventMacros")]
}]

[h: broadcast("Spread Calculations are finished")]
[h: closeFrame("Progress Bar")]

@@deferRemoveToken
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=0.90em ; sortBy=32 ; color=default ; playerEditable=true ; applyToSelected=false ; group=Scatter ; tooltip= ; minWidth=90 ; 
[h: '<!-- ---------------------------------------------- deferRemoveToken ---------------------------------------------------- -->']

[h:assert(getLibProperty("abortProcess", "lib:EventMacros")!=0, "Process Aborted", 0))]

[h: '<!-- the defer is needed cause in a foreach loop it will loop from 1 to n even if certain numbers have already been removed due to  the check. So foreach will not work, a defer where the first of the chklist is checked and then removed from that list INCLUDING every token that is removed in the check, does work.  -->']

[h:copies			= arg(0)]
[h:layer			= arg(1)]
[h:spread			= arg(2)]
[h:tokenName		= arg(3)]
[h:totalCopies		= arg(4)]
[h:macro			= arg(5)]
[h:remainingCopies	= arg(6)]

[h:currentIteration = json.length(copies)]
[h:broadcast("Tokens left to check: " + currentIteration)]

[h:prog.percentage = floor(100*currentIteration/totalCopies)]

[h:output	= "
	<table width=305px bgcolor='red'><tr><td>
		<table width=" + 3*prog.percentage + "px bgcolor = 'green' color='white'><tr><td>" + prog.percentage + "%&nbsp; " + if(band(currentIteration,1), '0', 'o') + "</td></tr></table>
	</td></tr></table>
	
	&nbsp; 
	<table width=100px bgcolor='black' cellpadding='1'>
		<table width=100% bgcolor='red'><td align='center')>
			<td>
				<span  style='text-decoration:none; color:yellow'>
					" + macroLink('Abort process', 'abortProcess@lib:OnTokenMove', '', 0) + "
				</span>
			</td>
		</table>
	</table>
"]

[if(bot_isFullScreen()), CODE:{
	[dialog("Progress Bar", "width=410; height=10; temporary=0; input=1"): {[r:output]}]
};{
	[frame("Progress Bar", "width=410; height=10; temporary=0"): {[r:output]}]
}]

[h:'<!----------------------------- ACTUAL LOOP -->']

[h:'<!-- pick a random token from the list so if you scatter three different tokens the first wont dominate the field -->']
[tok				= json.get(copies,roll(1,json.length(copies))-1)]
[if(findToken(tok) != ""), CODE:{
	[setTokenDrawOrder(1d1000, tok)]
	[conditions			= "{'layer':'"+layer+"', 'range':{'token':'"+tok+"', 'distancePerCell':0, 'upto':"+spread+"}}"]
	[toRemove			= bot_ids2NamesArray(getTokens("json", conditions))]
	[FOREACH(remTok, toRemove), if(json.contains(remainingCopies, remTok)): removeToken(remTok)]
	[remainingCopies	= json.difference(remainingCopies,toRemove)]
	[copies				= json.difference(copies, toRemove)]
};{}]
[copies				= json.difference(copies, json.append("[]",tok))]

['remainingCopies = json.sort(remainingCopies)']
['copies = json.sort(copies)']
['toRemove = json.sort(toRemove)']
['pause("remainingCopies","toRemove", "copies", "tok")']
[h:'<!----------------------------- /ACTUAL LOOP -->']

[if(!json.isEmpty(copies)):
	execLink(macroLinkText("deferRemoveToken@lib:onTokenMove","none",json.append("",copies,layer,spread,tokenName,totalCopies, macro, remainingCopies)),1)
; 
	execLink(macroLinkText("deferFinishScatter@lib:onTokenMove","none",json.append("",tokenName,macro,remainingCopies)),1)
]

@@fieldEditDialog
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy=44 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Scatter ; tooltip= ; minWidth=90 ; 
[h: '<!-- -------------------------------- fieldEditDialog ------------------------------------- -->']

[h, if(bot_timeOut(4)), CODE:{
	[bot_resetTimer(4)]

	[h:selected		= getSelectedNames("json")]
	[assert(json.length(selected)==1, "",0)]
	[h:selTok		= json.get(selected, 0)]

	[h:imgTok		= macro.args]
	[h:x			= 0]
	[h:y			= 0]

	[h,if(startsWith(selTok, "GridCoordMarker")), CODE:{
		[coordToken = selTok]
		[existImg	= if(findToken(imgTok) != "", 1, 0)]
	};{
		[coordToken = ""]
		[imgTok		= selTok]
		[existImg	= 1]
	}]

	[h:xmin	= getLibProperty("mapField.xMin", "lib:EventMacros")]
	[h:ymin	= getLibProperty("mapField.yMin", "lib:EventMacros")]
	[h:xmax	= getLibProperty("mapField.xMax", "lib:EventMacros")]
	[h:ymax	= getLibProperty("mapField.yMax", "lib:EventMacros")]
	[h:BASE	= getLibProperty("baseMapName", "lib:EventMacros")]

	[if(coordToken != "" && findToken(imgTok) != ""), CODE:{
		[x	= getTokenX(0, coordToken)]
		[y	= getTokenY(0, coordToken)]
		['pause("x","y","coordToken","imgTok")']
		[tmpState	= getState("editFieldMarker",imgTok)]
		[setState("editFieldMarker", 1, imgTok)]
			[newImgTok	=	getName(copyToken(imgTok, 1, getCurrentMapName(), json.set("{}", "x", x, "y", y)))]
		[setState("editFieldMarker",tmpState, imgTok)]
		[imgTok			= newImgTok]
	};{}]

	[if(existImg), CODE:{
		[switchToken(imgTok)]
		[imgTok		= token.name]
		[htmlImg	= "<img src='"+getTokenImage(100)+"'></img>"]
	};{
		[htmlMsg	= "Select ANY (not map field) token and the click on the field to auto-copy-paste it there"]
		[imgTok		= ""]
	}]

	[h:macroLink	= macroLinkText("fieldEditDialog@this", "none", imgTok)]

	[frame("Map Editor", "temp=1; closebutton=0; width=200; height=200"): {
		<html>
			<head>
				Map Editor
				<link rel='stylesheet' type='text/css' 
				<link rel='onChangeSelection' type='macro' href='[r:macroLink]')>
			</head>
			<body>
				<table>
					<tr><td>Current edit token</td></tr>
					<tr><td>[r,if(existImg):htmlImg ; htmlMsg]
					</td></tr>
				</table>
			</body>
		</html>
	}]
};{}]

@@getValidCrowd
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy=14 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Scatter ; tooltip= ; minWidth=90 ; 
[H: '<!-- getValidCrowd(useCurrentMap) -->']

[H: '<!-- based on Orpheus WoD campaign macro -->']
[h,if(argCount() > 0): useCurrentMap = arg(0); useCurrentMap = 0]

[h:oldMap			= getCurrentMapName()]
[h:baseMapName		= getLibProperty("baseMapName", "lib:EventMacros")]

[h, if(oldMap != baseMapName):setCurrentMap(baseMapName)]
[h, if(useCurrentMap):setCurrentMap(oldMap)]

[h:conditions		= '{"layer":"TOKEN"}']
[h:tokenList		= getTokenNames(",",conditions)]
[h:tokenList 		= listSort(tokenList, "N")]

[h:fancyCrowdList	= ""]
[h:crowdTokens		= ""]

[h:foundOne			= 0]
[H,FOREACH(tok, tokenList), CODE:{
	[h, if(startsWith(tok, "Crowd")), CODE:{
		[token(tok): assetID	= getTokenImage()]
		[crowdTokens			= listAppend(crowdTokens, tok)]
		[fancyCrowdList			= listAppend(fancyCrowdList, '<html><span style="color:black; vertical-align:middle"  >'+tok+'</span><img src="'+assetID+'" height="100" width="100"></img></html>')]
		[foundOne				= 1]
	};{}]
}]

[h:assert(foundOne,"There are no tokens found which names start with 'Crowd' on THE TOKEN LAYER of map:"+baseMapName+". Make sure you have these images on the object layer of that map before running this macro",0)]
[h, if(!useCurrentMap):setCurrentMap(oldMap)]

@@getValidTrunks
@PROPS@ fontColor=green ; autoExecute=true ; fontSize=1.00em ; sortBy=23 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Scatter ; tooltip= ; minWidth=90 ; 
[H: '<!-- getValidTrunks(useCurrentMap) -->']
[H: '<!-- based on Orpheus WoD campaign macro -->']
[h,if(argCount() > 0): useCurrentMap = arg(0); useCurrentMap = 0]

[h: oldMap = getCurrentMapName()]
[h:baseMapName = getLibProperty("baseMapName", "lib:EventMacros")]

[h, if(oldMap != baseMapName):setCurrentMap(baseMapName)]
[h, if(useCurrentMap):setCurrentMap(oldMap)]

[h:conditions	= '{"layer":"OBJECT"}']
[h:tokenList	= getTokenNames(",",conditions)]
[h:tokenList 	= listSort(tokenList, "N")]

[h:fancyTrunkList	= ""]
[h:treeTrunkImageList	= ""]

[h:foundOne		= 0]
[H,FOREACH(tok, tokenList), CODE:{
	[h, if(startsWith(tok, "Trunk")), CODE:{
		[token(tok): assetID = getTokenImage()]
		[treeTrunkImageList = listAppend(treeTrunkImageList, assetID)]
		[fancyTrunkList = listAppend(fancyTrunkList, '<html><span style="color:black; vertical-align:middle"  >'+tok+'</span><img src="'+assetID+'" height="100" width="100"></img></html>')]
		[foundOne		= 1]
	}; {}]
}]
[h:assert(foundOne,"There are no tokens found which names start with 'Trunk' on THE OBJECT LAYER of map:"+baseMapName+". Make sure you have these images on the object layer of that map before running this macro",0)]
[h, if(!useCurrentMap):setCurrentMap(oldMap)]

@@mapEditor
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy=41 ; color=darkgray ; playerEditable=true ; applyToSelected=false ; group=Scatter ; tooltip=<html>Use this macro to create a square filled with tokens (a crowd),<br>that can later be dispersed by using the 'move crowd' macro</html> ; minWidth=90 ; 
[dialog("Map Editor", "temp=1; closebutton=0; width=330; height=600"): {
    [macro("mapEditorDialog@this"): ""]
}]

@@mapEditorDialog
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy=42 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Scatter ; tooltip= ; minWidth=90 ; 
[h: '<!-- mapEditorDialog -->']

[h:boundaryToks	= getSelected("json")]
[h:boundaryChk	= if(json.length(boundaryToks) == 2, 1,0)]

[h,if(boundaryChk), CODE:{
	[boundaryTok0	= json.get(boundaryToks, 0)]
	[boundaryTok1	= json.get(boundaryToks, 1)]
	[x0				= getTokenX(0, boundaryTok0)]
	[y0				= getTokenY(0, boundaryTok0)]
	[x1				= getTokenX(0, boundaryTok1)]
	[y1				= getTokenY(0, boundaryTok1)]
};{
	[boundaryTok0	= ""]
	[boundaryTok1	= ""]
	[x0				= 0]
	[y0				= 0]
	[x1				= 0]
	[y1				= 0]
}]

[h:xmin			= min(x0,x1)]
[h:ymin			= min(y0,y1)]
[h:xmax			= max(x0,x1)]
[h:ymax			= max(y0,y1)]

[h:setLibProperty("mapField.xMin", xmin, "lib:EventMacros")]
[h:setLibProperty("mapField.yMin", ymin, "lib:EventMacros")]
[h:setLibProperty("mapField.xMax", xmax, "lib:EventMacros")]
[h:setLibProperty("mapField.yMax", ymax, "lib:EventMacros")]

<!-- upper left token -->
[h:tokUL		= if(xmin == x0, boundaryTok0, boundaryTok1) ]
<!-- assert if upper left is actually upper left and not lower left -->

<html>
	<head>
		Build Map Editor Field
		<link rel='stylesheet' type='text/css' 
		<link rel='onChangeSelection' type='macro' href='[r:macroLinkText("mapEditor@this")]'>
	</head>
	
	<body>
	<form name=in action=[r:macroLinkText("buildField@this")] method="json">
	<input type="hidden" name="bound1"		value='[r:boundaryTok0]'>	</input>
	<input type="hidden" name="bound2"		value='[r:boundaryTok1]'>	</input>

		<table>
		
			<th align='right'>
				<div title="This is my tooltip"><label for="layer">Layer where you wish to edit:</label></div>
			</th>
			<td>
				[h,if(json.isEmpty(boundaryToks)), code: {
					[lyr=""]
				} ; {
					[h: obj = json.get(boundaryToks, 0)]
					[lyr=getLayer(obj)]
				}]
				<select name="layer">
					<option value="Token"[r: if(lyr=="TOKEN", " selected='selected'", "")]>Token</option>
					<option value="Hidden"[r: if(lyr=="GM", " selected='selected'", "")]>Hidden</option>
					<option value="Object"[r: if(lyr=="OBJECT", " selected='selected'", "")]>Object</option>
					<option value="Background"[r: if(lyr=="BACKGROUND", " selected='selected'", "")]>Background</option>
				</select>
			</td>

		
			[r,if(json.length(boundaryToks) == 2), CODE:{
				[r,if(getTokenY(0,tokUL) != ymax && xmin != xmax), CODE:{
					<tr><td align='right'>Upper Left:		</td><td>([r:xmin],[r:ymin])</td></tr>
					<tr><td align='right'>Lower Right:	</td><td>([r:xmax],[r:ymax])</td></tr>
					<tr><td align='right'><input type=submit name=go value="Create Edit Field"></input></td><td></td></tr>
				};{
					<tr><td colspan=2><b><font color='red' size=3>Make sure that one of the selected boundary tokens is in the UPPER LEFT and the other token is LOWER RIGHT (this is currently NOT the case)</td></tr>
				}]
			};{
				<tr>	<td colspan=2><b><font color='blue' size=3>Make sure you have exactly TWO tokens selected. These two tokens form the boundary of the part of the map that you can edit.</td></tr>
			}]
		</table>
		<b>Short Manual</b><br>
		This editor works really simple. Just select two tokens (any will do) that outline the field you wish to edit. Make sure that one is the upper left and the other the lower right.<br>
		Once you have done that you can hit the 'Create Edit Field' button. If you have no tokens selected, you will not see that button. Additionally you can choose on which layer you wish to edit. Personally I find the object layer the best spot.<br><br>
		After you hit that button, the outline tokens will be removed and a 'field' of transparent tokens will be put on the chosen layer. Note that the field will cover the spots of the outline tokens.<br><br>
		To start editing select just ANY token (except one of the transparent tokens, although nothing will break when you do). That token will be your 'copy-paste' token. <br><br>
		Now just start selecting the transparent tokens and the previously selected token will be pasted there. Note that you can rotate, resize, add states, halos etc. and those will be copy pasted as well.<br><br>
		Thats it. Post on the Bag of Tricks thread on the forum if you have any questions.	</form>
	</body>
</html>

@@moveCrowd
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy=15 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Scatter ; tooltip=<html>Disperses a crowd created by the 'Create Crowd' macro.<br>Make sure the antagonist is on the map. ; minWidth=90 ; 
[h: '<!-- -------------------------------------- moveCrowd ------------------------------------------------------- -->']
[h:crowd		= getLibProperty("crowd","lib:EventMacros")]
[h:speed		= getLibProperty("crowd.speed","lib:EventMacros")]
[h:antagonists	= getLibProperty("crowd.antagonist","lib:EventMacros")]

[h:assert(findToken(json.get(crowd,0)) != "",	"Crowd NOT found on map. Create one first using the 'Create Crowd' macro in the Setup Macro Panel",0)]

[h:xMin			= getLibProperty("crowd.xMin","lib:EventMacros")]
[h:yMin			= getLibProperty("crowd.yMin","lib:EventMacros")]
[h:xMax			= getLibProperty("crowd.xMax","lib:EventMacros")]
[h:yMax			= getLibProperty("crowd.yMax","lib:EventMacros")]

<!-- calculate the middle position of all antagonists -->
[h:aX			= 0]
[h:aY			= 0]
[h, foreach(antagonist, antagonists), CODE:{
	[assert(findToken(antagonist) != "",			"Antagonist ("+antagonist+") NOT found. Make sure its on the map",0)]
	[aX	= aX + getTokenX(0, antagonist)]
	[aY	= aY + getTokenY(0, antagonist)]
}]
[h:aX			= round( aX/listCount(antagonists), 0 )]
[h:aY			= round( aY/listCount(antagonists), 0 )]

<!--
	Cxnew = Cx + e/|R| * (Cx-Ax)
	e = run speed of crowd
	|R| = sqrt( (Cx-Ax)^2 + (Cy-Ay)^2  ) (length of the vector CA)
	C = Crowd
	A = Antagonist
-->

[h:'bot_startTime()']
[h,foreach(poorSoul, crowd), CODE:{
	[moveToken(
		min(xMax,max(xMin,round(getTokenX(0, poorSoul) + eval(string(speed))/sqrt((getTokenX(0, poorSoul) - aX)^2+(getTokenY(0, poorSoul) - aY)^2) * (getTokenX(0, poorSoul) - aX),0))),
		min(yMax,max(yMin,round(getTokenY(0, poorSoul) + eval(string(speed))/sqrt((getTokenX(0, poorSoul) - aX)^2+(getTokenY(0, poorSoul) - aY)^2) * (getTokenY(0, poorSoul) - aY),0))),
		0,
		poorSoul
	)]
}]
[h:'broadcast(json.length(crowd))']
[h:'broadcast(bot_totalTime(1))']

@@moveCrowdPlus
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy=15 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Scatter ; tooltip=<html>Disperses a crowd created by the 'Create Crowd' macro.<br> Make sure the antagonist is on the map.<br> <br> This macro uses more intelligence however and is more realistic<br> but MUCH slower (roughly 1 second per 10 tokens) ; minWidth=90 ; 
[h: '<!-- -------------------------------------- moveCrowdPlus ------------------------------------------------------- -->']
<!--
<html>Disperses a crowd created by the 'Create Crowd' macro.<br> Make sure the antagonist is on the map.<br> <br> This macro uses more intelligence however and is more realistic<br> but MUCH slower (roughly 1 second per 10 tokens)
-->
<!-- THREE CODE LEVELS -->
[h:crowd		= getLibProperty("crowd","lib:EventMacros")]
[h:speed		= getLibProperty("crowd.speed","lib:EventMacros")]
[h:antagonists	= getLibProperty("crowd.antagonist","lib:EventMacros")]

[h:assert(json.length(crowd,0),	"Crowd NOT found on map. Create one first using the 'Create Crowd' macro in the Setup Macro Panel",0)]
[h:assert(findToken(json.get(crowd,0)) != "",	"Crowd NOT found on map. Create one first using the 'Create Crowd' macro in the Setup Macro Panel",0)]

[h:xMin			= getLibProperty("crowd.xMin","lib:EventMacros")-2]
[h:yMin			= getLibProperty("crowd.yMin","lib:EventMacros")-2]
[h:xMax			= getLibProperty("crowd.xMax","lib:EventMacros")+2]
[h:yMax			= getLibProperty("crowd.yMax","lib:EventMacros")+2]

<!-- calculate the middle position of all antagonists -->
[h:aX			= 0]
[h:aY			= 0]
[h, foreach(antagonist, antagonists), CODE:{
	[assert(findToken(antagonist) != "",			"Antagonist ("+antagonist+") NOT found. Make sure its on the map",0)]
	[aX	= aX + getTokenX(0, antagonist)]
	[aY	= aY + getTokenY(0, antagonist)]
}]
[h:aX			= round( aX/listCount(antagonists), 0 )]
[h:aY			= round( aY/listCount(antagonists), 0 )]

[h:'bot_startTime()']
<!-- THREE CODE LEVELS -->
[h:newCrowd = crowd]
[h,foreach(poorSoul, crowd), CODE:{
	[if(getState("Prone", poorSoul) == 1), CODE:{
		[setState("Prone",0,poorSoul)]
	''
	};{
		<!-- get the first tokens that is in the way, if any, list will contain poorSoul as first -->
		[distance	= eval(string(speed))]
		[inTheWays	= bot_selectOnLine(
			poorSoul,
			min(xMax,max(xMin,round(getTokenX(0, poorSoul) + distance/sqrt((getTokenX(0, poorSoul) - aX)^2+(getTokenY(0, poorSoul) - aY)^2) * (getTokenX(0, poorSoul) - aX),0))),
			min(yMax,max(yMin,round(getTokenY(0, poorSoul) + distance/sqrt((getTokenX(0, poorSoul) - aX)^2+(getTokenY(0, poorSoul) - aY)^2) * (getTokenY(0, poorSoul) - aY),0))),
			1
		)]
		[if(listCount(inTheWays) > 1), CODE:{
			[inTheWay	= getName(listGet(inTheWays, 1))]
			<!-- if a token is in the way then stop the poorSoul one cell short -->
			[distance	= getDistance(inTheWay,0,poorSoul) - 1]
			[if(1d100 < 51): setState("Prone",1,poorSoul)]
		''
		};{
			[inTheWay = ""]
		''
		}]
		[poorSoulX	= round(getTokenX(0, poorSoul) + distance/sqrt((getTokenX(0, poorSoul) - aX)^2+(getTokenY(0, poorSoul) - aY)^2) * (getTokenX(0, poorSoul) - aX),0)]
		[poorSoulY	= round(getTokenY(0, poorSoul) + distance/sqrt((getTokenX(0, poorSoul) - aX)^2+(getTokenY(0, poorSoul) - aY)^2) * (getTokenY(0, poorSoul) - aY),0)]
		
		[if(poorSoulX >= xMax || poorSoulX <= xMin || poorSoulY >= yMax || poorSoulY <= yMin), CODE:{
			[removeToken(poorSoul)]
			[newCrowd	= json.remove(newCrowd, json.indexOf(newCrowd,poorSoul))]
		''
		};{
			[moveToken(poorSoulX, poorSoulY, 0,poorSoul)]
		''
		}]
	''
	}]
''
}]
[h:setLibProperty("crowd", newCrowd, "lib:EventMacros")]
[h:'broadcast(json.length(crowd))']
[h:'broadcast(bot_totalTime(1))']

@@moveToHidden
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy=46 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Scatter ; tooltip= ; minWidth=90 ; 
[h: '<!-- --------------------------------------- moveToHidden --------------------------------------------------- -->']
[moveToks	= getTokenNames("json", json.set("{}", "setStates", '["editFieldMarker"]' ))]
[foreach(tok, moveToks), CODE:{
	[shape	= getTokenShape(tok)]
	[setLayer("HIDDEN", tok)]
	[setTokenShape(shape, tok)]
}]

@@moveToToken
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy=46 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Scatter ; tooltip= ; minWidth=90 ; 
[h: '<!-- --------------------------------------- moveToToken --------------------------------------------------- -->']
[moveToks	= getTokenNames("json", json.set("{}", "setStates", '["editFieldMarker"]' ))]
[foreach(tok, moveToks), CODE:{
	[shape	= getTokenShape(tok)]
	[setLayer("TOKEN", tok)]
	[setTokenShape(shape, tok)]
}]

@@quitEditor
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy=44 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Scatter ; tooltip= ; minWidth=90 ; 
[h: '<!-- quitEditor -->']

[h:fieldToks	= getLibProperty("fieldToks","lib:EventMacros")]
[h,foreach(tok, fieldToks), if(findToken(tok) != ""):removeToken(tok)]
[h:closeFrame("Map Editor")]

[h: '<!-- --------------------------------------- remove States --------------------------------------------------- -->']
[moveToks	= getTokenNames("json", json.set("{}", "setStates", '["editFieldMarker"]' ))]
[foreach(tok, moveToks):setAllStates(0,tok)]

@@scatter
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=1 ; color=darkgray ; playerEditable=true ; applyToSelected=false ; group=Scatter ; tooltip= ; minWidth=90 ; 
[dialog("ScatterDialog", "temp=1; closebutton=0; width=300; height=450"): {
    [macro("ScatterDialog@this"): ""]
}]

@@scatterDialog
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=2 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Scatter ; tooltip= ; minWidth=90 ; 
[h: '<!-- scatterDialog -->']
[h: '<!-- this macro is based on Craigs Scatter Drop-in -->']

[h: selList = getSelected("json")]
<html>
	<head>
		Copy and Scatter
		<link rel='stylesheet' type='text/css' 
		<link rel='onChangeSelection' type='macro' 
					href='[r:macroLinkText("scatter@this")]'>
	</head>
	<body>
		<table width=33% align=center border=1>
			<tr>
					[r,if(json.isEmpty(selList)), code: {
						<br>Select A Token or Object<br><br><br>
					} ; {
						[h: rows = sqrt(json.length(selList))]
						[h: perRow = ceil(json.length(selList)/rows)]
						[h: count = 0]
						[r,foreach(obj, selList,""), code: {
							[h: count = count +1]
							[r,if(count > perRow): "</tr><tr>"]
							[h,if(count > perRow): count=1]
							<td><img width=[r:round(100/perRow)] height=[r:round(100/perRow)] 
								 src='[r,token(obj): getTokenImage()]'></img></td>
						}]
					}]
			</tr>
		</table>
			<form name=in action=[r:macroLinkText("scatterImages@this")]
						method="json">
				<table>
					<tr>
						<th>
							<label for="numCopies">Number of Copies</label>
						</th>
						<td width=70>
							<input name="numCopies" value="100"></input>
						</td>
					</tr>
					<tr>
						<th>
							<label for="distNorth">Distance North</label>
						</th>
						<td width=70>
							<input name="distNorth" value="100"></input>
						</td>
					</tr>
					<tr>
						<th>
							<label for="distEast">Distance East</label>
						</th>
						<td width=70>
							<input name="distEast" value="100"></input>
						</td>
					</tr>
					<tr>
						<th>
							<label for="distSouth">Distance South</label>
						</th>
						<td width=70>
							<input name="distSouth" value="100"></input>
						</td>
					</tr>
					<tr>
						<th>
							<label for="distWest">Distance West</label>
						</th>
						<td width=70>
							<input name="distWest" value="100"></input>
						</td>
					</tr>
					<tr>
						<th>
							<label for="spread">Spreading</label>
						</th>
						<td width=70>
							<input name="spread" value="5"></input>
						</td>
					</tr>
					<tr>
						<th>
							<label for="rotation">Rotation</label>
						</th>
						<td width=70>
							<select name="rotation">
								<option value="Free" selected="selected">Free</option>
								<option value="SquareEdges">Square (Edges)</option>
								<option value="Square">Square</option>
								<option value="VHexEdges">Vertical Hex (Edges)</option>
								<option value="VHex">Vertical Hex</option>
								<option value="HHexEdges">Horizontal Hex (Edges)</option>
								<option value="HHex">Horizontal Hex</option>
								<option value="None">None</option>
							</select>
						</td>
					</tr>
					<tr>
						<th>
							<label for="sizeRange">Range of Size</label>
						</th>
						<td width=70>
							<select name="sizeRange">
								<option value="-1">Keep size of original</option>
								<option value="0" selected="selected">0</option>
								<option value="1">1</option>
								<option value="2">2</option>
								<option value="3">3</option>
								<option value="4">4</option>
								<option value="5">5</option>
							</select>
						</td>
					</tr>
					<tr>
						<th>
							<label for="layer">Layer</label>
						</th>
						<td>
				[h,if(json.isEmpty(selList)), code: {
								[lyr=""]
							} ; {
								[h: obj = json.get(selList, 0)]
								[lyr=getLayer(obj)]
				}]
							<select name="layer">
								<option value="Token"[r: if(lyr=="TOKEN", " selected='selected'", "")]>Token</option>
								<option value="Hidden"[r: if(lyr=="GM", " selected='selected'", "")]>Hidden</option>
								<option value="Object"[r: if(lyr=="OBJECT", " selected='selected'", "")]>Object</option>
								<option value="Background"[r: if(lyr=="BACKGROUND", " selected='selected'", "")]>Background</option>
							</select>
						</td>
					</tr>
					<tr>
						<th>
							<label for="tokenName">Special Token</label>
						</th>
						<td width=70>
							<select name="tokenName">
								<option value="0">No</option>
								<option value="Canopy" selected="selected">Canopy</option>
								<option value="Foliage">Foliage</option>
								<option value="Roof">Roof</option>
								<option value="Ward">Ward</option>

								<option value="EventPad">EventPad</option>
								<option value="MappedPad">MappedPad</option>

								<option value="PadStart">PadStart</option>
								<option value="PadEnd">PadEnd</option>
								<option value="InterPad">InterPad</option>

								<option value="PadStartBorder">PadStartBorder</option>
								<option value="PadEndBorder">PadEndBorder</option>
								<option value="InterPadBorder">InterPadBorder</option>

								<option value="PadJumpBorder">PadJumpBorder</option>
								<option value="PadDropBorder">PadDropBorder</option>
								<option value="InterJumpBorder">InterJumpBorder</option>
								<option value="InterDropBorder">InterDropBorder</option>

								<option value="PadJump">PadJump</option>
								<option value="PadDrop">PadDrop</option>
								<option value="InterJump">InterJump</option>
								<option value="InterDrop">InterDrop</option>
							</select>
						</td>
					</tr>

					[r,if(json.length(selList) > 1), code:{
						<tr>
							<th>
								<label for="mutiToken">Number Copies </label>
							</th>
							<td width=70>
								<select name="multiToken">
									<option value="ofEach" selected="selected">of each</option>
									<option value="randomlySelected">randomly selected</option>
							</td>
						</tr>
					} ; { 
					}]
				</table>
				<table width=33% align=center>
					<tr>
						<td>
							[r,if(json.isEmpty(selList) != 1), code: {
								<input type=submit name=go value="Scatter"></input>
							} ; {
							}]
						</td>
					</tr>
				</table>
				<input type="hidden" name="ids"			value='[r:selList]'></input>
				<input type="hidden" name="map"			value='[r:getCurrentMapName()]'></input>
				<input type="hidden" name="centreTok"	value=''></input>
				<input type="hidden" name="macro"		value='scatterToken'></input>
		 </form>
	</body>
</html>

@@scatterImages
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=31 ; color=default ; playerEditable=true ; applyToSelected=false ; group=Scatter ; tooltip= ; minWidth=90 ; 
[h: '<!-- --------------------------------------- scatterImages --------------------------------------------------- -->']
[h: '<!-- this macro is based on Craigs Scatter Drop-in -->']
[h:closeDialog("Create Crowd")]
[h: numCopies	= json.get(macro.args, "numCopies")]
[h: distNorth	= json.get(macro.args, "distNorth")]
[h: distEast	= json.get(macro.args, "distEast")]
[h: distSouth	= json.get(macro.args, "distSouth")]
[h: distWest	= json.get(macro.args, "distWest")]
[h: ids			= json.get(macro.args, "ids")]
[h: spread		= json.get(macro.args, "spread")]
[h: speed		= json.get(macro.args, "speed")]
[h: antagonist	= json.get(macro.args, "antagonist")]
[h: sizeRange	= json.get(macro.args, "sizeRange")]

[h:setLibProperty("crowd.speed", speed, "lib:EventMacros")]
[h:setLibProperty("crowd.antagonist", antagonist, "lib:EventMacros")]

[h: tokenName	= json.get(macro.args, "tokenName")]
[h: map			= json.get(macro.args, "map")]
[h: centreTok	= json.get(macro.args, "centreTok")]
<!-- either createCrowd or scatterToken -->
[h: macro		= json.get(macro.args, "macro")]

[h:assert(isNumber(numCopies),"Number Copies must be numeric",0)]
[h:assert(isNumber(distNorth),"Distance North must be numeric",0)]
[h:assert(isNumber(distEast),"Distance East must be numeric",0)]
[h:assert(isNumber(distSouth),"Distance South must be numeric",0)]
[h:assert(isNumber(distWest),"Distance West must be numeric",0)]

[h: layer		= json.get(macro.args, "layer")]
[h: rotation	= json.get(macro.args, "rotation")]

[h,switch(rotation):
	case "Free": 		rotStr	= "1d360-1"; 
	case "SquareEdges":	rotStr	= "(1d4-1) * 90"; 
	case "Square":		rotStr	= "(1d8-1) * 45"; 
	case "VHexEdges":	rotStr	= "(1d6-1) * 60 + 30"; 
	case "VHexEdges":	rotStr	= "(1d12-1) * 30"; 
	case "HHexEdges":	rotStr	= "(1d6-1) * 60"; 
	case "HHexEdges":	rotStr	= "(1d12-1) * 30"; 
	case "None":		rotStr	= ""; 
] 

<!-- either ofEach or randomlySelected -->
[h: method	= json.get(macro.args, "multiToken")]
<!-- if you use the crowd macro use randomlySelected -->
[h,if(method == ""): method	= "randomlySelected")]

[h:'<!-- Create an array of "number of copies" to use based on method -->']
[h:numCopyArr	= "[]"]
[h: numIds		= json.length(ids)]
[h,if(method == "ofEach"), code: {
	[for(i, 0, numIds): numCopyArr	= json.append(numCopyArr, numCopies)]
} ; { 
	<!-- create an array with the amounts of each id to scatter -->
	[for(i, 0, numIds): numCopyArr	= json.append(numCopyArr, floor(numCopies/numIds))]
	<!-- because you round the amount the total amount might be less then was required. So get total of copies in array (sum of array) -->
	[sum	= evalMacro(replace(replace(numCopyArr, "\\[", "[r:"), ",", "+"))]
	[toAdd	= max(0,numCopies - sum)]
	<!-- the amount still to add should ALWAYS be LESS then the total amount of scatter ids, hence just add one of each id until finished (but just add a limiter (min) just in case) -->
	[count(toAdd): numCopyArr	= json.set(  numCopyArr, min(numIds,roll.count), json.get(numCopyArr, min(numIds,roll.count)) + 1  )]
}]

[h: sizeList	= "Fine, Diminutive, Tiny, Small, Medium, Large, Huge, Giant, Gargantuan, Colossal"]
[h, if(sizeRange == 5): sizeStr	= "[r:listGet(sizeList, 1d10-1)]"); sizeStr	= "[r:listGet(sizeList, 1d" + (2*sizeRange+1) + "+" + (3-sizeRange) + ")]" ]
[h, if(sizeRange == "-1"): sizeStr	= "" ]
[h: spreadChkList	= "[]"]
[h,for(i, 0, numIds), code: {
	[obj		= json.get(ids, i)]
	[copies		= json.get(numCopyArr, i)]
	<!-- crowd makes use of a centreTok, scatter uses the to copy tok as centre -->
	[centreX	= getTokenX(0, if(centreTok == "", obj, centreTok))]
	[centreY	= getTokenY(0, if(centreTok == "", obj, centreTok))]

	[xstr		= "centreX" + (-1 * (distWest + 1)) + "+ 1d" + (distWest + distEast + 1)]
	[ystr		= "centreY" + (-1 * (distNorth + 1)) + "+ 1d" + (distNorth + distSouth + 1)]

	[updates	= json.set("{}", "layer", layer)]
	[updates	= json.set(updates, "useDistance", 0)]
	[if(rotStr != ""): updates	= json.set(updates, "facing", "[r:" + rotStr + "]")]
	[updates	= json.set(updates, "x", "[r:" + xstr + "]")]
	[updates	= json.set(updates, "y", "[r:" + ystr + "]")]
	[if(sizeStr != ""): updates	= json.set(updates, "size", sizeStr)]
	[copies		= copyToken(obj, copies, map, updates)]
	[spreadChkList	= json.merge(spreadChkList, copies)]

	['tmp	= bot_ids2Names(spreadChkList)']
	['tmp1	= bot_ids2Names(copies)']
	['pause("tmp","tmp1")']
}]

[spreadChkList		= bot_ids2NamesArray(spreadChkList)]

[h,if(spread > -1), CODE: {
	[txt	= "All the tokens have now been scattered in the designated area. Now the field will be checked for the 'spreading'. Any token closer than "+spread+" will be removed. Press cancel if you do not want this.<br><br><b>Note</b> that this will mean that the resulting amount of tokens will be less then the 'Number of Copies' you have set.<br><br>(also note that this pause is vital, so don't remove it from the code)"]
	[pause("txt")]
	[bot_abortProcess(1)]
	[link	= macroLinkText("deferRemoveToken@lib:onTokenMove","none",json.append("",spreadChkList,layer,spread,tokenName,json.length(spreadChkList),macro,spreadChkList))]
	[execLink(link,1)]
}; {
	['broadcast(spreadChkList)']
	[if(macro == "createCrowd"):setLibProperty("crowd", spreadChkList, "lib:EventMacros")]
}]

@@buildInputString
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=default ; playerEditable=true ; applyToSelected=false ; group=bubblobill Input String Builder ; tooltip= ; minWidth=90 ; 
[h:'<!-- ---------------------------------------- buildInputString --------------------------------------------- -->']

<!-- This macro helps to build input strings by putting the right bits in the right places. -->
<!-- bubblobill original created 30.06.2014 -->
<!-- last updated 05.07.2014 -->

<!-- set up initial default variables -->
[h,code:{
[inData=macro.args][inType=''][inputDisplay=''][newString=''][prevStrings=json.fromList("")][runFrom=getMacroLocation()]
[TEXT="Text"]
	[txtvarName="myTextVar"][txtprompt="TextLabel"][txtspan=""][txtspanchk=""][txtvalue="DefaultText"][txtwidth="16"]
[LIST="Listbox"]
	[lstvarName="myListVar"][lstlabel="ListboxName"][lstspan=""][lstspanchk=""][lstvalue="String, List, Example"][lstindex="0"][lststring=""]
[CHECK="Checkbox"]
	[chkvarName="myCheckVar"][chkprompt="CheckboxName"][chkspan=""][chkspanchk=""][chkvalue="0"]
[RADIO="Radio button"]
	[radvarName="myRadioVar"][radprompt="RadioGroupName"][radspan=""][radspanchk=""][radvalues="String, List, Example"][radvalue="0"][radstring=""][radorient=""]
[LABEL="Label"]
	[lblprompt="LabelName"][lblvalue="<b>LabelContent</b>"][lblspan=""][lblspanchk=""]
[PROPS="Props"]
	[propvarName="myPropVar"][propprompt="PropListGroupName"][propspan=""][propspanchk=""][propvalue=encode("String=Prop; List=example")][propvar=""][propvar_=""]
[TAB="Tab"]
	[tabvarName="myTabVar"][tabvalue="TabName"][tabstart=""]
[SHOW="Show"]
}]

<!-- test for first run, ie. have arguments been passed for processing -->
[h,if(!json.isEmpty(macro.args)==1),code:{

	<!-- First run=FALSE, process form -->

	<!-- set switch value to the input type button that was pressed -->
	[types="TEXT,LIST,CHECK,RADIO,LABEL,PROPS,TAB,SHOW"]
	[foreach(type,types):inType=add(inType,json.get(inData,type))]

	<!-- set variables from arguments -->
	[varList=json.fields(inData)]
	[foreach(var,varList),CODE:{
		[value = json.get(inData,var)]
		[set(var,value)]
		}]
	[propvalue=decode(propvalue)]
	[prevStrings=decode(prevStrings)]

	<!-- build input string from fields for appropriate type -->
	[switch(inType),code:
	case "Text":	{[newString=strformat("&#39;%{newString}%{txtvarName}|%{txtvalue}|<html>%{txtprompt}</html>|TEXT|WIDTH=%{txtwidth} %{txtspan}&#39;")]};
	case "Text":	{[newString=strformat("&#39;%{newString}%{txtvarName}|%{txtvalue}|<html>%{txtprompt}</html>|TEXT|WIDTH=%{txtwidth} %{txtspan}&#39;")] };
	case "Listbox":	{[newString=strformat("&#39;%{newString}%{lstvarName}|%{lstvalue}|<html>%{lstlabel}</html>|LIST|%{lstspan} %{lststring} SELECT=%{lstindex}&#39;")]};
	case "Checkbox":{[newString=strformat("&#39;%{newString}%{chkvarName}|%{chkvalue}|<html>%{chkprompt}</html>|CHECK|%{chkspan}&#39;")]};
	case "Radio button":	{[newString=strformat("&#39;%{newString}%{radvarName}|%{radvalues}|%{radprompt}|RADIO|SELECT=%{radvalue} %{radspan} %{radstring} %{radorient}&#39;")]};
	case "Label":	{[newString=strformat("&#39;%{newString}junkvar|<html>%{lblvalue}</html>|%{lblprompt}|LABEL|%{lblspan}&#39;")]};
	case "Props":	{[newString=strformat("&#39;%{newString}%{propvarName}|%{propvalue}|%{propprompt}|PROPS|%{propspan} %{propvar} %{propvar_}&#39;")]};
	case "Tab":		{[newString=strformat("&#39;%{newString}%{tabvarName}|%{tabvalue}||TAB|%{tabstart} &#39;")]};
	case "Show":	{[newString=" ")]}
	]
	
	
	<!-- append strings together into a display string and clean -->
	[if(prevStrings==""): inputDisplay=newString; inputDisplay = strformat ("&#39;%{prevStrings}&#39;%{newString}")]
	[inputDisplay=replace(inputDisplay,"&#"+59,";")]
	[inputDisplay=replace(inputDisplay,"<(.*?)>","&lt;\$1&gt;")]
	[inputDisplay=replace(inputDisplay,"&#39;&#39;"," ## ")]
	};{

	<!-- First run=TRUE -->
	[h, if (runFrom == "token"):setSpeech("input","");""]

}]

<!-- declare strings for putting together form -->
[h:formLink = macroLinkText("buildInputString@lib:OnTokenMove","","","")]

[h:CHECKED=string('CHECKED="CHECKED"')][h:SPAN=string('SPAN=TRUE')][h:STRINGVALUE=string('VALUE=STRING')]

<!-- set form checkboxes checked value from previous run -->
[h,code:{
[txtspanchk=if(txtspan==SPAN,CHECKED,"")]
[lstspanchk=if(lstspan==SPAN,CHECKED,"")]
[chkspanchk=if(chkspan==SPAN,CHECKED,"")]
[radspanchk=if(radspan==SPAN,CHECKED,"")]
[lblspanchk=if(lblspan==SPAN,CHECKED,"")]
[propspanchk=if(propspan==SPAN,CHECKED,"")]
[chkvaluechk=if(chkvalue==1,CHECKED,"")]
[lststringchk=if(lststring==STRINGVALUE,CHECKED,"")]
[radstringchk=if(radstring==STRINGVALUE,CHECKED,"")]
[radorientchk=if(radorient=="ORIENT=H",CHECKED,"")]
[propvarchk=if(propvar=="SETVARS=UNSUFFIXED", CHECKED,"")]
[propvar_chk=if(propvar_=="SETVARS=SUFFIXED",CHECKED,"")]
}]

[h:css='<style>
table.mytable 		{ color:black }
table.mytable th 	{ background-color: #660066; font-weight:bold; color:white }
table.mytable tr	{ background-color: #C0C0C0 }
table.mytable .alt 	{ background-color: #FFFFFF }
table.table2 tr td 	{ background-color: #FFFFEE; color: black }
table.table2 .note 	{ background-color: #FFFFFF; color: blue }
</style>']

<!-- create form HTML string for display -->
[h:displayString='<html>
<head>
<title>Build input string</title>
'+css+'
</head>
<form action="'+formLink+'" method=json >

<table width=100% class="mytable">
	<tr>
		<th></th>
		<th>Variable name							</th>
		<th>Label / Prompt / Tooltip				</th>
		<th>Hide<br>label							</th>
		<th colspan=2>Prefill / value				</th>
		<th colspan=2 align=right width=80>Options	</th>
		<th colspan=5>								</th>
		</tr>
	<tr>
		<td align=right bgcolor=#A0A0A0><input type="submit" name="TAB" value="Tab">											</td>
		<td align=right>				<input type="text" name="tabvarName" size="18" maxlength="" value="'+tabvarname+'">		</td>
		<td align=right>				<input type="text" name="tabvalue" size="18" maxlength="" value="'+tabvalue+'">	</td>
		<td>																													</td>
		<td>																													</td>
		<td>																													</td>
		<td>																													</td>
		<td align=right>				Starting tab		</td><td><input type="checkbox" name="tabstart" value="SELECT=TRUE"></td>
		</tr>
	<tr class="alt">
		<td align=right bgcolor=#A0A0A0><input type="submit" name="TEXT" value="Text">													</td>
		<td align=right>				<input type="text" name="txtvarName" size="18" maxlength="" value="'+txtvarName+'">				</td>
		<td align=right>				<input type="text" name="txtprompt" size="18" maxlength="" value="'+txtprompt+'">				</td>
		<td align=center>				<input type="checkbox" name="txtspan" value="SPAN&#61;TRUE" '+txtspanchk+'>						</td>
		<td align=right colspan=2>		<input type="text" name="txtvalue" size="18" maxlength="" value="'+txtvalue+'">					</td>
		<td align=right colspan=2>		Field width																						</td>
		<td>							<input type="text" name="txtwidth" size="3" maxlength="" value="'+txtwidth+'">					</td>
		</tr>

	<tr>
		<td align=right bgcolor=#A0A0A0><input type="submit" name="LIST" value="Listbox">															</td>
		<td align=right>				<input type="text" name="lstvarName" size="18" maxlength="" value="'+lstvarName+'">							</td>
		<td align=right>				<input type="text" name="lstlabel" size="18" maxlength="" value="'+lstlabel+'">								</td>
		<td align=center>				<input type="checkbox" name="lstspan" value="SPAN=TRUE" '+lstspanchk+'>										</td>
		<td align=right colspan=2>		<input type="text" name="lstvalue" size="18" maxlength="" value="'+lstvalue+'">								</td>
		<td align=right colspan=2>		Preselect index		</td><td><input type="text" name="lstindex" size="3" maxlength="" value="'+lstindex+'">	</td>
		<td align=right>				Set string not no.	</td><td><input type="checkbox" name="lststring" value="VALUE=STRING" '+lststringchk+'>	</td>
		</tr>

	<tr class="alt">
		<td align=right bgcolor=#A0A0A0><input type="submit" name="CHECK" value="Checkbox">												</td>
		<td align=right>				<input type="text" name="chkvarName" size="18" maxlength="" value="'+chkvarName+'">				</td>
		<td align=right>				<input type="text" name="chkprompt" size="18" maxlength="" value="'+chkprompt+'">				</td>
		<td align=center>				<input type="checkbox" name="chkspan" value="SPAN=TRUE" '+chkspanchk+'>							</td>
		<td align=right>				Checked				</td><td><input type="checkbox" name="chkvalue"value="1" '+chkvaluechk+'>	</td>
		</tr>

	<tr>
		<td align=right bgcolor=#A0A0A0><input type="submit" name="RADIO" value="Radio button">														</td>
		<td align=right>				<input type="text" name="radvarName" size="18" maxlength="" value="'+radvarName+'">							</td>
		<td align=right>				<input type="text" name="radprompt" size="18" maxlength="" value="'+radprompt+'">							</td>
		<td align=center>				<input type="checkbox" name="radspan" value="SPAN=TRUE" '+radspanchk+'>										</td>
		<td align=right colspan=2>		<input type="text" name="radvalues" size="18" maxlength="" value="'+radvalues+'">							</td>
		<td align=right colspan=2>		Preselect index		</td><td><input type="text" name="radvalue" size="3" maxlength="" value="'+radvalue+'">	</td>
		<td align=right>				Set string not no.	</td><td><input type="checkbox" name="radstring" value="VALUE=STRING", '+radstringchk+'></td>
		<td align=right>				Horizontal			</td><td><input type="checkbox" name="radorient" value="ORIENT=H" '+radorientchk+'>		</td>
		</tr>

	<tr class="alt">
		<td align=right bgcolor=#A0A0A0><input type="submit" name="LABEL" value="Label">									</td>
		<td>																												</td>
		<td align=right>				<input type="text" name="lblprompt" size="18" maxlength="" value="'+lblprompt+'">	</td>
		<td align=center>				<input type="checkbox" name="lblspan" value="SPAN=TRUE" '+lblspanchk+'>				</td>
		<td align=right colspan=2>		<input type="text" name="lblvalue" size="18" maxlength="" value="'+lblvalue+'">		</td>
		<td>																												</td>
		<td>																												</td>
		<td>																												</td>
		</tr>

	<tr>
		<td align=right bgcolor=#A0A0A0><input type="submit" name="PROPS" value="Props">																</td>
		<td align=right>				<input type="text" name="propvarName" size="18" maxlength="" value="'+propvarName+'">							</td>
		<td align=right>				<input type="text" name="propprompt" size="18" maxlength="" value="'+propprompt+'">								</td>
		<td align=center>				<input type="checkbox" name="propspan" value="SPAN=TRUE" '+propspanchk+'>										</td>
		<td align=right colspan=2>		<input type="text" name="propvalue" size="18" maxlength="" value="'+decode(propvalue)+'">						</td>
		<td align=right colspan=2>		Set variables (var)	</td><td><input type="checkbox" name="propvar" value="SETVARS=UNSUFFIXED" '+propvarchk+'>	</td>
		<td align=right>				Set variables (var_)</td><td><input type="checkbox" name="propvar_" value="SETVARS=SUFFIXED" '+propvar_chk+'>	</td>
		</tr>
		
	<tr class="alt">
		<td align=right bgcolor=#A0A0A0><input type="submit" name="SHOW" value="Show">																</td>
			<td colspan=12>
			<!-- display complete string -->
				<table width=100% border=1>
					<table border=0 width=100% class="table2">
					<td></td><td align=center><b>Input String</b></style></td><td></td>
						<tr>
							<td width=4%></td>
							<td width=92% border=1 height=90 class="note" align=center><textarea name="prevStrings" cols="104" rows="7">'+decode(inputDisplay)+'</textarea>
							<td width=4%></td>
							</tr>
						<tr>
							<td></td><td></td><td></td>
							</tr>
					</table>
				</table>
			</td>
		</tr>
</table>
</form>
</html>']

<!-- output to chat with ## separator and html -->
[r:inputDisplay]
[h:inString=replace(inputDisplay,"&lt;(.*?)&gt;","<\$1>")]
[h:input(inString)]
[h, if (runFrom == "token"):setSpeech("input",inString);""]
<br>

<!-- display completed dialog form -->
[r,dialog('Input String Builder','width=1050; height=540; temporary=1;'):
{
[r:displayString]
}]

@@clearGroup
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=2 ; color=default ; playerEditable=false ; applyToSelected=false ; group=6. Group Move ; tooltip= ; minWidth=90 ; 
[h,if(argCount()>0):switchToken(arg(0)); switchToken(listGet(getSelectedNames(),0))]
[h:'assert(startsWith(token.label,"group"),"This token does not belong to a group",0)']
[h:groupName = token.label]
[h:tokList = getProperty("w42.boT."+token.label)]
[h,foreach(tmpTok,tokList), CODE:{
	[token(tmpTok):resetProperty("w42.boT."+token.label)]
	[token(tmpTok):token.label=""]
}]
[h:resetProperty("w42.boT."+token.label)]
[h:token.label=""]

@@contractGroup
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=6 ; color=default ; playerEditable=false ; applyToSelected=false ; group=6. Group Move ; tooltip= ; minWidth=90 ; 
[h:switchToken(listGet(getSelectedNames(),0))]
[h:x0 = getTokenX()]
[h:y0 = getTokenY()]

<!-- if the selected token belongs to a group, load the corresponding group, if it does not apply to currently selected tokens -->
[h,if(startsWith(token.label,"group_")):tokList = getProperty("w42.boT."+token.label); tokList = getSelectedNames()]

[h,foreach(tmpTok,tokList), CODE:{
	[token(tmpTok):moveToken(x0+round(0.5*(getTokenX()-x0),0), y0+round(0.5*(getTokenY()-y0),0))]
}]

@@formationEchelon
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=default ; playerEditable=false ; applyToSelected=false ; group=6. Group Move ; tooltip= ; minWidth=90 ; 
[h:switchToken(listGet(getSelectedNames(),0))]
[h:x0 = getTokenX(0)]
[h:y0 = getTokenY(0)]

<!-- if the selected token belongs to a group, load the corresponding group, if it does not apply to currently selected tokens -->
[h,if(startsWith(token.label,"group_")):tokList = listAppend(currentToken(), getProperty("w42.boT."+token.label)); tokList = getSelectedNames()]

[h:numToks	= listCount(tokList)]
[h:width	= round(sqrt(numToks),0)]
[h,foreach(tmpTok,tokList), CODE:{
	[token(tmpTok):moveToken(x0+roll.count, y0+roll.count, 0)]
}]

@@formationLine
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=default ; playerEditable=false ; applyToSelected=false ; group=6. Group Move ; tooltip= ; minWidth=90 ; 
[h:switchToken(listGet(getSelectedNames(),0))]
[h:x0 = getTokenX(0)]
[h:y0 = getTokenY(0)]

<!-- if the selected token belongs to a group, load the corresponding group, if it does not apply to currently selected tokens -->
[h,if(startsWith(token.label,"group_")):tokList = listAppend(currentToken(), getProperty("w42.boT."+token.label)); tokList = getSelectedNames()]

[h:numToks	= listCount(tokList)]
[h:width		= round(sqrt(numToks),0)]
[h,foreach(tmpTok,tokList), CODE:{
	[token(tmpTok):moveToken(x0+roll.count, y0, 0)]
}]

@@formationPWedge
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=7 ; color=default ; playerEditable=false ; applyToSelected=false ; group=6. Group Move ; tooltip= ; minWidth=90 ; 
[h:switchToken(listGet(getSelectedNames(),0))]
[h:x0 = getTokenX(0)]
[h:y0 = getTokenY(0)]

<!-- if the selected token belongs to a group, load the corresponding group, if it does not apply to currently selected tokens -->
[h,if(startsWith(token.label,"group_")):tokList = listAppend(currentToken(), getProperty("w42.boT."+token.label)); tokList = getSelectedNames()]

[h:numToks	= listCount(tokList)]
[h:length		= floor(numToks/4)]
[h:tokCount	= 0]
[h,for(yF,0,length+2), CODE:{
	[for(xF,-yF,+yF+1), CODE:{
		[tmpTok = listGet(tokList, tokCount)]
		[token(tmpTok):moveToken(x0+xF, y0+yF, 0)]
		[tokCount = tokCount +1]
		[assert(tokCount < numToks,"",0)]
	}]
}]

@@formationSquare
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=default ; playerEditable=false ; applyToSelected=false ; group=6. Group Move ; tooltip= ; minWidth=90 ; 
[h:switchToken(listGet(getSelectedNames(),0))]
[h:x0 = getTokenX(0)]
[h:y0 = getTokenY(0)]

<!-- if the selected token belongs to a group, load the corresponding group, if it does not apply to currently selected tokens -->
[h,if(startsWith(token.label,"group_")):tokList = listAppend(currentToken(), getProperty("w42.boT."+token.label)); tokList = getSelectedNames()]

[h:numToks	= listCount(tokList)]
[h:width	= round(sqrt(numToks),0)]
[h,foreach(tmpTok,tokList), CODE:{
	[yF = floor((roll.count) / width)]
	[xF = roll.count - yF*width]
	[token(tmpTok):moveToken(x0+xF, y0+yF, 0)]
}]

@@formationStagger
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=default ; playerEditable=false ; applyToSelected=false ; group=6. Group Move ; tooltip= ; minWidth=90 ; 
[h:switchToken(listGet(getSelectedNames(),0))]
[h:x0 = getTokenX(0)]
[h:y0 = getTokenY(0)]

<!-- if the selected token belongs to a group, load the corresponding group, if it does not apply to currently selected tokens -->
[h,if(startsWith(token.label,"group_")):tokList = listAppend(currentToken(), getProperty("w42.boT."+token.label)); tokList = getSelectedNames()]

[h:numToks	= listCount(tokList)]
[h:width		= round(sqrt(numToks),0)]
[h,foreach(tmpTok,tokList), CODE:{
	[token(tmpTok):moveToken(x0+if(odd(roll.count),1,0), y0+roll.count, 0)]
}]

@@formationWedge
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=8 ; color=default ; playerEditable=false ; applyToSelected=false ; group=6. Group Move ; tooltip= ; minWidth=90 ; 
[h:selToks = getSelected()]
[h:switchToken(listGet(selToks,0))]
[h:x0 = getTokenX(0)]
[h:y0 = getTokenY(0)]

<!-- if the selected token belongs to a group, load the corresponding group, if it does not apply to currently selected tokens -->
[h,if(startsWith(token.label,"group_")):tokList = getProperty("w42.boT."+token.label); tokList = listDelete(selToks,listFind(selToks, currentToken()))]

[h:numToks	= listCount(tokList)]
[h:length	= floor(numToks-1/2)]
[h:tokCount	= 0]
[h,for(yF,1,length+1), CODE:{
		[tmpTok = listGet(tokList, tokCount)]
		[token(tmpTok):moveToken(x0-yF, y0+yF, 0)]
		[tokCount = tokCount +1]
		[assert(tokCount < numToks,"",0)]

		[tmpTok = listGet(tokList, tokCount)]
		[token(tmpTok):moveToken(x0+yF, y0+yF, 0)]
		[tokCount = tokCount +1]
		[assert(tokCount < numToks,"",0)]
	}]
}]

@@rotateCCW
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=3 ; color=default ; playerEditable=false ; applyToSelected=false ; group=6. Group Move ; tooltip=tokens in the group CANNOT be set to freesize ; minWidth=90 ; 
[h:bot_rotateGroup(90)]

@@rotateCCW BCK
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=4 ; color=default ; playerEditable=false ; applyToSelected=false ; group=6. Group Move ; tooltip= ; minWidth=90 ; 
[h:'<!-- ROTATE GROUP COUNTER CLOCK WISE -->']
[h:selected	= getSelectedNames()]
[h:switchToken(listGet(selected,0))]
[h:x0		= getTokenX()]
[h:y0		= getTokenY()]
[h:SG		= isSnapToGrid()]

<!-- if the selected token belongs to a group, load the corresponding group, if it does not apply to currently selected tokens -->
[h,if(startsWith(token.label,"group_")):tokList = getProperty("w42.boT."+token.label); tokList = getSelectedNames()]

[h, if(SG), CODE:{
	[foreach(tmpTok,tokList),CODE:{
		[moveToken(getTokenY(1, tmpTok)-y0+x0, y0-getTokenX(1, tmpTok)+x0, 1, tmpTok)]
		[bot_setTokenFacing(bot_getTokenFacing(tmpTok)+90, tmpTok)]
	}]	
};{
	[fDiff	= 45]
	[fCurr	= getTokenFacing()]
	[if(listCount(selected) == 1 && fCurr != ""), CODE:{
		[fOld	= getProperty("w42.bot.oldFacing")]
		[if(fOld == ""): fDiff = fCurr ; fDiff = fCurr - fOld)]
		[setProperty("w42.bot.oldFacing", fCurr)]
	};{}]	
	[a		= bot_toRadians(fDiff)]
	[cos	= bot_cos(a)]
	[sin	= bot_sin(a)]
	[foreach(tmpTok,tokList),CODE:{
		[moveToken((getTokenX(1,tmpTok)-x0)*cos + (getTokenY(1,tmpTok)-y0)*sin + x0, -(getTokenX(1,tmpTok)-x0)*sin + (getTokenY(1,tmpTok)-y0)*cos + y0, 1, tmpTok)]
		[bot_setTokenFacing(bot_getTokenFacing(tmpTok)+fDiff, tmpTok)]
	}]	
}]

@@rotateCW
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=3 ; color=default ; playerEditable=false ; applyToSelected=false ; group=6. Group Move ; tooltip=tokens in the group CANNOT be set to freesize ; minWidth=90 ; 
[h:bot_rotateGroup(-90)]

@@rotateCW BCK
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=3 ; color=default ; playerEditable=false ; applyToSelected=false ; group=6. Group Move ; tooltip= ; minWidth=90 ; 
[h:'<!-- ROTATE GROUP CLOCK WISE -->']
[h:selected	= getSelectedNames()]
[h:switchToken(listGet(selected,0))]
[h:x0		= getTokenX()]
[h:y0		= getTokenY()]
[h:SG		= isSnapToGrid()]

<!-- if the selected token belongs to a group, load the corresponding group, if it does not apply to currently selected tokens -->
[h,if(startsWith(token.label,"group_")):tokList = getProperty("w42.boT."+token.label); tokList = getSelectedNames()]

[h, if(SG), CODE:{
	[foreach(tmpTok,tokList),CODE:{
		[moveToken(-getTokenY(1, tmpTok)+y0+x0, getTokenX(1, tmpTok)+y0-x0, 1, tmpTok)]
		[bot_setTokenFacing(bot_getTokenFacing(tmpTok)-90, tmpTok)]
	}]
};{
	[fDiff	= 45]
	[a		= bot_toRadians(fDiff)]
	[fCurr	= getTokenFacing()]
	[if(listCount(selected) == 1 && fCurr != ""), CODE:{
		[fOld	= getProperty("w42.bot.oldFacing")]
		[if(fOld == ""): fDiff = fCurr ; fDiff = fCurr - fOld)]
		[fDiff	= 360-fDiff]
		[a		= bot_toRadians(fDiff)]
		[setProperty("w42.bot.oldFacing", fCurr)]
	};{}]	
	[cos	= bot_cos(a)]
	[sin	= bot_sin(a)]
	[foreach(tmpTok,tokList),CODE:{
		[moveToken((getTokenX(1,tmpTok)-x0)*cos - (getTokenY(1,tmpTok)-y0)*sin + x0, (getTokenX(1,tmpTok)-x0)*sin + (getTokenY(1,tmpTok)-y0)*cos + y0, 1, tmpTok)]
		[bot_setTokenFacing(bot_getTokenFacing(tmpTok)-fDiff, tmpTok)]
	}]
}]

@@rotateGroup
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=teal ; playerEditable=false ; applyToSelected=false ; group=6. Group Move ; tooltip=tokens in the group CANNOT be set to freesize ; minWidth=90 ; 
[h:'<!-- ---------------------------------------------- Rotate Group (degrees [,tokens]) ---------------------------------------------------------->']
[debug=0]
<!--
	the idea is: 
	- get the rotational offset (thats the centre of the centreTok)
	- translate all otherToks to the actual centre (by deducting the rotational offset)
	- then rotate the otherToks around the origin
	- then translate them back to the offset (by adding the rotational offset)
	- finally substract the size of the tok from eithe x or y (depending on the direction) to composate for the size of the tok. 
-->
[h:assert(getLibProperty('vblSupport','lib:EventMacros'),"This version of maptool does NOT support this function",0)]

[rotation	= arg(0)]
[assert(rotation/90 == floor(rotation/90), "You can only give multiples of 90 degrees",0)]

[if(argCount() > 1): toks	= arg(1) ; toks	= getSelectedNames()]
[assert(listCount(toks) > 0, "Make sure you have a centreTok AND its otherToks selected",0)]

<!-- seperate otherToks from centreTok and rotate all the token 90 degrees-->
[foreach(tok,toks), CODE:{
	[bot_setTokenFacing(bot_getTokenFacing(tok) + rotation,tok)]
}]
[centreTok	= listGet(toks, 0)]
[otherToks	= listDelete(toks,0)]

<!-- get the rotational offset -->
[X0	= getTokenX(1, centreTok)	+ round(getTokenWidth(centreTok)/2)]
[Y0	= getTokenY(1, centreTok)	+ round(getTokenHeight(centreTok)/2)]

<!-- 
	this function works for rotation steps of 90 degrees only.
	keep in mind that the setpsize must be +/- according to the 
	rotation direction or the for loop wont work.
 -->
[stepSize	= if(rotation<0, -90, 90)]
[for(rot, 0, rotation, stepSize), CODE:{
[foreach(tok, otherToks), CODE:{
		<!-- while this is no point rotation but a cell rotation, youll need to take care of the doorsize as well. -->
		<!-- you never know the orientation of the tok and some tok tokens have a different height from width... -->
		[sizeDoor	= round(max(getTokenWidth(tok),getTokenHeight(tok)))]
		<!-- get current position of tok -->
		[XD			= getTokenX(1, tok)]
		[YD			= getTokenY(1, tok)]
		<!-- translate tok to the correct position (-translate, rotate, +translate) -->
		[X			= if(rotation < 0, -1, 1)*(YD-Y0) + X0 - if(rotation < 0, sizeDoor, 0)]
		[Y			= if(rotation > 0, -1, 1)*(XD-X0) + Y0 - if(rotation > 0, sizeDoor, 0)]
		[if(debug == 1): pause("X0","Y0","XD","YD","X","Y","centreTok","tok","sizeDoor")]
		[moveToken(X,Y,1,tok)]
	}]
}]

@@setGroup
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=1 ; color=default ; playerEditable=false ; applyToSelected=false ; group=6. Group Move ; tooltip= ; minWidth=90 ; 
[h:'<!-- setGroup (token names, group name) -->']
[h,if(argCount()): grpList = arg(0) ; grpList = getSelectedNames()]
[h,if(argCount()>1): name = arg(1) ; name="name"]
[h,if(argCount()>1): askName = 0 ; askName = 1]

<!-- first clear any group assignments still there, do grab the old name to provide in the input -->
[h, foreach(tok, grpList), CODE:{
	[token(tok),if(startsWith(token.label, "group_")), CODE:{
		[name = substring(token.label, 6)]
		[bot_clearGroup(tok)]	
	}; {}]
}]

<!-- if no name as argument was given, ask for it -->
[h, if(askName):abort(input("name|"+name+"|Enter name (no spaces)"))]
<!-- for each tok in the selected group, set a token property with the list of all the tokens in the group -->
[h, foreach(tok, grpList), CODE:{
	[switchToken(tok)]
	<!-- set groupname in the token label -->
	[token.label = "group_"+name]
	<!-- delete self from the token list -->
	[tmpList = listDelete(grpList, listFind(grpList, tok))]
	<!-- set the rest of the names of the tokens of the group in the property -->
	[setProperty("w42.boT."+token.label, tmpList)]
}]
[r:grpList+" have grouped into one group names: "+name]

@@spreadGroup
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=5 ; color=default ; playerEditable=false ; applyToSelected=false ; group=6. Group Move ; tooltip= ; minWidth=90 ; 
[h:switchToken(listGet(getSelectedNames(),0))]
[h:x0 = getTokenX()]
[h:y0 = getTokenY()]

<!-- if the selected token belongs to a group, load the corresponding group, if it does not apply to currently selected tokens -->
[h,if(startsWith(token.label,"group_")):tokList = getProperty("w42.boT."+token.label); tokList = getSelectedNames()]

[h,foreach(tmpTok,tokList), CODE:{
	[token(tmpTok):moveToken(x0+2*(getTokenX()-x0), y0+2*(getTokenY()-y0))]
}]

@@clearSelectGroup
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=5 ; color=default ; playerEditable=false ; applyToSelected=false ; group=8. Group Select ; tooltip=<html>This ungroups a 'Select Group'. You only need to select one token of the group to ungroup the entire group ; minWidth=90 ; 
[h:'<!-- -------------------------------- clearSelectGroup () --------------------------------------->']
<!-- 
<html>This ungroups a 'Select Group'. You only need to select one token of the group to ungroup the entire group
-->
[h:tokenId	= listGet(getSelected(),0)]
[h:groupTokenLst	= getProperty("w42.bot.groupToken", tokenId)]
[h, foreach(tok, groupTokenLst), if(findToken(tok)!=""):resetProperty("w42.bot.groupToken", tok)]

[h:broadcast("Tokens have been ungrouped.")]

@@groupFrame
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy=2 ; color=default ; playerEditable=false ; applyToSelected=false ; group=8. Group Select ; tooltip= ; minWidth=90 ; 
[h:'<!-- ------------------ groupFrame ----------------------------------->']
[h,if(argCount()): tooMany	= arg(0) ; tooMany	= 0]
[frame("Group Select Panel", "width=70; height=4; temporary=1"): {
	<html>
		<head>
			<link rel='onChangeSelection' type='macro' href='[r: macroLinkText("groupHandler@Lib:OnTokenMove", "none")]'>
		</head>
		<body>
			[r:if(tooMany, "Group Select Panel is deactivated cause their are currently too many tokens selected: "+tooMany+"<br>", "")]
			Please leave this frame open, it auto selects the 'siblings' of a 'select group'
		</body>
	</html>
}]

@@groupHandler
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=3 ; color=default ; playerEditable=false ; applyToSelected=false ; group=8. Group Select ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------- groupHandler () --------------------------------------->']
[h:currentSelection	= getSelected("json")]

[h:maxGroupSelect	= getLibProperty('maxGroupSelect','lib:EventMacros')]
[h:numSelect		= json.length(currentSelection)]
[h,if(numSelect > maxGroupSelect), CODE:{
	[bot_groupFrame(numSelect)]
	[abort(0)]
};{}]

<!-- build in delay to make sure the open door macro is called only once as the token select event will fire 2 to 4 times when you select a token -->
[h, if(bot_timeOut(2)), CODE:{
	[bot_resetTimer(2)]
	[lastSelection	= getLibProperty('lastSelection.GroupSelect','lib:EventMacros')]
	<!-- if the time out is too short then the selection gets reset to its original, this needs to be corrected -->
	[redoSelection	= if(numSelect == 1 && json.length(lastSelection) > 1 && json.length(json.intersection(lastSelection, currentSelection)) == 1,1,0)]
	[if(redoSelection):newSelection	= lastSelection ; newSelection	= json.difference(currentSelection, lastSelection)]
	[if(json.length(newSelection) >= 1), CODE:{	
		<!-- first create a complete json array of all tokens to be selected -->
		[toSelect	= "[]"]
		[foreach(tok, newSelection): toSelect = json.union(toSelect, if(json.type(getProperty("w42.bot.groupToken", tok))=='ARRAY', getProperty("w42.bot.groupToken", tok), '[]')))]
		<!-- remove the already selected tokens -->
		[groupTokenLst	= json.difference(json.unique(toSelect), currentSelection)]
		<!-- select the not already selected tokens of the group -->
		[if(json.length(groupTokenLst)): selectTokens(groupTokenLst,1,"json")]
	};{}]

	[if(isFrameVisible("Draw Order")), CODE:{
		[maxOrderSelect	= getLibProperty('maxOrderSelect','lib:EventMacros')]
		[if(numSelect > maxOrderSelect): bot_orderWarning(numSelect) ; bot_orderFrame()] 
	};{}]

	<!-- set time out again (cause the above could have take some time) and set last selection -->
	[bot_resetTimer(2)]
	[setLibProperty('lastSelection.GroupSelect', getSelected("json"), 'lib:EventMacros')]
}; {
	<!-- sometimes the former selection is negated (erratically) when this happens reselect ONLY the deselected tokens -->
	[lastSelection	= getLibProperty('lastSelection.GroupSelect','lib:EventMacros')]
	[groupTokenLst	= json.difference(lastSelection, currentSelection)]
	[if(json.length(groupTokenLst)): selectTokens(groupTokenLst,1,"json")]
}]

@@openGroupFrame
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy=1 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=8. Group Select ; tooltip=<html>This opens a 'group select' frame which is required for the 'Select Group' to function.<br>When this panel is closed you can still group and ungroup, but the 'auto select' will only<br>work when this frame is active. ; minWidth=90 ; 
[h:'<!------------------------------------- openGroupFrame ------------------------------------------------>']
<!-- <html> Turns on door switches at selected players. This will allow players to use doorswitches -->
[h:assert(isGM(),"This macro can only be run by the GM",0)]
[h:userList	= getAllPlayerNames()]

[h,if(listCount(userList) != 1), CODE:{
	[h:'<!-- input string -->']
	[h:inputStr	= "junk|<html><b>Turn on door switches for selected players<br></html>|-|LABEL|SPAN=TRUE"]
	[H,FOREACH(player, userList): inputStr = listAppend(inputStr, "player"+roll.count+"|1|"+player+"|CHECK","@")]

	[h:'<!-- ask for input-->']
	[h:abort(eval(listFormat(inputStr, "input( %list )", " ' %item ' ", ",", "@")))]

	[h:playerList = ""]
	[H,FOREACH(player, userList), CODE:{
		[if(eval("player"+roll.count)): playerList = listAppend(playerList, player)]
	}]
};{
	[h:playerList = userList]
}]

<!-- need to make certain that this value is initialized on lib eventmacros -->
[h:bot_resetTimer(2)]
[h:setLibProperty('lastSelection.GroupSelect', '[]', 'lib:EventMacros')]

[h:bot_execAllPlayers("groupFrame@lib:OnTokenMove","", playerList)]

@@setSelectGroup
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=4 ; color=default ; playerEditable=false ; applyToSelected=false ; group=8. Group Select ; tooltip=<html>This macro creates a 'select group' of all currently selected tokens.<br>After a group is set (and the group select frame is active) when you<br>select one token of the group, all the other tokens of the group will be<br>automatically selected as well. This is particularly usefull when drawing<br>maps and you want to group a set of tokens into one object. ; minWidth=90 ; 
[h:'<!-- -------------------------------- setSelectGroup () --------------------------------------->']
<!-- 
<html>This macro creates a 'select group' of all currently selected tokens.<br>After a group is set (and the group select frame is active) when you<br>select one token of the group, all the other tokens of the group will be<br>automatically selected as well. This is particularly usefull when drawing<br>maps and you want to group a set of tokens into one object.
--> 

[h:selected	= getSelected("json")]
[h,foreach(tok, selected): setProperty("w42.bot.groupToken", selected, tok)]
[h:broadcast("Tokens have been grouped.")]

@@conditionalOutput
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=default ; playerEditable=false ; applyToSelected=false ; group=LMarkus Whispers ; tooltip= ; minWidth=90 ; 
[h:'<!-- ---------------- CONDITIONALOUTPUT ----------------------------- -->']
[h: args = macro.args]
[h, if(json.type(args)=='OBJECT'), CODE:{
	[text	= json.get(macro.args, 'toSend')]
};{
	[text	= args]
}]

[r:execMacro(text)]

@@outputTo
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=default ; playerEditable=false ; applyToSelected=false ; group=LMarkus Whispers ; tooltip= ; minWidth=90 ; 
[h:'<!-- ---------------- OUTPUTTO ----------------------------- -->']

[h: toPlayer	= arg(0)]
[h: message		= arg(1)]
[h: fromWho		= arg(2)]

[h, if(json.type(toPlayer) == 'ARRAY'), CODE:{
    [toWho	= 'list']
    [toSend	= json.set('{}', 'mlOutputList', toPlayer)]
};{
    [toWho	= toPlayer]
	[toSend	= '{}']
}]
[h: toSend				= json.set(toSend, 'toSend', arg(1))]
[h, if(fromWho == currentToken() || fromWho == ""): 
	conditionalOutput	= macroLinkText('conditionalOutput@this', toWho, toSend)
;
	conditionalOutput	= macroLinkText('conditionalOutput@this', toWho, toSend, fromWho)
]
[h: execLink(conditionalOutput, 1)]

@@sendWhisper
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=110 ; color=default ; playerEditable=false ; applyToSelected=false ; group=LMarkus Whispers ; tooltip= ; minWidth=90 ; 
[h:'<!-- ---------------- SENDWHISPER ----------------------------- -->']

[H: args			= arg(0) ]
[H: whisperText	= json.get(args, "whisperText")]
[H: numPlayers	= json.get(args, "numPlayers")]
[H: numPlayers	= json.get(args, "numPlayers")]
[H: color		= json.get(args, "color")]
[H: italic		= if( json.contains(args, "italic"), 1, 0)]
[H: bold		= if( json.contains(args, "bold"), 1, 0)]
[H: underline	= if( json.contains(args, "underline"), 1, 0)]

[h: lastSettings	= strPropFromVars("color, italic, bold, underline", "UNSUFFIXED")]
[h: setLibProperty("w42.bot.whisperPanel.lastSettings", lastSettings)]

[h,if(italic), CODE:{
	[italicOpen		="<i>"]	[italicClose	="</i>"]
};{
	[italicOpen		=""]	[italicClose	=""]
}]

[h,if(bold), CODE:{
	[boldOpen		="<b>"]	[boldClose		="</b>"]
};{
	[boldOpen		=""]	[boldClose		=""]
}]

[h,if(underline), CODE:{
	[underlineOpen	="<u>"]	[underlineClose	="</u>"]
};{
	[underlineOpen	=""]	[underlineClose	=""]
}]

[h: whisperText		= strformat("<font color=%{color}>%{italicOpen}%{boldOpen}%{underlineOpen}%{whisperText}%{underlineClose}%{boldClose}%{italicClose}</font>")]

[h,if(json.contains(args, "impersonate")), CODE:{
	[fromWho	= getSelected()]
	[assert(listCount(fromWho) == 1, "ABORTED: make sure you have (only) one token selected",0)]
	[assert(if(isGM() || isOwner(getPlayerName(), fromWho),1,0),"ABORTED: you do not own this token",0)]
};{
	[fromWho	= currentToken()]
}]

[h,if(json.contains(args, "allPlayers")), CODE:{
	[toPlayer	= "all"]
};{
	[toPlayer	= ""]
	[for(i, 0, numPlayers), CODE: {
		[key	= "selectedPlayerName" + i]
		[if(json.contains(args, key)):	toPlayer = json.append(toPlayer, json.get(args, key))]
	}]
}]

[h: bot_outputTo(toPlayer, whisperText, fromWho)]
[H: bot_whisperFrame( json.fromList(json.fields(args)) ) ]

@@whisperFrame
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=110 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=LMarkus Whispers ; tooltip=<html>This opens a frame where you can send formatted text to specific players.<br> <u>Alternatively</u> you can send a message to <u>all</u> players as if you<br> impersonate the selected token, without actually needing to impersonate it.<br> <br> <b>Notes</b> <br> - you must either be the gm or own the selected token to do this.<br> - the impersonation ONLY works with <i>all players</i> check box <br>   selected. (So not when some or all the individual player checkboxes are<br>   selected!!)</html> ; minWidth=90 ; 
[h:'<!-- ---------------- SHOWWHISPERFRAME ----------------------------- -->']

<!-- 
<html>This opens a frame where you can send formatted text to specific players.<br>
<u>Alternatively</u> you can send a message to <u>all</u> players as if you<br>
impersonate the selected token, without actually needing to impersonate it.<br>
<br>
<b>Notes</b> <br>
- you must either be the gm or own the selected token to do this.<br>
- the impersonation ONLY works with <i>all players</i> check box <br>
  selected. (So not when some or all the individual player checkboxes are<br>
  selected!!)</html>
 -->

[H: selectedPlayerName	= arg(0) ]
[H: selectedPlayerName	= if( json.isEmpty(selectedPlayerName), "[]", selectedPlayerName ) ]

[H: allPlayerNames		= getAllPlayerNames("json")]
[H: count				= 0]
[h: lastSettings		= getLibProperty("w42.bot.whisperPanel.lastSettings")]
[h, if(lastSettings == ""): lastSettings	= "color=black ; italic=0 ; bold=0 ; underline=0"]
[h: varsFromStrProp(lastSettings)]

[frame("Whisper", "width=250; height=300"): {
	<html><head><title>Whisper</title></head><body>
	<form name="Whisper" method="json" action='[R: macroLinkText("sendWhisper@this","none")]'>
		<table border="0" cellpadding="0" cellspacing="0">
			<tr><th>
				Send To	<small>([R: macroLink("Refresh Player List", "displayWhisperFrame@this", "none")])</small>
			</th></tr><tr><td>
			<table>
				[R, FOREACH(playerName, allPlayerNames, ""), CODE: { 
					<tr><td><input type="checkbox" name="selectedPlayerName[R: count]" value="[R: playerName]" [R: checked	= if( json.contains( selectedPlayerName, "selectedPlayerName"+count), "CHECKED", "" ) ] ></td><td>[R: playerName]</td></tr>
					[H: count	= count + 1]
				}]
				<tr><td colspan=2>_________________________</td></tr>
				
				<tr><td><input type="checkbox" name="allPlayers"	value="1" [R: checked	= if(json.contains(selectedPlayerName, "allPlayers"),	"CHECKED", "")] ></td><td> All Players (no whisper)</td></tr>
				<tr><td><input type="checkbox" name="impersonate"	value="1" [R: checked	= if(json.contains(selectedPlayerName, "impersonate"),	"CHECKED", "")] ></td><td> Impersonate selected token<br><font size = 2> (only works if 'All Players' is selected)</font></td></tr>
			</table>
			</td></tr><tr><td>
				<textarea name="whisperText" cols="30" rows="5" wrap="soft" ></textarea>
			</td></tr><tr><td>
				<select name='color'>
					<option value='black'	[r:if(color == 'black',		'selected',	'')]>Black		</option>
					<option value='gray'	[r:if(color == 'gray',		'selected',	'')]>Gray		</option>
					<option value='maroon'	[r:if(color == 'maroon',	'selected',	'')]>Maroon		</option>	
					<option value='red'		[r:if(color == 'red',		'selected',	'')]>Red		</option>
					<option value='yellow'	[r:if(color == 'yellow',	'selected',	'')]>Yellow		</option>
					<option value='green'	[r:if(color == 'green',		'selected',	'')]>Green		</option>
					<option value='blue'	[r:if(color == 'blue',		'selected',	'')]>Blue		</option>
					<option value='navy'	[r:if(color == 'navy',		'selected',	'')]>Dark Blue	</option>
					<option value='purple'	[r:if(color == 'purple',	'selected',	'')]>Purple		</option>
				</select>

			</td></tr><tr><td>

			<table><font size='150%'>
				<tr><td><input type='checkbox' name='italic'	[r:if(italic,	'checked', '')]>	</td><td><i>Italic</i>		</input></td></tr>
				<tr><td><input type='checkbox' name='bold'		[r:if(bold,		'checked', '')]>	</td><td><b>Bold</b>		</input></td></tr>
				<tr><td><input type='checkbox' name='underline'	[r:if(underline,'checked', '')]>	</td><td><u>Underline</u>	</input></td></tr>
			</font></table>

			</td></tr><tr><td align="center">
				<input type='submit' value='Send' >
				<input type='hidden' name='numPlayers' value='[R: json.length(allPlayerNames)]' >
			</td></tr>
		</table>
	</form></body></html>
}]
[H: abort(0)]

@@convertTrapPit
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=10 ; color=darkgray ; playerEditable=true ; applyToSelected=false ; group=Event Macros ; tooltip=<html>This macro will convert ALL Pits and Traps on ALL (not excluded) maps to EventPads.<br>For pits you will need to rewrite the macro slightly before it works again. ; minWidth=90 ; 
[h:'<!-- convertTrapPit -->']
[h, if(argCount()):passResult = arg(0); passResult = 0]
[h:mapList = getAllMapNames("json")]
[h:oldMap = getCurrentMapName()]

[h:tmpList = json.toList(mapList)]
[h:excludedMaps = getLibProperty("excludedMaps", "lib:EventMacros")]
[H:activeMaps = json.difference(mapList,excludedMaps)]

[r,foreach(currentMap,activeMaps), code: {
	[h:setCurrentMap(currentMap)]
	[h:allToks = getTokenNames(",", json.set("{}", "layer", json.append("","TOKEN", "HIDDEN", "OBJECT", "BACKGROUND")))]
	Fixed following tokens on map <b>{currentMap}</b>:
	[h:fixedList = ""]
	[h:i=1]
	[h,foreach(me,allToks), CODE:{
		[isTrap	= if(startsWith(me,"Trap "),1,0)]
		[isPit	= if(startsWith(me,"Pit "),1,0)]
		[fixIt	= if(isPit || isTrap,1,0)]
		[if(fixIt): padNumber	= substring(me, indexOf(me, " "))]
		['pause("isTrap", "isPit", "me", "padNumber", "allToks")']
		[if(fixIt): fixIt		= if(isNumber(padNumber),1,0)]
		
		[if(fixIt): switchToken(me)]
		[if(fixIt): token.name = "EventPad "+ i]
		[if(fixIt): i=i+1]
		
		[if(fixIt && isTrap): setProperty("w42.bot.eventTypeList", "movedOn, movedOver, movedReturn")]
		[if(fixIt && isPit): setProperty("w42.bot.eventTypeList", "movedOn, movedOff, movedOver, movedReturn")]

		[if(fixIt): fixedList = listAppend(fixedList, me)]
	}]
	{fixedList}
}]
[h:setCurrentMap(oldMap)]
[r:bot_initializePads()]

@@executeEvent
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=5 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Event Macros ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------- executeEvent ----------------------------- -->']
[h:'<!-- This macro generates a list of macros per group from the lib:Event token.<br>You can select one or more macros which then will be executed -->']

[h:'<!-- create a list of the macro groups -->']

[h:oldMap = getCurrentMapName()]
[h:setCurrentMap(getLibProperty("baseMapName", "lib:EventMacros"))]
[h:macroLabels	= getMacros(",", "lib:EventMacros")]

[h:groupList	= ""]
[h, foreach(macro, macroLabels, "<br>"), CODE:{
	[tmp		= getMacroIndexes(macro, ",", "lib:EventMacros")]
	[group		= getStrProp(getMacroProps(tmp, "; ", "lib:EventMacros"), "group")]
	[if(!listContains(groupList, group)): groupList = listAppend(groupList, group)]
}]
[h:groupList = listSort(groupList, "N+")]

[h:'<!-- ---------------------------------Generate Input Screen based on found groups-------------------->']
[h:inputStr		= "junk|<html><b>Select an event macro from the lists</b></html>|-|LABEL|SPAN=TRUE"]

[h,foreach(group, groupList), CODE:{
	[groupName		= "group_"+roll.count]
	[macroList		= getMacroGroup(group, ",", "lib:EventMacros")]
	[macroNameList	= "<none>"]
	[foreach(macro, macroList,""): macroNameList = listAppend(macroNameList, getStrProp(getMacroProps(macro, "; ", "lib:EventMacros"), "label"))]
	[h:macroNameList	= listSort(macroNameList, "N+")]
	[if(group == ""): group = "~Ungrouped~"]
	[inputStr		= listAppend(inputStr, groupName+"|"+macroNameList+"|"+group+" |LIST|VALUE=STRING", "##")]
}]
[h:setCurrentMap(oldMap)]

[h:'<!-- ask for input -->']
[h: inputStr			= listFormat(inputStr, "input( %list )", " ' %item ' ", ", ", "##")]
[H: abort(eval(inputStr))]

[h:'<!-- --------------------------------- execute chosen macro -------------------->']
[h,foreach(group, groupList), CODE:{
	[choice		= eval("group_"+roll.count)]
	[if(choice != "<none>"), CODE:{[r,macro(choice+"@Lib:EventMacros"): ""]}]
}]

@@getEventType
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=10 ; color=default ; playerEditable=true ; applyToSelected=true ; group=Event Macros ; tooltip= ; minWidth=90 ; 
[h:'<!-- ---------------------------getEventType --------------------------------------------------- -->']
<!-- NO NEW SCOPE ; IGNORE OUTPUT -->
<!-- check which event type this token triggers this can be 
  trigger type (started, ended, moved, same length)
- noInteraction	(0000)
- movedOn		(0110)
- movedOff 		(1010)
- movedOver 	(0010)
- movedNot		(1101)	when you move the token but place it back on its original spot
- movedReturn	(1110)	when you move the token AND use way points AND leave the token but end the move onto the token
- movedRemain	(1111)	when you move but remain on the token during the entire move (both the path and the triggerpath are the same length)
Note that ONLY ONE event will be TRUE the REST WILL BE FALSE
- movedWard		(1001)	when you move the token over or onto a Ward -->

[pathLength		= json.length(lastPath)]
[triggerLength	= json.length(eventPadTriggered)]

[startedOnPad	= if(json.contains(eventPadTriggered,startingLocation),1,0)]
[endedOnPad		= if(json.contains(eventPadTriggered,currentLocation),1,0)]
[didMove		= min(1, json.length(lastPath)-1)]
[sameLength		= if(pathLength == triggerLength, 1, 0)]

<!-- get trigger type add the three results into a string e.g. 011 == movedOn-->
[if(triggerLength):	triggerString = strformat("%{startedOnPad}%{endedOnPad}%{didMove}%{sameLength}") ; triggerString = 0]
[triggerTypeList	= "noInteraction, movedOn, movedOff, movedOver, movedNot, movedReturn, movedRemain, movedWard"]
[triggerStringList	= "0,110,1010,10,1101,1110,1111,1001"]
<!-- 'pause("startedOnPad","endedOnPad","didMove","sameLength", "eventPadTriggered","lastPath", "startingLocation","currentLocation","triggerString","triggerLength")' -->

[if(listContains(triggerStringList, triggerString)): 
	triggerType		= listGet(triggerTypeList, listFind(triggerStringList, triggerString))
; 
	assert(0,"Error occured in getEventType: "+triggerString+" trigger (started, ended, moved, not left) string is unknown",1)
]

[macro.return = triggerType]

@@resetPit
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=10 ; color=darkgray ; playerEditable=true ; applyToSelected=true ; group=Event Macros ; tooltip=<html>This will reset a sprung pit. Select the pit and click this button<br>This macro can also be put on the selection panel of the token. ; minWidth=90 ; 
[h, token(getSelected()):  setTokenImage(getTokenPortrait())]

@@setEventButton
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=8 ; color=fuchsia ; playerEditable=false ; applyToSelected=false ; group=Event Macros ; tooltip=<html>This macro can be used to link an Event Macro to a Event Button.<br><br>1. Create a macro on the lib:EventMacros token in the group: 'Event Button Macros', containing the<br>code that is activated when the button, e.g. 'Switch To Map'<br>2. Select the button (any token will do) to which that macro should apply e.g. "Switch to Fair Haven"<br>3. Run this macro<br>4. Select "Switch Map" from the list<br>5. In the "Give Arguments" box enter the arguments as a stringproperty, e.g."toMap=Fair Haven"<br><br>Here it is important that both the the arguments name (toMap) and the arguments (Fair Haven)<br>contains ONLY alphanumeric  characters!<br>Note that you can give multiple arguments! Just seperate them with a ;.<br>E.g. toMap=Fair Haven;message=Going to Fair Haven.<br><br>6. Click OK. Now everything is set up<br><br>To use the buttons you need to run the macro 'Activate Switches'. This is used for door switches<br>but it will also work for the Event Buttons. Now when thats done you will notice a pop-up. You can<br>make this pop-up small, but you cannot close it (else the buttons will not work).<br><br>If you now click on the button "Switch to Fair Haven" the macro "Switch Map" is activated.</html>--> ; minWidth=90 ; 
[h:'<!-- --------------------------------- setEventButton ----------------------------------------------->']
[h:debug=0]
[h:assert(isGM(),"GM only!",0)]
<!-- <html>
This macro can be used to link an Event Macro to a Event Button.<br>
<br>
1. Create a macro on the lib:EventMacros token in the group: 'Event Button Macros', containing the<br>
code that is activated when the button, e.g. 'Switch To Map'<br>
2. Select the button (any token will do) to which that macro should apply e.g. "Switch to Fair Haven"<br>
3. Run this macro<br>
4. Select "Switch Map" from the list<br>
5. In the "Give Arguments" box enter the arguments as a stringproperty, e.g."toMap=Fair Haven"<br>
<br>
Here it is important that both the the arguments name (toMap) and the arguments (Fair Haven)<br>
contains ONLY alphanumeric  characters!<br>
Note that you can give multiple arguments! Just seperate them with a ;.<br>
E.g. toMap=Fair Haven;message=Going to Fair Haven.<br>
<br>
6. Click OK. Now everything is set up<br>
<br>
To use the buttons you need to run the macro 'Activate Switches'. This is used for door switches<br>
but it will also work for the Event Buttons. Now when thats done you will notice a pop-up. You can<br>
make this pop-up small, but you cannot close it (else the buttons will not work).<br>
<br>
If you now click on the button "Switch to Fair Haven" the macro "Switch Map" is activated.</html>
-->

[h:selectedTokens = getSelectedNames()]
<!-- assert correct selected -->
[h:assert(listCount(selectedTokens),"Please select at least one token first before running this macro",0)]

<!-- initialize values -->
[h:oldMap			= getCurrentMapName()]
[h:setCurrentMap(getLibProperty("baseMapName", "lib:EventMacros"))]

<!-- create macro list from the Event Button Macros group -->
[h:macroIDList		= getMacroGroup("Event Button macros", ",", "lib:EventMacros")]
[h:macroNameList	= "<none>"]
[h,foreach(id, macroIDList): macroNameList = listAppend(macroNameList, getStrProp(getMacroProps(id, "; ", "lib:EventMacros"),"label"))]

[h:setCurrentMap(oldMap)]

[h:me				= listGet(selectedTokens,0)]
[h:all.buttonArgs	= getProperty("buttonArgs",me)]

[h,if(getStrProp(all.buttonArgs, "macroToCall")==""), CODE:{
	[macroToCall	= "name of macro"]
	[buttonArgs		= "argumentName=give argument;"]
};{
	[macroToCall	= getStrProp(all.buttonArgs, "macroToCall")]
	[buttonArgs		= deleteStrProp(all.buttonArgs, "macroToCall")]
	<!-- remove @Lib:EventMacros from macroToCall -->
	[macroToCall	= substring(macroToCall, 0, indexOf(macroToCall,"@"))]
}]

[h:assert(macroNameList != "","First create at least one macro on the lib:EventMacro token with which this eventPad can be associated",0)]
[h,if(listContains(macroNameList, macroToCall)):currentMacro = listFind(macroNameList,macroToCall) ; currentMacro = 0]

[h,if(debug == 1):pause("macroToCall", "macroNameList", "currentMacro", "buttonArgs")]

<!-- ask for input -->
[h:abort(input(
	'junk|<html><b>Associated Macro</b><br>This macro will be linked to ALL currently selected tokens:<br><u>'+selectedTokens+'</u><br>Note that only the macros from the group: "Event Button macros" on "Lib:EventMacros" are in the drop downlist </html>|-|LABEL|SPAN=TRUE',
	'macroToCall|'	+macroNameList	+'|<html><span title="<html><b>Enter here the name of the macro that is used when the button is activated.</html>">Name of associated macro</html></span></html>|LIST|SELECT='+currentMacro,
	'buttonArgs|'	+buttonArgs	+'|<html><span title="<html>Enter the argument(s) to be passed to the activated macro<br>as a stringproperty, e.g.&quot;toMap=Fair Haven&quot;<br>Here it is important that both the the arguments name (toMap)<br>and the arguments (Fair Haven) contains ONLY alphanumeric  characters!<br>Note that you can give multiple arguments! Just seperate them with a ;.<br>E.g. toMap=Fair Haven;message=Going to Fair Haven.<br></html>">Give arguments for macro</html></span></html>|TEXT|WIDTH=50',
	'removeLink|0|<html>Check to remove any macro linked to selected token(s).</html>|CHECK'
))]

[h:macroToCall	= listGet(macroNameList, macroToCall)]
[h:buttonArgs	= setStrProp(buttonArgs, "macroToCall", macroToCall+"@lib:EventMacros")]
<!-- set choices for all selected tokens -->
[r,gm,if(removeLink), CODE:{
	[h,foreach(me, selectedTokens):resetProperty("buttonArgs", me)]
	[r, gm:"The Macro <u>"+macroToCall+"</u> is now <b>REMOVED</b> from the following token(s)<u> "+selectedTokens+"</u>."]
};{
	[h,foreach(me, selectedTokens):setProperty("buttonArgs", buttonArgs, me)]
	[r, gm:"The Macro <u>"+macroToCall+"</u> is now linked to the following token(s)<u> "+selectedTokens+"</u>. This macro will be executed when this (or one of these) tokens are selected: <u>"+selectedTokens+"</u>. Keep in mind that you first need to run 'Activate Switches' before they work!"]
}]

<!-- reselect the selected tokens -->
[h:selectTokens(selectedTokens,1,",")]

[h,if(debug==1), CODE:{
	[me			= listGet(selectedTokens,0)]
	[butArgs	= getProperty("buttonArgs", me)]
	[bot_debugInfo("butArgs, me, selectedTokens",1,1,0, getMacroName(), getMacroLocation() )]
};{}]

@@setEventPad
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=8 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Event Macros ; tooltip=<html>This macro can be used to link an Event Macro to an EventPad<br><br>1. Create a macro on the lib:EventMacros token in the group:<br>'Event Pad Macros', containing the code that is activated when the<br>Event is triggered. For example 'Spear Trap<br>2. Select an 'Event token'. This is a token which name starts with<br>'EventPad ' e.g. 'EventPad 1' or 'EventPad Pit Trap'.<br>This token can be placed on any layer<br>3. Run the macro 'Set Event Pad'<br>4. Pick an Event macro from the list, e.g. 'Standard Pit'<br>5. Then select the events on which this macro is triggered<br>7. Click OK <br>8. Run 'Initialize Maps'<br><br>The Event Pad is now set<br> ; minWidth=90 ; 
[h:'<!-- --------------------------------- setEventPad ----------------------------------------------->']
<!-- 
<html>
This macro can be used to link an Event Macro to an EventPad<br>
<br>
1. Create a macro on the lib:EventMacros token in the group:<br>
'Event Pad Macros', containing the code that is activated when the<br>
Event is triggered. For example 'Spear Trap<br>
2. Select an 'Event token'. This is a token which name starts with<br>
'EventPad ' e.g. 'EventPad 1' or 'EventPad Pit Trap'.<br>
This token can be placed on any layer<br>
3. Run the macro 'Set Event Pad'<br>
4. Pick an Event macro from the list, e.g. 'Standard Pit'<br>
5. Then select the events on which this macro is triggered<br>
7. Click OK <br>
8. Run 'Initialize Maps'<br>
<br>
The Event Pad is now set<br>
-->

[h:selectedTokens = getSelectedNames()]
<!-- assert correct selected -->
[h:assert(listCount(selectedTokens),"Please select an EventPad first before running this macro",0)]
[h,foreach(me, selectedTokens):assert(startsWith(me, "EventPad "),"Make sure only Eventpad(s) are selected",0)]
[h:me = listGet(selectedTokens,0)]
[h:switchToken(me)]

<!-- initialize values -->
[h:oldMap = getCurrentMapName()]
[h:setCurrentMap(getLibProperty("baseMapName", "lib:EventMacros"))]
	[h:macroIDList		= getMacroGroup("Event Pad Macros", ",", "lib:EventMacros")]
	<!-- create macro list from the Event Button Macros group -->
	[h:macroNameList	= "<none>"]
	[h,foreach(id, macroIDList): macroNameList = listAppend(macroNameList, getStrProp(getMacroProps(id, "; ", "lib:EventMacros"),"label"))]
[h:setCurrentMap(oldMap)]

[h:macroName		= getProperty("w42.bot.macroName")]
[h,if(macroName == ""): macroName = "name of macro"]
[h:eventTypeList	= getProperty("w42.bot.eventTypeList")]
[h:triggerTypeList	= "movedOn, movedOff, movedOver, movedNot, movedReturn, movedRemain"]
[h:varsFromStrProp("movedOn=0; movedOff=0; movedOver=0; movedNot=0; movedReturn=0; movedRemain=0")]
[h, foreach(event, eventTypeList): set(event, 1)]
[h:assert(macroNameList != "","First create at least one macro on the lib:EventMacro token with which this eventPad can be associated",0)]
[h,if(listContains(macroNameList, macroName)):currentMacro = listFind(macroNameList,macroName) ; currentMacro = 0]

<!-- ask for input -->
[h:abort(input(
	'junk|<html><b>Associated Macro</b><br>This macro will be linked to ALL currently selected tokens:<br><u>'+selectedTokens+'</u><br>Note that only the macros from the group: "Event Pad macros" on "Lib:EventMacros" are in the drop downlist </html>|-|LABEL|SPAN=TRUE',
	'macroName|'	+macroNameList+'|<html><span title="<html><b>Enter here the name of the macro that is used when this EventPad is triggered.</html>">Name of associated macro</html></span></html>|LIST|SELECT='+currentMacro,
	'junk|<html><b>Which events trigger this pad (all events are mutual exclusive)</b></html>|-|LABEL|SPAN=TRUE',
	'movedOn|'		+movedOn+		'|<html><span title="<html><b>When checked:</b> The macro associated with this pad,<br>will be triggered when a token <b>moves onto this pad</b>.</html>">Token moves onto pad</html></span></html>|CHECK',
	'movedOff|'		+movedOff+		'|<html><span title="<html><b>When checked:</b> The macro associated with this pad,<br>will be triggered when a token <b>leaves this pad.</html>">Token moves off pad</html></span></html>|CHECK',
	'movedOver|'	+movedOver+		'|<html><span title="<html><b>When checked:</b> The macro associated with this pad,<br>will be triggered when a token <b>moves over this pad.</html>">Token moves over pad</html></span></html>|CHECK',
	'movedNot|'		+movedNot+		'|<html><span title="<html><b>When checked:</b> The macro associated with this pad,<br>will be triggered when a token <b>on this pad is moved<br>from and back to the same postion on this pad<br>without using waypoints.</b><br>Note that zero move is turned off per default in the<br>settings, in which case this event will never occur.</html>">Token does zero move on pad</html></span></html>|CHECK',
	'movedReturn|'	+movedReturn+	'|<html><span title="<html><b>When checked:</b> The macro associated with this pad,<br>will be triggered when a token <b>moves off this pad<br>and back onto it, using waypoints.</html>">Token leaves and returns onto pad</html></span></html>|CHECK',
	'movedRemain|'	+movedRemain+	'|<html><span title="<html><b>When checked:</b> The macro associated with this pad,<br>will be triggered when a token <b>is moved but remains<br>on the pad the entire move.</html>">Token moves but remains on pad</html></span></html>|CHECK'
))]

[h:macroName = listGet(macroNameList, macroName)]
<!-- set choices for all selected tokens -->
[h,foreach(me, selectedTokens), CODE:{
	[switchToken(me)]
	[setProperty("w42.bot.macroName", macroName)]
	[eventTypeList = ""]
	[foreach(event, triggerTypeList), if(eval(event)): eventTypeList = listAppend(eventTypeList, event)]
	[setProperty("w42.bot.eventTypeList", eventTypeList)]
}]

[r, gm:"The Macro <u>"+macroName+"</u> is now linked to the following token(s)<u> "+selectedTokens+"</u>. This macro will be executed when one of the following events are triggered: <u>"+eventTypeList]

@@cos
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=0.95em ; sortBy=2 ; color=default ; playerEditable=false ; applyToSelected=false ; group=math ; tooltip= ; minWidth=21 ; 
<!-- developed by Aliasmask -->
[H: radians = arg(0)]
[H: cosine = 1]
[H: product = 1]
[H, for(i,2,21,2), code: {
   [H: product = product * -1 * i * (i-1)]
   [H: cosine = cosine + power(radians,i) / product]
}]
[H: macro.return = cosine ]

@@facingToCoord
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=0.95em ; sortBy=11 ; color=default ; playerEditable=false ; applyToSelected=false ; group=math ; tooltip= ; minWidth=90 ; 
<!-- 0:x1, 1:y1, 2:range, 3:angle -->
[h:macro.return = strformat(
	'{"x":%s,"y":%s}', 
	arg(0) + round(arg(2)*bot_cos(bot_toRadians(arg(3)+90)),0),
	arg(1) - round(arg(2)*bot_sin(bot_toRadians(arg(3)+90)),0)
)]

@@facingToCoordX
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=0.95em ; sortBy=12 ; color=default ; playerEditable=false ; applyToSelected=false ; group=math ; tooltip= ; minWidth=90 ; 
<!-- 0:x1, 1:range, 2:angle -->
[h:macro.return = arg(0) + round(arg(1)*bot_cos(bot_toRadians(arg(2)+90)),0)]

@@facingToCoordY
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=0.95em ; sortBy=13 ; color=default ; playerEditable=false ; applyToSelected=false ; group=math ; tooltip= ; minWidth=90 ; 
<!-- 0:y1, 1:range, 2:angle -->
[h:macro.return = arg(0) - round(arg(1)*bot_sin(bot_toRadians(arg(2)+90)),0)]

@@getTokenFacing
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy=22 ; color=teal ; playerEditable=false ; applyToSelected=false ; group=math ; tooltip= ; minWidth=90 ; 
[h: '<!-- ---------------------------------------- getTokenFacing----------------------------------- 
type 0 or default only changes the range from -180 - 180 to 0 - 360. Type 1 ALSO inverts the angle so CW is positive AND make sure that no facing == 270 (pointing down) instead of -90.
so:

0 (CCW)(usefull for tokens with the arrow, where unrotated points down=270):
 > = 0 ; ^ = 90 ; < = 180 ; V = 270(no facing) 
1 (CW)(useful for top down tokens (without the arrow. Unrotated then means: 0, 90 CW results in 90, etc.):
 > = 270 ; ^ = 180 ; < = 90 ; V = 0(no facing) 
2 (CW):
 > = 0 ; ^ = 270 ; < = 180 ; V = 90(no facing) 

-->']

[h,if(argCount()>0):	angle	= getTokenFacing(arg(0)) ; angle	= getTokenFacing(currentToken())]
[h,if(argCount()>1):	type	= arg(1) ; type	= 0]

[h,if(angle == ""):		angle	= -90]
[h,if(type == 1): 		angle	= angle + 90]
[h:angle	= if(angle <0, angle + 360, angle)]
[r,if(type && angle):	macro.return = 360-angle ; macro.return = angle]

@@pi
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=0.95em ; sortBy=1 ; color=default ; playerEditable=false ; applyToSelected=false ; group=math ; tooltip= ; minWidth=21 ; 
[H: macro.return = 3.14159265358979323846 ]

@@setTokenFacing
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy=21 ; color=teal ; playerEditable=false ; applyToSelected=false ; group=math ; tooltip= ; minWidth=90 ; 
[h: '<!-- ---------------------------------------- setTokenFacing----------------------------------- -->']

[h:angle	= arg(0)]
[h,if(argCount()>1):	me		= arg(1) ; me		= currentToken()]
[h,if(argCount()>2):	type	= arg(2) ; type		= 0]

[h:macro.return = setTokenFacing(if(type, 360-angle-90, angle), me)]

@@sin
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=0.95em ; sortBy=3 ; color=default ; playerEditable=false ; applyToSelected=false ; group=math ; tooltip= ; minWidth=21 ; 
<!-- developed by Aliasmask -->
[H: radians = arg(0)]
[H: sine = radians]
[H: product = 1]
[H, for(i,3,24,2), code: {
   [H: product = product * -1 * i * (i-1)]
   [H: sine = sine + power(radians,i) / product]
}]
[H: macro.return = sine]

@@tan
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=0.95em ; sortBy=4 ; color=default ; playerEditable=false ; applyToSelected=false ; group=math ; tooltip= ; minWidth=21 ; 
[H: macro.return = bot_sin(arg(0)) / bot_cos(arg(0))]

@@toRadians
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=0.95em ; sortBy=5 ; color=default ; playerEditable=false ; applyToSelected=false ; group=math ; tooltip= ; minWidth=57 ; 
<!-- developed by Aliasmask -->
[H: macro.return = arg(0) * (bot_pi() / 180)]

@@cpyDelMacros
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Rumbles Delete Macro Utility ; tooltip=<html> This macro allows you to select macros on the selected token. The selected macros you can copy or delete.<br> <br> In case of <b>copy</b>, they will be stored in a property on lib:EventMacros. When you select another token you can <br> click <i>Paste Macros</i>. This will open a similar frame where you can select the macros to paste on the selected<br> token.<br> In case of <b>delete</b> you have the option to <i>allow undo</i>. The selected macros will be deleted from the token<br> and if allow undo is turned on, they will be stored in a property on that token. So you can later choose to undo the<br> process. </html> ; minWidth=90 ; 
[h:'<!-- ------------------ cpyDelMacros ----------------------------------->']
<!-- 
<html>
This macro allows you to select macros on the selected token. The selected macros you can copy or delete.<br>
<br>
In case of <b>copy</b>, they will be stored in a property on lib:EventMacros. When you select another token you can <br>
click <i>Paste Macros</i>. This will open a similar frame where you can select the macros to paste on the selected<br>
token.<br>
In case of <b>delete</b> you have the option to <i>allow undo</i>. The selected macros will be deleted from the token<br>
and if allow undo is turned on, they will be stored in a property on that token. So you can later choose to undo the<br>
process.
</html>
 -->

<!-- General method to get macro groups and labels on a token. This version is to delete unwanted or unneeded macros -->
<!-- but it is possible to use this information for whatever purpose you might think of -->
<!-- original macro by Rumble, improved by Wolph42 (added copy option and 'all macros' options) -->

[ids	= getSelected()]
[assert(listCount(ids) == 1, "Make sure that (only) one token is selected", 0)]
[switchToken(ids)]

<!-- Get a list of all macros on a token -->
[h,if(getMacros() != ""): fullMacList	= getMacros(); assert(0, "There are no macros on the token <b>"+token.name+"</b>", 0)]
[h:fullMacList		= listSort(fullMacList,"N+")]
[h:fullMacList		= json.fromList(fullMacList))]
[h:macroList		= json.unique(fullMacList)]

<!-- Loop through the list of macros, and extract the GROUP property from the result of getMacroProps() -->
[h:groupArray		= ""]
[h,foreach(macro,macroList),CODE:{
	[indexes		= getMacroIndexes(macro)]
	[foreach(index,indexes): 
		groupArray	= if(
			getStrProp(getMacroProps(index),"group")	== "", 
			json.append(groupArray, "__no group name__"), 
			json.append(groupArray, getStrProp(getMacroProps(index), "group"))
		)
	]
}]

<!-- Since we need only the names of each unique group, use json.unique() to return a list of the unique entries in groupArray -->
[h:groupList		= listSort(json.toList(json.unique(groupArray)), "N+")]

[h:macrosInGroup	= "{}"]
[h,foreach(macroGroup, groupList),CODE:{
	[tmpObj		= ""]
	[foreach(macro,macroList),CODE:{
		[indexes	= getMacroIndexes(macro)]
		[foreach(index, indexes): tmpObj	= 
			if(
				if(	getStrProp(getMacroProps(index),"group") == "", 
					"__no group name__", 
					getStrProp(getMacroProps(index),"group")
				) == macroGroup,
				listAppend(tmpObj, macro), 
				tmpObj
			)
		]
	}]
	[macrosInGroup	= json.set(macrosInGroup, macroGroup, tmpObj)]
}]

[h:inputParams		= json.append("", 
						"initial|ALL MACROS||TAB",
						"deleteMacros|Copy Macros, Delete Macros|<html><b>Copy or Delete Selected Macros</b></html>|RADIO|SELECT=0",
						".|<html><b>Copy</b> will cache the selected macros to a property on lib:EventMacros.<br>After this is done you can select another token and paste the macros onto them.<br><b>Delete</b> will delete the selected macros from this token immediately.<br><br></html>||LABEL|SPAN=TRUE",
						"doUndo|1|<html><b>Allow Undo</b></html>|CHECK",
						".|<html><b>Allow undo</b> will store the macro on the property: <i>rumble.bot.deleteMacroUndo</i> on<br>the selected token. This will allow you to undo the deletion later on, but will also<br>increase token size<br><br></html>||LABEL|SPAN=TRUE",
						"deleteAllMacros|0|<html><b>Select ALL macros</b></html>|CHECK",
						".|<html><b>Select ALL macros from the following groups!</b></html>||LABEL|SPAN=TRUE"
)]

[h,foreach(macroGroup, groupList):
	inputParams		= json.append(inputParams, "groupDelete_"+roll.count+"|0|"+macroGroup+"|CHECK")
)]

[h,foreach(macroGroup, groupList),CODE:{	
	[macroLabels	= listSort(json.get(macrosInGroup, macroGroup), "N+")]
	[inputParams	= json.append(inputParams, "group_"+roll.count+"|"+macroGroup+"||TAB")]
	[inputParams	= json.append(inputParams, ".|<html><b>Select individual macros you wish to copy or delete.</b></html>||LABEL|SPAN=TRUE")]
	[foreach(macroLabel, macroLabels),CODE:	{
		[idx		= getMacroIndexes(macroLabel)]
		[foreach(index, idx): inputParams	= 
			if(
				if(
					getStrProp(getMacroProps(index),"group")=="", 
					"__no group name__", 
					getStrProp(getMacroProps(index),"group")
				) == macroGroup, 
				json.append(inputParams, "macro_"+index+"|0|<html>"+macroLabel+" "+if(getStrProp(getMacroProps(index),"tooltip")=="", "(no tooltip available)", "("+getStrProp(getMacroProps(index),"tooltip")+")")+"</html>|CHECK"), 
				inputParams
			)
		]
	}]
}]

<!-- Convert inputParams from a JSON string array to a string list, using ## as the list delimiter (required for this trick) -->
<!-- pass inputParams to the input() function to generate an input dialog with tabs for each macro group, and the macros listed -->
[h:abort(input(json.toList(inputParams, "##")))]

[h:deleteGroupList	= ""]
[h,foreach(macroGroup, groupList),CODE:{	
	[if(eval("groupDelete_"+roll.count)): deleteGroupList	= listAppend(deleteGroupList, macroGroup)]
}]

<!-- Finally, go through each macro on the token (again!) and, if its box is checked, delete it. -->
[h:backUpMacros		= "{}"]
[h,foreach(macro,macroList),CODE:{
	[macroIndexes	= getMacroIndexes(macro)]
	[foreach(index, macroIndexes),code:{
		[group		= getStrProp(getMacroProps(index),"group")]
		[group		= if(group == "", "__no group name__", group)]
		[checked	= eval("macro_"+index) + deleteAllMacros + if(listContains(deleteGroupList, group),1,0)] 
		[if(checked): backUpMacros	= json.set(backUpMacros, macro, getMacroProps(index, "json"))]
		[if(checked && deleteMacros): removeMacro(index)]
	 }]
}]

[r, if(deleteMacros), CODE:{
	[r,if(doUndo), CODE:{
		[h:setProperty("rumble.bot.deleteMacroUndo", backUpMacros)]
		Backup of macros stored on token. <br>
	};{}]
	Macro(s) removed.
};{
	[h:setLibProperty("cpDel.backUpMacros", backUpMacros, "lib:EventMacros")]
	[h:setLibProperty("cpDel.groupList", groupList, "lib:EventMacros")]
	[h:setLibProperty("cpDel.macrosInGroup", macrosInGroup, "lib:EventMacros")]
	Macro(s) copied.
}]

@@pasteMacros
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Rumbles Delete Macro Utility ; tooltip=<html> This button you can use to paste macro on the selected token. Before you do this, you first need to run the <br> Copy/Del Macros button on another token. </html> ; minWidth=90 ; 
[h:'<!-- ------------------ pasteMacros ----------------------------------->']
[h:debug = 0]

<!-- 
<html>
This button you can use to paste macro on the selected token. Before you do this, you first need to run the <br>
Copy/Del Macros button on another token.
</html>
 -->

[ids	= getSelected()]
[assert(listCount(ids) == 1, "Make sure that (only) one token is selected", 0)]
[switchToken(ids)]

[h:backUpMacros		= getLibProperty("cpDel.backUpMacros",	"lib:EventMacros")]
[h:groupList		= getLibProperty("cpDel.groupList",		"lib:EventMacros")]
[h:macrosInGroup	= getLibProperty("cpDel.macrosInGroup",	"lib:EventMacros")]

[h:assert(json.type(backUpMacros) == "OBJECT", "No back-up macros were ever stored on this token", 0)]
[h:assert(json.length(backUpMacros) > 0, "No macros left to undelete", 0)]

[h:macroList		= json.fields(backUpMacros)]

[h:inputParams		= json.append("", 
						"initial|ALL MACROS||TAB",
						"deleteAllMacros|0|<html><b>Select ALL macros</b></html>|CHECK",
						".|<html><b>Select ALL macros from the following groups!</b></html>||LABEL|SPAN=TRUE"
)]

[h,foreach(macroGroup, groupList):
	inputParams		= json.append(inputParams, "groupDelete_"+roll.count+"|0|"+macroGroup+"|CHECK")
)]

[h:index			= 0]
[h,foreach(macroGroup, groupList), CODE:{	
	[macroLabels	= listSort(json.get(macrosInGroup, macroGroup), "N+")]
	[inputParams	= json.append(inputParams, "group_"+roll.count+"|"+macroGroup+"||TAB")]
	[inputParams	= json.append(inputParams, ".|<html><b>Select individual macros you wish to paste.</b></html>||LABEL|SPAN=TRUE")]
	[if(debug): bot_debugInfo("groupList, macroGroup, macroLabels, index, inputParams", 0,0,0,0,0)]
	[foreach(macroLabel, macroLabels),CODE:	{
		[macroData	= json.get(backUpMacros, macroLabel)]
		[toolTip	= json.get(macroData, "tooltip")]
		[if(toolTip == ""): toolTip =="(no tooltip available)"]
		[inputParams = json.append(inputParams, "macro_"+index+"|0|<html>"+macroLabel+" "+toolTip+"</html>|CHECK")]
		[index	= index + 1]
		<!-- bot_debugInfo(vars [, oneLine, showTok, pause, macroName, macroLocation]) -->
		[if(debug): bot_debugInfo("groupList, macroGroup, macroLabels, macroData, toolTip, index, macroLabel, inputParams", 0,0,0,0,0)]
	}]
}]

<!-- Convert inputParams from a JSON string array to a string list, using ## as the list delimiter (required for this trick) -->
<!-- pass inputParams to the input() function to generate an input dialog with tabs for each macro group, and the macros listed -->
[h:abort(input(json.toList(inputParams, "##")))]

[h:deleteGroupList	= ""]
[h,foreach(macroGroup, groupList), CODE:{	
	[if(eval("groupDelete_"+roll.count)): deleteGroupList	= listAppend(deleteGroupList, macroGroup)]
}]

[if(debug): pause("deleteGroupList")]

<!-- Finally, go through each macro on the token (again!) and, if its box is checked, delete it. -->
[h:index			= 0]
[h,foreach(macroGroup, groupList), CODE:{	
	[macroLabels	= listSort(json.get(macrosInGroup, macroGroup), "N+")]
	[foreach(macroLabel, macroLabels),CODE:	{
		[macroData	= json.get(backUpMacros, macroLabel)]
		[group		= json.get(macroData, "group")]
		[group		= if(group == "", "__no group name__", group)]
		[checked	= eval("macro_"+index) + deleteAllMacros + if(listContains(deleteGroupList, group),1,0)] 
		[if(checked): pasteProps = json.get(backUpMacros, macroLabel)]
		[if(checked): createMacro(pasteProps)]
		[index	= index + 1]
		[if(debug): bot_debugInfo("groupList, macroGroup, macroLabels, macroLabel, group, deleteGroupList, checked, macroData", 0,0,1,0,0)]
	}]
}]

macros have been copied.

@@undoDelMacros
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Rumbles Delete Macro Utility ; tooltip=<html> If you deleted macros on the selected token using the Copy/Del Macros function<br> AND you had <i>allow undo</i> turned on, then you can use this function to undo<br> that process </html> ; minWidth=90 ; 
[h:'<!-- ------------------ undoDelMacros ----------------------------------->']
<!--
<html>
If you deleted macros on the selected token using the Copy/Del Macros function<br>
AND you had <i>allow undo</i> turned on, then you can use this function to undo<br>
that process
</html>
-->

[ids	= getSelected()]
[assert(listCount(ids) == 1, "Make sure that (only) one token is selected", 0)]
[switchToken(ids)]

[h:copiedMacros		= getLibProperty("macroCopies", "lib:EventMacros")]
[h:assert(json.type(copiedMacros) == "OBJECT", "No back-up macros were ever stored on this token", 0)]
[h:assert(json.length(copiedMacros) > 0, "No macros left to undelete", 0)]

[h:deletedMacroList	= json.fields(copiedMacros)]
[h:abort(input("macToRestore|"+deletedMacroList+"|Choose Macro to Paste|LIST|SELECT=0 VALUE=STRING"))]
[h:restoreProps		= json.get(copiedMacros, macToRestore)]
[h:copiedMacros		= json.remove(copiedMacros, macToRestore)]
[h:createMacro(restoreProps)]

<i>[r:macToRestore]</i> macro restored.

@@createSplices
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=teal ; playerEditable=true ; applyToSelected=true ; group=Util Documented ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------- createSplices ------------------------------------ -->']
<!-- new scope no output -->
<!-- this function splits large (>1000) LISTS OR ARRAYS into splices so they can be handled in loops without bugging out because of the 1000 loop limitation -->

[h: theList = arg(0)]
<!-- if a list if fed, then turn it into an array -->
[h, if(json.type(theList) == "UNKNOWN"): theList = json.fromList(theList)]

[h: maxCount			= json.length(theList)]
[h: splices				= ""]
[h: from				= 0]
[h: to					= from + 999]

<!-- in case the list has length 0 -->
[h, if(maxCount < 1):	to = -1]

[h, while(to >= 0), code: {
	[if(to >= maxCount): to = -1]
	[thisSplice	= json.get(theList, from, to)]
	[splices	= json.append(splices, thisSplice)]
	[from		= from + 1000]
	[if(to != -1):to = from + 999]
}]

[h:macro.return = splices]

@@debugInfo
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=21 ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Util Documented ; tooltip=This macro executes the macro on ALL clients. Feed it macro@lib:token, args (json array), players, output to ; minWidth=90 ; 
[h:'<!-- ----------------------------- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), MacroName, macroLocation)----------------------- -->']
<!-- NO NEW SCOPE !! -->
[					 w42_debug_vars		= arg(0)]
[if(argCount() > 1): w42.debug.oneLine	= arg(1) ; w42.debug.oneLine	= 1]
[if(argCount() > 2): w42.debug.showTok	= arg(2) ; w42.debug.showTok	= 1]
[if(argCount() > 3): w42.debug.pause	= arg(3) ; w42.debug.pause		= 0]
[if(argCount() > 4): w42.debug.macro	= arg(4) ; w42.debug.macro		= ""]
[if(argCount() > 5): w42.debug.location	= arg(5) ; w42.debug.location	= ""]

[if(currentToken() != "" && w42.debug.showTok), CODE:{
	[w42.debug.currTok		= getName(currentToken())]
	[token(w42.debug.currTok): w42.debug.currTok.img = getTokenImage()]
};{
	[if(w42.debug.showTok), CODE:{
		[w42.debug.currTok		= "<i><font color='gray'>none</font></i>"]
		[w42.debug.currTok.img	= ""]
	};{
		[w42.debug.currTok		= ""]
	}]
}]

[if(hasImpersonated() && w42.debug.showTok), CODE:{
	[w42.debug.impTok	= getImpersonatedName()]
	[token(w42.debug.impTok): w42.debug.impTok.img = getTokenImage()]
};{
	[if(w42.debug.showTok), CODE:{
		[w42.debug.impTok		= "<i><font color='gray'>none</font></i>"]
		[w42.debug.impTok.img	= ""]
	};{
		[w42.debug.impTok		= ""]
	}]
}]

[w42.debug.textOut	="<table border='1'>" +
	if(w42.debug.macro		!= "", "<tr><td><b>Running from:		</b></td>	<td colspan='2'>%{w42.debug.macro}@%{w42.debug.location}</td></tr>", "") + 
	if(w42.debug.currTok	!= "", "<tr><td><b>Current Token:		</b></td>	<td><img height='15' width='15' src='%{w42.debug.currTok.img}'></img></td>	<td>%{w42.debug.currTok}</td></tr>", "") + 
	if(w42.debug.impTok		!= "", "<tr><td><b>Impersonated Token:	</b></td>	<td><img height='15' width='15' src='%{w42.debug.impTok.img}'></img></td>	<td>%{w42.debug.impTok}</td></tr>", "") + 
	"</tr></table>"
]

[if(w42.debug.oneLine), CODE:{
	[w42.debug.textOut	= w42.debug.textOut + "<table border='1'><tr>"]
	[foreach(w42_debug_var, w42_debug_vars): w42.debug.textOut = w42.debug.textOut + "<td><b>"+w42_debug_var+":</b></td><td>%{"+w42_debug_var+"}</td>")]
	[w42.debug.textOut	= w42.debug.textOut + "</tr></table>"]
};{
	[w42.debug.textOut	= w42.debug.textOut + "<table border='1'>"]
	[foreach(w42_debug_var, w42_debug_vars): w42.debug.textOut = w42.debug.textOut + "<tr><td><b>"+w42_debug_var+":</b></td><td>%{"+w42_debug_var+"}</td></tr>")]
	[w42.debug.textOut	= w42.debug.textOut + "</table>"]
}]

[broadcast(strformat(w42.debug.textOut))]

[if(w42.debug.pause), CODE:{
	[frame("Debug Info", "width=400; height=600;"):{
		[r:strformat(w42.debug.textOut)]
	}]
	[pause()]
};{}]
[h:'<!-- ----------------------------- /DEBUG INFO ----------------------------------------------------- -->']

@@execAllPlayers
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=21 ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Util Documented ; tooltip=This macro executes the macro on ALL clients. Feed it macro@lib:token, args (json array), players, output to ; minWidth=90 ; 
[h:'<!-- ------------------- execAllPlayers (macro name, arguments, players, output to) ----------------------------------------------------- -->']
<!-- This macro executes the macro on ALL SELECTED clients. Feed it macro@lib:token, args (json array) -->
<!-- And optional third argument is allowed where you give a list of clients where this macro should be executed -->
[h,if(argCount() > 2), CODE:{
	[userList = arg(2)]
	[if(json.type(userList)=="ARRAY"):userList = json.toList(userList)]
};{
	[userList = getAllPlayerNames()]
}]
[h,if(argCount() > 3), CODE:{
	[outputList = arg(3)]
	[if(json.type(outputList)=="ARRAY"):outputList = json.toList(outputList)]
};{
	[outputList = "none"]
}]

[h: self	= getPlayerName()]
[h: others	= listDelete(userList, listFind(userList, self))]

[h, if(others != ""):broadcast(macroLink("<color='red'>", arg(0), outputList, arg(1), ""), others)]
[h,if(listContains(userList, self)), CODE:{
	[macro(arg(0)):arg(1)]
}; {}]

@@findDuplicates
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=21 ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Util Documented ; tooltip=This macro executes the macro on ALL clients. Feed it macro@lib:token, args (json array), players, output to ; minWidth=90 ; 
[h:'<!-- ------------------------------------- bot_findDuplicates() ------------------------------ -->']
[h:'<!-- THREE 3 CODE LEVELS -->']

[h:'<!-- get all tokens from all layers on map -->']
[h:	allToks			= json.sort(getTokenNames("json",json.set("{}", "layer", json.append("", "TOKEN","HIDDEN","OBJECT","BACKGROUND"))),"N+")]
[h:'<!-- check if any duplicates at all -->']
[h:hasDuplicates	= if(json.equals(allToks,json.sort(json.unique(allToks))),0,1)]
[h:duplicates	= ""]

[h, if(hasDuplicates), CODE: {
	[lastTok	= ""]
	
	[allSplices	= bot_createSplices(allToks)]
	
	[foreach(tokList,allSplices), CODE: {
		[foreach(tok,tokList), CODE: {
			[if(lastTok == tok): duplicates = listAppend(duplicates,tok)]
			[lastTok = tok]
		''
		}]
	''
	}]
	[output = strformat("Found duplicates: %{duplicates}")]
''
};{
	[output = strformat("No duplicate token names")]
''
}]

[h:macro.return = duplicates]
[h:broadcast(output)]

@@getGridSize
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=16 ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Util Documented ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------- getGridSize ------------------------------------------------>']
[h:macro.return = json.get(json.get(getInfo("map"),"grid"),"size")]

@@getNewImage
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy=20b ; color=default ; playerEditable=false ; applyToSelected=false ; group=Util Documented ; tooltip= ; minWidth=90 ; 
[token(arg(1)): macro.return = getTokenImage(arg(0))]

@@getPath
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=teal ; playerEditable=false ; applyToSelected=true ; group=Util Documented ; tooltip= ; minWidth=90 ; 
[h:'<!-- ------------------- GETPATH (pathType (0 dont /1 do /2 do + no step removal /3 remove step only), Distance in pixels (1/0), Token(id)) ----------------------------------------------------- -->']
[h:'<!-- This function returns ALL points where the direction of a token path changed. For a gridless token these are the way points, for a grid token then also points will be added for non 45 degree angle diagonal movement. This function can also be used to show the entire path including the facing direction  -->']

[h,if(argCount() > 2): me = arg(2); me	= getSelected()]
[h:switchToken(me)]

[h,if(argCount() > 1): units = arg(1); units = 1]
[h:switchToken(me)]

[h,if(argCount() > 0): pathType = arg(0); pathType	= 0]
[h,if(pathType), CODE:{
	[pathFeet		= if(isPC(), "blue feet", "red feet")]
	[directionLst	= "0X0Y,0X1Y,0X-1Y,1X0Y,-1X0Y,1X-1Y,-1X1Y,-1X-1Y,1X1Y"]
	[facingLst		= "none, -90,90,0,180,45,-135,135,-45"]
	[doLastStep		= 0]
	[baseMapName	= getLibProperty('baseMapName','lib:EventMacros')]

};{
	[doLastStep		= 1]
}]

[h,if(argCount() > 3): path = arg(3); path = getLastPath(units)]

[h, if(pathType == 3): path = "[]"]
[h:assert(!json.isEmpty(path) || pathType==3, "Token has not last path",0)]

[h,if(units): gs = bot_getGridSize() ; gs = 1]

[h,if(json.length(path)), CODE:{
	['<!-- first step -->']
	[firstStep	= json.get(path, 0)]
	[path			= json.remove(path, 0)]
	[x			= json.get(firstStep, "x")]
	[y			= json.get(firstStep, "y")]
	[direction	= ""]
	[wp			= ""]
	[point		= "{}"]
};{}]

[h,foreach(step, path), CODE:{
	[nx			= json.get(step, "x")]
	[ny			= json.get(step, "y")]
	[ndirection	= strformat("%sX%sY", (nx-x)/gs, (ny-y)/gs)]
	
	<!-- need to distinguish between the 8 possible paths +/-(hor, vert, bDiag, fDiag)
		If the path is changed THEN the last coord BEFORE the path is changed needs to be saved and the path needs to be reset. 
	-->
		
	[if(pathType), CODE:{
		<!-- add facing to the json object -->
		[ndirection	= strformat("%sX%sY", (nx-x)/gs, (ny-y)/gs)]
		[ndir		= listFind(directionLst, ndirection)]
		[if(ndir > 0): angle = listGet(facingLst, ndir) ; broadcast("unknown or no move: "+ndirection)]
		[point		= json.set(point, "facing", angle)]
	};{}]
	
	[if (direction != ndirection || pathType), CODE:{
		<!-- add point to the step array EITHER always (if pathType) of when the direction changes -->
		[point	= json.set(point, "x", x, "y", y)]
		[wp		= json.append(wp, point)]
	};{}] 

	[x			= nx]
	[y			= ny]
	[direction	= ndirection]
}]

[h, if(json.length(path) > 0 && doLastStep), CODE:{
	<!-- add last step as waypoint -->
	[lastStep	= json.get(path, -1,-1)]
	[nx			= json.get(lastStep, "x")]
	[ny			= json.get(lastStep, "y")]
	[ndirection	= strformat("%sX%sY", (nx-x)/gs, (ny-y)/gs)]

	[if(pathType), CODE:{
		[ndirection	= strformat("%sX%sY", (nx-x)/gs, (ny-y)/gs)]
		[ndir		= listFind(directionLst, ndirection)]
		[if(ndir > 0): angle = listGet(facingLst, ndir) ; broadcast("unknown or no move: "+ndirection)]
		[point		= json.set(point, "facing", angle)]
	};{}]
	
	[point	= json.set(point, "x", x, "y", y)]
	[wp		= json.append(wp, point)]
};{}]

[h, if(pathType), CODE:{
	<!-- remove the old steps and copy a set of feet on each step -->

	[if(pathType != 2), CODE:{
		<!-- first remove the old ones -->
		[currentFeet = getTokens(",", json.set("{}", "layer", "OBJECT", "setStates", "pathFeet"))]
		<!-- make sure that you do not delete the originals -->
		[if(listFind(currentFeet, "red feet")!=-1):		currentFeet = listDelete(currentFeet, listFind(currentFeet, "red feet")]
		[if(listFind(currentFeet, "blue feet")!=-1):	currentFeet = listDelete(currentFeet, listFind(currentFeet, "blue feet")]
		[foreach(feet, currentFeet): removeToken(feet)]
	};{}]
	
	[if(pathType != 3), CODE:{
		<!-- then copy the new ones-->
		[foreach(p, wp,"<br>"): copyToken(pathFeet, 1, baseMapName, json.set(p, "useDistance", units, "layer", "OBJECT", "name", "w42.bot.feet"))]
	};{}]
	[macro.return	= ""]
};{
	<!-- return all the points where the direction changed. -->
	[macro.return	= wp]
}]

@@getTokensPath
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=teal ; playerEditable=false ; applyToSelected=true ; group=Util Documented ; tooltip= ; minWidth=90 ; 
[h:'<!-- ------------------- GETPATH (showPath (0 dont /1 do /2 do + no step removal /3 remove step only), Distance in pixels (1/0), Token(id)) ----------------------------------------------------- -->']
[h:'<!-- This function returns ALL points where the direction of a token path changed. For a gridless token these are the way points, for a grid token then also points will be added for non 45 degree angle diagonal movement. This function can also be used to show the entire path including the facing direction  -->']

[h,if(argCount() > 2): me = arg(2); me	= getSelected()]
[h:switchToken(me)]

[h,if(argCount() > 1): units = arg(1); units = 1]
[h:switchToken(me)]

[h,if(argCount() > 0): showPath = arg(0); showPath	= 0]
[h,if(showPath), CODE:{
	[pathFeet		= if(isPC(), "blue feet", "red feet")]
	[directionLst	= "0X0Y,0X1Y,0X-1Y,1X0Y,-1X0Y,1X-1Y,-1X1Y,-1X-1Y,1X1Y"]
	[facingLst		= "none, -90,90,0,180,45,-135,135,-45"]
	[doLastStep		= 0]
	[baseMapName	= getLibProperty('baseMapName','lib:EventMacros')]

};{
	[doLastStep		= 1]
}]

[h,if(argCount() > 3): path = arg(3); path = getLastPath(units)]

[h, if(showPath == 3): path = "[]"]
[h:assert(!json.isEmpty(path) || showPath==3, "Token has not last path",0)]

[h,if(units): gs = bot_getGridSize() ; gs = 1]

[h,if(json.length(path)), CODE:{
	['<!-- first step -->']
	[firstStep	= json.get(path, 0)]
	[path			= json.remove(path, 0)]
	[x			= json.get(firstStep, "x")]
	[y			= json.get(firstStep, "y")]
	[direction	= ""]
	[wp			= ""]
	[point		= "{}"]
};{}]

[h,foreach(step, path), CODE:{
	[nx			= json.get(step, "x")]
	[ny			= json.get(step, "y")]
	[ndirection	= strformat("%sX%sY", (nx-x)/gs, (ny-y)/gs)]
	
	<!-- need to distinguish between the 8 possible paths +/-(hor, vert, bDiag, fDiag)
		If the path is changed THEN the last coord BEFORE the path is changed needs to be saved and the path needs to be reset. 
	-->
		
	[if(showPath), CODE:{
		<!-- add facing to the json object -->
		[ndirection	= strformat("%sX%sY", (nx-x)/gs, (ny-y)/gs)]
		[ndir		= listFind(directionLst, ndirection)]
		[if(ndir > 0): angle = listGet(facingLst, ndir) ; broadcast("unknown or no move: "+ndirection)]
		[point		= json.set(point, "facing", angle)]
	};{}]
	
	[if (direction != ndirection || showPath), CODE:{
		<!-- add point to the step array EITHER always (if showPath) of when the direction changes -->
		[point	= json.set(point, "x", x, "y", y)]
		[wp		= json.append(wp, point)]
	};{}] 

	[x			= nx]
	[y			= ny]
	[direction	= ndirection]
}]

[h, if(json.length(path) > 0 && doLastStep), CODE:{
	<!-- add last step as waypoint -->
	[lastStep	= json.get(path, -1,-1)]
	[nx			= json.get(lastStep, "x")]
	[ny			= json.get(lastStep, "y")]
	[ndirection	= strformat("%sX%sY", (nx-x)/gs, (ny-y)/gs)]

	[if(showPath), CODE:{
		[ndirection	= strformat("%sX%sY", (nx-x)/gs, (ny-y)/gs)]
		[ndir		= listFind(directionLst, ndirection)]
		[if(ndir > 0): angle = listGet(facingLst, ndir) ; broadcast("unknown or no move: "+ndirection)]
		[point		= json.set(point, "facing", angle)]
	};{}]
	
	[point	= json.set(point, "x", x, "y", y)]
	[wp		= json.append(wp, point)]
};{}]

[h, if(showPath), CODE:{
	<!-- remove the old steps and copy a set of feet on each step -->

	[if(showPath != 2), CODE:{
		<!-- first remove the old ones -->
		[currentFeet = getTokens(",", json.set("{}", "layer", "OBJECT", "setStates", "pathFeet"))]
		<!-- make sure that you do not delete the originals -->
		[if(listFind(currentFeet, "red feet")!=-1):		currentFeet = listDelete(currentFeet, listFind(currentFeet, "red feet")]
		[if(listFind(currentFeet, "blue feet")!=-1):	currentFeet = listDelete(currentFeet, listFind(currentFeet, "blue feet")]
		[foreach(feet, currentFeet): removeToken(feet)]
	};{}]
	
	[if(showPath != 3), CODE:{
		<!-- then copy the new ones-->
		[foreach(p, wp,"<br>"): copyToken(pathFeet, 1, baseMapName, json.set(p, "useDistance", units, "layer", "OBJECT", "name", "w42.bot.feet"))]
	};{}]
	[macro.return	= ""]
};{
	<!-- return all the points where the direction changed. -->
	[macro.return	= wp]
}]

@@gotoMap
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=22 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Util Documented ; tooltip=This macro executes the macro on ALL clients. Feed it macro@lib:token, args (json array) ; minWidth=90 ; 
<!-- This macro changes the map -->
[h:setCurrentMap(arg(0))]
[h,if(findToken("centreOnMePad") != ""): goto(getTokenX(0,"centreOnMePad"),getTokenY(0,"centreOnMePad"))]

@@gotoToken
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy=20b ; color=default ; playerEditable=false ; applyToSelected=false ; group=Util Documented ; tooltip= ; minWidth=90 ; 
[h:'<!-- ------------------------------- gotoToken ---------------------------------------- -->']
[gotoMap	= arg(0)]
[tok		= arg(1)]
[copyTok	= arg(2)]
[X			= arg(3)]
[Y			= arg(4)]

[currentMap	= getCurrentMapName()]

<!-- 1=copy ; 2=move ; 3=select -->

<!-- 2=move from another/same map-->
[if(copyTok == 0), CODE:{
	[abort(input(
		"junk|<html>You have selected <b>"+tok+"</b>. What do you want to do</html>|-|LABEL|SPAN=TRUE",
		"copyTok|<html>Nothing, COPY "+tok+" to current location, MOVE "+tok+" to current location, "+if(gotoMap != currentMap, "go to "+gotoMap+" and","")+" SELECT "+tok+", DELETE "+tok+" (confirm), DELETE "+tok+" (no confirm)|Pick one|RADIO|"
	))]
}; {}]

<!-- 1=copy -->
[if(copyTok == 1):	copyToken(tok, 1, gotoMap, json.set("{}", "useDistance", 0, "x", X, "y", Y))]

<!-- 2=move from another/same map-->
[if(copyTok == 2), CODE:{
	[if(gotoMap != currentMap):	moveTokenFromMap(tok, gotoMap, X, Y, 100) ; moveToken(X,Y,0,tok)]
}; {}]

<!-- 3=select -->
[if(copyTok == 3), CODE:{
	[if(gotoMap != currentMap):setCurrentMap(gotoMap)]
	[selectTokens(tok)]
	[goto(tok)]
	[layer	= getLayer(tok)]
	[if(layer != "TOKEN"): broadcast(strformat("%{tok} is on the %{layer} layer"))]
}; {}]

<!-- 4=delete with confirmation -->
[if(copyTok == 4), CODE:{
	[Warning = "Press OK to delete: <b>"+tok+"</b>, else press cancel"]
	[pause("Warning")]
}; {}]

<!-- 5=delete withOUT confirmation -->
[if(copyTok == 4 || copyTok == 5), CODE:{
	[if(gotoMap != currentMap):setCurrentMap(gotoMap)]
	[removeToken(tok)]
	[if(gotoMap != currentMap):setCurrentMap(currentMap)]
	[broadCast(tok+" has been deleted from map: "+gotoMap)]
}; {}]

@@ids2Names
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Util Documented ; tooltip= ; minWidth=90 ; 
[h:'<!-- ids2Names -->']
[h:tokNames = ""]
[h,foreach(tok,arg(0)): tokNames = listAppend(tokNames, getName(tok))]
[r:tokNames]

@@ids2NamesArray
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=orange ; playerEditable=false ; applyToSelected=false ; group=Util Documented ; tooltip= ; minWidth=90 ; 
[h:'<!-- ids2NamesArray -->']
[h:array	= replace(arg(0), '(")([^,]+)(")', '"[r:getName(&#39;\$2&#39;)]"')]
[h:macro.return = json.evaluate(replace(array, "&#39;", "'"))]

@@inStr
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=3 ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Util Documented ; tooltip= ; minWidth=90 ; 
[H: '<!-- inStr -->']
[H: '<!-- 0=Text, 1=string to look for in Text -->']
[r, if(arg(1)==""):""; getFindCount(strfind(arg(0), arg(1)))]

@@pause
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=2 ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Util Documented ; tooltip= ; minWidth=90 ; 
[h:'<!-------------------------------------------------------------- PAUSE------------------------------------------------------------------------------->']
[ toolkit.DebugVariableCount = argCount() ]
[ toolkit.DebugVariableArray = macro.args ]
[ toolkit.DebugInputParameter = ".|<html>" +
    "<table cellspacing='2' cellpadding='0' style='background-color:#595751'>" +
    "<tr><td>" +
    "<table width='300px' cellspacing='0' cellpadding='2' style='background-color:#FAF9F5; '>" +
    "%{toolkit.DebugVariableRows}</table></td></tr></html>" +
    "|Debugger|LABEL|SPAN=TRUE"
]
[ toolkit.DebugVariableRow = "<tr %{toolkit.DebugVariableRowStyle}><td>" +
    "<b>%{toolkit.DebugVariableName}</b></td><td>%{toolkit.DebugVariableContent}" +
    "</td></tr>"
]
[ toolkit.DebugVariableRows = "<tr style='background-color:#E0DDD5; font-size:1.1em; '><td><b>Variable</b></td><td><b>Value</b></td></tr>" ]
[ count( toolkit.DebugVariableCount ), code:
{
    [ toolkit.DebugVariableRowStyle = "" ]
    [ toolkit.DebugVariableName = json.get( toolkit.DebugVariableArray, roll.count ) ]
    [ toolkit.DebugVariableContent = eval( toolkit.DebugVariableName ) ]    [H: '<!-- this may not be compatible with a custom eval function (which would overwrite macro.args) -->']
    [ if( floor( roll.count/2 ) == roll.count/2 ), code:
    {
        [ toolkit.DebugVariableRowStyle = "style='background-color:#EDECE8; '" ]
    } ]
    [ toolkit.DebugVariableRows = toolkit.DebugVariableRows +
        strformat( toolkit.DebugVariableRow )
    ]
} ]
[ if( toolkit.DebugVariableCount == 0 ), code:
{
    [ toolkit.DebugVariableRows = "<tr><td style='font-size: 1.4em' align='center'><b>Pause</b></td></tr>" ]
} ]

[ toolkit.DebugBreak = input( strformat( toolkit.DebugInputParameter ) )]
[ abort( toolkit.DebugBreak ) ] 
[h:'<!-------------------------------------------------------------- END PAUSE------------------------------------------------------------------------------->']

@@ppc2GridCoord
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=18 ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Util Documented ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------- bot_ppc2GridCoord(coord [,gs]) ------------------------------------------------>']
<!-- this function returns a pixel per cell coordinate to a grid cell coordinate  -->
[if(argCount() > 1): gs = arg(1) ; gs	= bot_getGridSize()]
[h:macro.return = round(arg(0)/gs)]

@@round2Grid
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=18 ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Util Documented ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------- round2Grid(coord [,gs]) ------------------------------------------------>']
<!-- this function returns a coordinate rounded to multiple of grid size  -->
[if(argCount() > 1): gs = arg(1) ; gs	= bot_getGridSize()]
[h:macro.return = gs*round((arg(0)/gs))]

@@seekToken
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy=20a ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Util Documented ; tooltip=<html>This macro searches ALL maps and ALL tokens and<br>return those tokens of which the first part of <br>their name matches with the entered search string<br><b>Pop-ups on first use ; minWidth=90 ; 
[h:'<!------------------------------------- seekToken ------------------------------------------------>']
[h:'<!-- <html>This macro searches ALL maps and ALL tokens and<br>return those tokens of which the first part of <br>their name matches with the entered search string<br><b>Pop-ups on first use -->']

[h:'<!-- retrieve the last saved settings from seek token macro findTok, showImage, showName, showLayer, copyTok, libTok, doTokenLayer, doObjectLayer, doHiddenLayer, doBackgroundLayer -->']
[h:lastSettings	= getLibProperty("seekTokensLastSettings", "Lib:EventMacros")]
[h,if(lastSettings == ""): lastSettings = "findTok=0 ; showImage=0 ; showName=1 ; showLayer=0 ; copyTok=0 ; libTok=0 ; doTokenLayer=1 ; doObjectLayer=1 ; doHiddenLayer=1 ; doBackgroundLayer=1 ; "]
[h:varsFromStrProp(lastSettings)]

[h:'<!-- option to give parameters, when returnArg is 1 NO input is requested and NO form will pop-up -->']

[h,if(argCount()>0), CODE:{
	[					 returnArg		= arg(0)]
	[h,if(argCount()>1): findTok		= arg(1) ; findTok		= ""]
	[h,if(argCount()>2): chosenLayers	= arg(2) ; chosenLayers = '["TOKEN", "HIDDEN", "OBJECT", "BACKGROUND"]']
	[if(string(chosenLayers) == ""): chosenLayers = '["TOKEN", "HIDDEN", "OBJECT", "BACKGROUND"]']
	[h,if(argCount()>3): mapList		= arg(3) ; mapList		= getCurrentMapName()]
	[h,if(argCount()>4): libTok			= arg(4) ; libTok		= 0]

	[numMaps	= listCount(mapList)]
	[if(numMaps > 1): returnValue= "{}" ; returnValue= "" ]
	[showName	= 1]
	[showImage	= 0]
	[showLayer	= 0]
}; {
	[mapList	= ""]
	[returnArg	= 0]
}]

[h, if(mapList == ""), CODE:{
	[h:mapList		= getAllMapNames()]
	<!-- put BASE map first -->
	[h:baseMapName	= getLibProperty("baseMapName","lib:EventMacros")]
	[h:mapList		= listAppend(baseMapName, listDelete(mapList, listFind(mapList, baseMapName)))]
}; {}]

[h:oldMap		= getCurrentMapName()]
[h:resultTxt	= "<hml><table border=1><tr><td><b>MAP</b></td><td><b>FOUND</b></td></tr><tr>"]
[h:me = getSelected()]
[h, if(listCount(me) == 1), CODE:{
	[switchToken(me)]
	[h: X = getTokenX(0)]
	[h: Y = getTokenY(0)]
	[H: PrimePC	= getName() ]
}; {
	[h: X = 0]
	[h: Y = 0]
	[H: PrimePC	= ""]
}]

[h:inputStr		= "[]"]
[h:inputStr		= json.append(inputStr, "junk|<html><b>Find tokens which names have the following search string</html>|<html>The token will show up in the results when the<br>search string matches ANY part of the token name|LABEL|SPAN=TRUE")]
[h:inputStr		= json.append(inputStr, "findTok|"+findTok+"|Enter search string")]
[h:inputStr		= json.append(inputStr, "junk|<html><b>In search results</html>|<html>The search results will be shown in a frame.<br>When you check all three boxes the result will<br>look like <u>Picture</u> <u>Token name</u>(<u>token layer</u>)|LABEL|SPAN=TRUE")]
[h:inputStr		= json.append(inputStr, "showImage|"+showImage+"|Show token image|CHECK")]
[h:inputStr		= json.append(inputStr, "showName|"+showName+"|Show token name|CHECK")]
[h:inputStr		= json.append(inputStr, "showLayer|"+showLayer+"|Show layer|CHECK")]

[h:inputStr		= json.append(inputStr, "junk|<html><b>LIB:Tokens (search string is ignored for these)</html>|<html>Lib:Tokens can only be found through a special macro<br>and are thus dealt with seperately. An additional <br>feature for lib:Tokens is to find the duplicates only.<br>For the find duplicates note the following: <br>- Only ONE duplicate is shown. This to prevent you <br>from accidentily deleting both. <br>- When you delete one token the results are NOT <br>UPDATED. So on the frame it appears the token is still<br>there even though its not. If you run this macro again<br>you will see the update. <br>|LABEL|SPAN=TRUE")]
[h:inputStr		= json.append(inputStr, "libTok|No: only 'normal' tokens, Yes: BOTH normal and lib:Tokens, Yes: ONLY lib:Tokens, Yes: ONLY DUPLICATE lib:Tokens|Find lib:Tokens|RADIO|SELECT="+libTok)]

[h:inputStr		= json.append(inputStr, "junk|<html><b>Check layers to look on</html>|<html>The result will only show tokens that are on the layers you check here.|LABEL|SPAN=TRUE")]
[h:inputStr		= json.append(inputStr, "doTokenLayer|"+doTokenLayer+"|Token Layer|CHECK")]
[h:inputStr		= json.append(inputStr, "doHiddenLayer|"+doHiddenLayer+"|Hidden Layer|CHECK")]
[h:inputStr		= json.append(inputStr, "doObjectLayer|"+doObjectLayer+"|Object Layer|CHECK")]
[h:inputStr		= json.append(inputStr, "doBackgroundLayer|"+doBackgroundLayer+"|Background Layer|CHECK")]

[h:inputStr		= json.append(inputStr, "junk|<html><b>The results will be presented as macrolinks</html>|<html>Macrolinks look like hyperlinks. However when<br>you click on them you do not open a page, but<br>activate a macro. Here you can choose WHICH<br>macro to activate.<br>|LABEL|SPAN=TRUE")]
[h:inputStr		= json.append(inputStr, "copyTok|decide when you click, copy token to current location, move token to current location, go to map and select token, DELETE token (with confirmation), DELETE token (WITHOUT confirmation)|Click on link will|RADIO|SELECT="+copyTok)]

[h:'<!-- ask for coords -->']
[h:inputStr		= json.append(inputStr, "junk|<html><b>If you summon the token(s), do this to: </b></html>|<html>The Token will be summoned to a CELL coordinate on the<br>current map. Per default this is 0,0. If you look at the<br>bottom right corner you see the coordinates of the cell<br>your cursor was last on the map. You can enter these<br>coordinates into the below boxes. Alternatively you can<br>select a token before you run this and the coords of the<br>position of the selected token will be entered instead.|LABEL|SPAN=TRUE")]
[h:inputStr 	= json.append(inputStr, "X|"+X+"|give X coordinates")]
[h:inputStr 	= json.append(inputStr, "Y|"+Y+"|give Y coordintates")]

[h:'<!-- show coords of selected token-->']
[h, if(PrimePC != ""):inputStr		= json.append(inputStr,"junk|"+X+","+Y+"|<html><b>Location of "+PrimePC+"</b>|LABEL")]

[h:'<!-- put local variables in input form -->']
[H: inputStr	= json.evaluate(inputStr)]
[h:'<!-- get user input, except when a returnArg is requested -->']
[H, if(!returnArg): abort(input(json.toList(inputStr,"##")))]

[h:'<!-- assertion -->']
[h:assert(showImage+showName+showLayer, "Check at least one of the Show Image, Name, Layer boxes",0)]
[h:assert(doTokenLayer+doObjectLayer+doHiddenLayer+doBackgroundLayer, "Check at least one of the (Token, Hidden, Object, Background) layer boxes",0)]

<!-- set search string to match everything when empty -->
[h,if(findTok == ""): findTok = "(?!,)."]
[h:regex		= strformat("(?i)([^,]*(%{findTok})[^,]*)")]
[h,if(!returnArg): result = "<a href='macro://gotoToken@lib:OnTokenMove/none/impersonated?[&quot;%{currentMap}&quot;, &quot;%{tok}&quot;, &quot;%{copyTok}&quot;, &quot;%{X}&quot;, &quot;%{Y}&quot;]'>"+if(showImage, "<img src=%s></img>", "<!-- %s -->")+if(showName, "%{tok}", "")+if(showLayer, " (%s)", "")+"</a>" ; result = "%{tok}"]

[h, if(!returnArg), CODE:{
	['<!-- {layer:["TOKEN", "HIDDEN", "OBJECT", "BACKGROUND"]} -->']
	[chosenLayers = "[]"]
	[if(doTokenLayer):		chosenLayers = json.append(chosenLayers, "TOKEN")]
	[if(doHiddenLayer):		chosenLayers = json.append(chosenLayers, "HIDDEN")]
	[if(doObjectLayer):		chosenLayers = json.append(chosenLayers, "OBJECT")]
	[if(doBackgroundLayer):	chosenLayers = json.append(chosenLayers, "BACKGROUND")]
};{}]
[h:layers		= json.set("{}", "layer", chosenLayers) ]

[h:'<!-- get ALL lib:tokens from ALL maps-->']
[h, if(libTok):	libTokens = listSort(json.fields(json.get(getInfo("client"),"library tokens")),"N+") ; libTokens = ""]
[h: libFoundList		= ""]

[h,foreach(currentMap,mapList,""), CODE: {
	[if(currentMap != getCurrentMapName()): setCurrentMap(currentMap)]
	[if(libTok < 2): allToks = listSort(getTokenNames(",",layers),"N+") ; allToks = ""]
	<!-- remove redundant whitespace around , and double spaces-->
	[h: allToks	=  replace(allToks, "\\s*([\\,\\s])\\s*","\$1")]

	[resultList	= ""]
	[id			= strfind(allToks, regex)]
	[numFound	= getFindCount(id)]
	[if(numFound > 1000), CODE:{
		[message	= strformat("Found: %{numFound} results on map %{currentMap}. Only showing the first 1000 results")]
		[numFound	= 1000]
		[pause("message")]
	}; {}]
	[count(numFound), CODE:{
		[tok		= getGroup(id, roll.count+1, 0)]
		[resultList	= listAppend(resultList, strformat(result, bot_getNewImage(30, tok), getLayer(tok)))]
	}]
	
	[libResultList = ""]
	[foreach(tok, libTokens), CODE:{
		[found	= if(findToken(tok) != "", 1, 0)]
		[if(found && libTok == 3):					duplicate			= if(listContains(libFoundList, tok),1,0) ; duplicate = 0]
		[if(found && libTok == 3):					libFoundList		= listAppend(libFoundList, tok)]
		[if(duplicate || (found && libTok < 3)):	libResultList		= listAppend(libResultList,		strformat(result, bot_getNewImage(30,tok), getLayer(tok)))]
		['if(found):pause("found", "tok", "libTokens","duplicate","libResultList","libTok")']
	}]
	
	[if(libResultList != ""): resultList	= listAppend(resultList, libResultList)]

	[if(!returnArg): 
		resultTxt	= resultTxt + "<td><b>" + currentMap + ":</b></td><td>" + if(listCount(resultList), resultList, 'none found')+"</td></tr>"
	; 
		returnValue	= if(numMaps > 1, json.set(returnValue, currentMap, resultList), resultList)
	]
}]
[h,if(oldMap != getCurrentMapName()): setCurrentMap(oldMap)]

[h:resultTxt	= resultTxt + "</table></html>"]

[h,if(copyTok == 0):	executeText = strformat("a <b>POP-UP</b> will appear asking you whether you want to Copy, Move or Select the corresponding token. When moved or copied, it will be to coord:(%{X},%{Y})"+if(PrimePC != "", "(%{PrimePC})", ""))]
[h,if(copyTok == 1):	executeText = strformat("the corresponding token will be <b>COPIED</b> to this map (%{oldMap}), to coord:(%{X},%{Y})"+if(PrimePC != "", "(%{PrimePC})", ""))]
[h,if(copyTok == 2):	executeText = strformat("the corresponding token will <b>MOVED</b> from its current location to this map, to coord:(%{X},%{Y})"+if(PrimePC != "", "(%{PrimePC})", ""))]
[h,if(copyTok == 3):	executeText = "you will switch to the map where the token is at and the token will be selected"]

[h:output = "When you click on one of the macrolinks  <u>"+executeText+"</u><br><br>"+resultTxt]
	
[r, if(!returnArg && bot_isFullScreen()), CODE:{
	[r,dialog("Looking for: "+ findTok,"width=400; height=400; input=1"):{[r:output]}]
};{}]

[r, if(!returnArg && !bot_isFullScreen()), CODE:{
	[r,frame("Looking for: "+ findTok,"width=400; height=400; "):{[r:output]}]
};{}]

[h:'<!-- save the settings from seek token macro -->']
[h:setLibProperty("seekTokensLastSettings", strPropFromVars("findTok, showImage, showName, showLayer, copyTok, libTok, doTokenLayer, doObjectLayer, doHiddenLayer, doBackgroundLayer","UNSUFFIXED"), "Lib:EventMacros")]

[h, if(returnArg):	macro.return = returnValue]

@@showHTML
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Util Documented ; tooltip= ; minWidth=90 ; 
[h:output = arg(0)]

[h: htmlResult = replace(output, "<", "&lt; ")]
[h: htmlResult = replace(htmlResult, "&lt; table", "<br>&lt; table")]
[h: htmlResult = replace(htmlResult, "&lt; /table", "<br>&lt; /table")]

[frame("displayHTML"):{
	<pre>
		[r: htmlResult]
	</pre>
}]

[frame("displayHTMLResult"):{
	[r: output]
}]

@@snapAngle
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=18 ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Util Documented ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------- snapAngle ------------------------------------------------>']
<!-- this function aligns the facing of a token to the closest angle given along a divider and returns the new angle -->
<!-- e.g a divider of 4 will face a token to either -90 0 90 or 180 depending on where its closest at -->
<!-- you can also turn off the align and just return the closest angle -->
[h:switchToken(arg(0))]
[h,if(getTokenFacing() == ""): setTokenFacing(-90)]
[h,if(argCount()>1): corners	= arg(1); corners	= 8]
[h,if(argCount()>2): align		= arg(2); align		= 1]

[h:cornerDivider = round(360/corners)]
[h:angle = round( (getTokenFacing()) / cornerDivider ) * cornerDivider]

[h, if(align): setTokenFacing(angle)]

[h:macro.return = angle]

@@snapToGrid
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=18 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=Util Documented ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------- snap2Grid(tok) ------------------------------------------------>']
[moveToken(round(getTokenX(1,arg(0))/json.get(json.get(getInfo("map"),"grid"),"size"),0), round(getTokenY(1,arg(0))/json.get(json.get(getInfo("map"),"grid"),"size"),0), 0, arg(0))]

@@sortTokByProp
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=21 ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Util Documented ; tooltip=This macro executes the macro on ALL clients. Feed it macro@lib:token, args (json array), players, output to ; minWidth=90 ; 
[h:'<!-- ---------------------------------- bot_sortTokByProp (propertyName [,sortOrder(asc/desc) ,list or array of tokens. Defaults to selected tokens) -------------- -->']
[h:sortKey	= arg(0)]
[h,if(argCount() > 1): order	= arg(1) ; order	= "ascending"]
[h,if(argCount() > 2): tokens	= arg(2) ; tokens	= getSelected()]

<!-- build array of token/sortkey objects -->
[h: array = ""]
[h, foreach(id, tokens): array = json.append(array, json.set("", "id", id, "sortKey", getProperty(sortKey, id)))]

<!-- sort -->
[h:array	= json.sort(array, order, "sortKey")]

<!-- retrieve token names/ids -->
[h:resultArray	= ""]
[h, foreach(item, array): resultArray = json.append(resultArray, json.get(item, "id"))]

<!-- output -->
[h: macro.return = resultArray]

@@switchMap
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=22 ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Util Documented ; tooltip=<html> Forces ALL clients to chosen map AND centres view on the token <i>centreOnMePad</i> <br><br>If you select tokens before you use this macro, then the option will be added to move<br>the selected tokens to the new map as well. These tokens will be placed near the <i>centreOnMePad</i><br><br>If there is no <i>centreOnMePad</i> then the coords (X,Y) 0,0 will be used instead. ; minWidth=90 ; 
[h:'<!------------------------------------- switchMap ([mapName[, players]]) ------------------------------------------------>']
<!-- The argument players must be either a list of player names or 1 to select ALL players -->

<!-- <html> Forces ALL clients to chosen map AND centres view on the token <i>centreOnMePad</i> <br><br>If you select tokens before you use this macro, then the option will be added to move<br>the selected tokens to the new map as well. These tokens will be placed near the <i>centreOnMePad</i><br><br>If there is no <i>centreOnMePad</i> then the coords (X,Y) 0,0 will be used instead.
-->
[h:assert(isGM(),"This macro can only be run by the GM",0)]

[h:mapList		= listSort(getAllMapNames(),"N+")]
[h:oldMap		= getCurrentMapName()]
[h:allPlayers	= getAllPlayerNames()]

[h,if(argCount() > 0): newMap	= arg(0) ; newMap	= oldMap]
[h:assert(listFind(mapList, newMap) != -1, "The map "+arg(0)+" does not exist",0)]

[h,if(argCount() > 1), CODE:{
	<!-- in case both arguments have been given, the input can be omitted and the players can be switched to the map -->
	[userList		= arg(1)]
	[if(userList == 1): userList = getAllPlayerNames()]

	<!-- move players -->
	[playerList = ""]

	[FOREACH(player, userList), if(listContains(allPlayers, player)): playerList = listAppend(playerList, player) ; broadcast("The player: "+player+" does not exist!")]
	[selCount		= 0]
};{
	<!-- in case one or no arguments have been given, show the input and ask for map and players to switch map for -->
	[newMap		= listFind(mapList, newMap)]
	[userList	= allPlayers]
	[selected	= getSelectedNames()]
	[selCount	= listCount(selected)]

	<!-- input string -->
	[							inputStr = "junk|<html><b>Force Selected Players to Map<br></html>|-|LABEL|SPAN=TRUE"]
	[							inputStr = listAppend(inputStr, "newMap|"+mapList+"|Select map|RADIO|VALUE=STRING SELECT="+newMap,"@")]
	[if(selCount):				inputStr = listAppend(inputStr, "selCount|1|<html><b>Move selected token(s)?</b></html>|CHECK","@")]
	[if(selCount):				inputStr = listAppend(inputStr, "junk|<html>("+selected+")<br>&nbsp;</html>|-|LABEL|SPAN=TRUE","@")]
	[							inputStr = listAppend(inputStr, "junk|<html><b>Select Players<br></html>|-|LABEL|SPAN=TRUE","@")]
	[FOREACH(player, userList):	inputStr = listAppend(inputStr, "player"+roll.count+"|1|"+player+"|CHECK","@")]

	<!-- ask for input-->
	[abort(eval(listFormat(inputStr, "input( %list )", " ' %item ' ", ",", "@")))]
	
	<!-- move players -->
	[playerList = ""]
	[FOREACH(player, userList), CODE:{
		[if(eval("player"+roll.count)): playerList = listAppend(playerList, player)]
	}]
}]

<!-- move tokens (if any) -->
[if(selCount && oldMap != newMap), CODE:{
	[setCurrentMap(newMap)]
	[if(findToken("centreOnMePad")!=""), CODE:{
		[X = getTokenX(0,"centreOnMePad")]
		[Y = getTokenY(0,"centreOnMePad")]
	};{
		[X = 0]
		[Y = 0]
	}]
	[FOREACH(tok, selected): moveTokenFromMap(tok, oldMap, X+roll.count, Y)]
	[setCurrentMap(oldMap)]
};{}]

[h:bot_execAllPlayers("gotoMap@lib:OnTokenMove",newMap, playerList)]

@@travelAngle
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=19 ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Util Documented ; tooltip= ; minWidth=90 ; 
[h:'<!------------------------------------- travelAngle ------------------------------------------------>']
<!-- this function calculates the facing of a token travelling in a certain direction with a acurracy of 45 degrees -->
<!-- x1 is the current position, x2 is the postion travelling to -->
<!-- based on CIFs calculateFacing -->
[h:x1 = arg(0)]
[h:y1 = arg(1)]
[h:x2 = arg(2)]
[h:y2 = arg(3)]
<!-- option 0 = return angle, 1 = return cardinal directions -->
[h, if(argCount()>4):option = arg(4) ; option = 0]

[h:dx = x2 - x1]
[h:dy = y2 - y1]

[h, if(dx), CODE:{
	<!-- check if the angle close to one of the 4 diagonals. If not set the smallest dn to 0 -->
	<!-- tan(45/2) == 0.414 and 1/0.414 == 2.414 -->
	[diagonal = abs(dy/dx)]
	[if(diagonal < 0.414214):dy = 0]
	[if(diagonal > 2.414214):dx = 0]
}; {}]

<!-- make sure that the other value is limited between -1 and 1 and positive by adding +1 -->
[dxl = min(1, max(dx, -1)) + 1]
[dyl = min(1, max(dy, -1)) + 1]

<!-- this creates two sets dx and dy with the values 0,1 or 2. By multiplying dx by 3 and adding it to dy you get a list of 0 to 8 (without 4 which can only exist if dx and dy are both 0, and that means that the token does NOT travel) which you can turn into a list of corresponding angles -->
[h:'pause("x1","y1","x2","y2","dx","dy","diagonal","dxl","dyl")']
[h,if(option):
	macro.return = listGet("North West,West,South West,North,NONE,South,North East,East,South East", 3 * dxl + dyl)
;
	macro.return = listGet("135, 180, -135, 90, 0, -90, 45, 0, -45", 3 * dxl + dyl)
]

@@createTable
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=1 ; color=darkgray ; playerEditable=true ; applyToSelected=false ; group=11. Tables ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------------- TokenParserBoxFrame ------------------------------------------------------- -->']
<!-- shows a frame in which you can copy paste an excel table. This table will be processed in a table+ table. -->
[frame("List builder", "width = 250; height = 330; temporary = 0"): {
	<html>
	<head>
		<title>Edit Token Frame</title>
		<meta name = "input" content = "true">
 </head>
	<body>
		<form method = "json" name = "TokenInput" action = "[r:macroLinkText('text2Table@Lib:onTokenMove')]">
			<input type = "hidden" name = "show" value = 0> </input>
			<table>
				<tr><th align = "left"><label for = "Name">Paste List here (straight from excel):</label></th></tr>
				<tr><td><textarea rows = "10" cols = "500" name = 'TextBox' ></textarea></td></tr>
			</table>
			<table>
				<tr><td colspan="2" width="5%"><b>Title of the table:</b></td></tr>
				<tr><td colspan="2"><input type = "text" name = "Title": size = "50"> </input></td></tr>
				<tr><td width="5%"><input type = "checkbox" name = "show" value = 1> </input> </td><td width="95%">Edit table afterwards</td></tr>
			</table>
			<br>
			<input type = "submit" name = "Save" value = "Save"> </input>
		</form>
	</body>
	</html>
}]

@@deleteTable
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=10 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=11. Tables ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------------- deleteTable ------------------------------------------------------- -->']
<!-- gives a lists of all available tables, from which the one picked will be deleted -->

[h:shortTblNames	= bot_listBoTTables()]

[h:abort(input("shortTblName|"+shortTblNames+"|Choose a table|RADIO|SELECT	= 0 VALUE=STRING"))]

[h:resetProperty("tbl."+shortTblName, "lib:EventMacros")]
[h:broadcast(strformat("Table <b>%{shortTblName}</b> has been deleted"))]

@@getColumns
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=6 ; color=default ; playerEditable=false ; applyToSelected=false ; group=11. Tables ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------------- getColumns (0.table name) ------------------------------------------------------- -->']
<!-- returns a list of the columns of a table -->
[macro.return	= decode(json.fields(json.get(getLibProperty("tbl."+arg(0), "Lib:EventMacros"), listGet(bot_getRows(arg(0)),1))))]

@@getRows
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=5 ; color=default ; playerEditable=false ; applyToSelected=false ; group=11. Tables ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------------- getColumns (0.table name) ------------------------------------------------------- -->']
<!-- returns a list of the columns of a table -->
[macro.return	= decode(json.fields(getLibProperty("tbl."+arg(0), "Lib:EventMacros")))]

@@json.pappend
@PROPS@ fontColor=fuchsia ; autoExecute=true ; fontSize=1.00em ; sortBy=99 ; color=default ; playerEditable=true ; applyToSelected=false ; group=11. Tables ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------------- json.pappend ------------------------------------------------------- -->']
<!-- json.pappend( 0. json object, 1. path/like/this, 2. value to add)  -->
<!-- original code by lmarkus001, minor updates by wolph42 -->

[assert(argCount()	== 3, "json.pset requires three arguments (JSONVariable, JSONPath, Value)", 0)]
[jV		= arg(0)]
[path	= trim(arg(1))]
[val	= arg(2)]

[path	= replace("path\", "\\\", "/")]
[path	= if(substring(path, 0, 1) == "/", substring(path, 1), path)]

[if(listCount(path, "/") <= 1), CODE: {
	[output		= json.append(jV, val)]
};{
	[fld		= listGet(path, 0, "/")]
	[newPath	= substring(path, length(fld)+1)]
	[assert(fld != "", "Invalid path " + path, 0)]
	[newjV		= json.get(jV, fld)]
	<!-- recursive call -->
	[output		= json.set(jV, fld, json.pappend( newjV, newPath, val))]
}]

[macro.return = output]

@@json.paths
@PROPS@ fontColor=fuchsia ; autoExecute=true ; fontSize=1.00em ; sortBy=99 ; color=default ; playerEditable=true ; applyToSelected=false ; group=11. Tables ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------------- json.paths ------------------------------------------------------- -->']
<!-- json.paths( 0. json object) -->
<!-- original code by Craig, further improved by lmarkus001, minor updates by wolph42 -->

[assert(argCount() > 0, "json.paths requires a single argument ( JSONVariable )", 0)]
[val	= arg(0)]
[if(argCount() > 1): prefix	= arg(1) ; prefix	= ""]
[paths	= "[]"]
[if(json.type(val) != "UNKNOWN"), foreach(p, json.fields(val)), CODE: {
	[obj	= json.get(val, p)]
	[if(json.type(obj)	== "UNKNOWN"), CODE : {
		[paths		= json.append(paths, prefix + "/" + p)]
	};{
		[newPrefix	= prefix + "/" + p]
		[paths		= json.union(paths, json.paths(obj, newPrefix))]
	}] 
}]

[macro.return	= json.sort(paths)]

@@json.pget
@PROPS@ fontColor=fuchsia ; autoExecute=true ; fontSize=1.00em ; sortBy=99 ; color=default ; playerEditable=true ; applyToSelected=false ; group=11. Tables ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------------- json.pget ------------------------------------------------------- -->']
<!-- json.pget( 0. json object, 1. path/like/this)  -->
<!-- original code by Craig, further improved by lmarkus001, minor updates by wolph42 -->

[assert(argCount()	== 2, "json.pget requires two arguments (JSONVariable, JSONPath)", 0)]
[val	= arg(0)]
[path	= arg(1)]
[foreach(fld, path, "", "/"), CODE:{ 
	[if(fld != ""), CODE: {
		[if(json.type(val)	== "OBJECT"): assert(json.contains(val, fld), "Invalid path ( " + fld + " )", 0)]
		[if(json.type(val)	== "ARRAY"): aT	= if( fld > (json.length(val) - 1), 0, 1)]
		[if(json.type(val)	== "ARRAY"): assert( aT, "Invalid path index ( " + fld + " )", 0)]
		[val	= json.get(val, fld)]
	};{}]
}]

[macro.return	= val]

@@json.pset
@PROPS@ fontColor=fuchsia ; autoExecute=true ; fontSize=1.00em ; sortBy=99 ; color=default ; playerEditable=true ; applyToSelected=false ; group=11. Tables ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------------- json.pset ------------------------------------------------------- -->']
<!-- json.pset( 0. json object, 1. path/like/this, 2. value to add)  -->
<!-- original code by lmarkus001, minor updates by wolph42 -->

[assert(argCount()	== 3, "json.pset requires three arguments (JSONVariable, JSONPath, Value)", 0)]
[jV		= arg(0)]
[path	= arg(1)]
[val	= arg(2)]
[path	= if(substring(path, 0, 1)	== "/", substring(path, 1), path)]
[if(listCount(path, "/") == 1), CODE: {
	[output		= json.set(jV, path, val)]
};{
	[fld		= listGet(path, 0, "/")]
	[newPath	= substring(path, length(fld)+1)]
	[assert(fld != "", "Invalid path " + path, 0)]
	[newjV		= json.get(jV, fld)]
	[output		= json.set(jV, fld, json.pset( newjV, newPath, val))]
}]
[macro.return	= output]

@@listBoTTables
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=8 ; color=default ; playerEditable=false ; applyToSelected=false ; group=11. Tables ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------------- listBoTTables ------------------------------------------------------- -->']
<!-- returns a list with the SHORT names of the tables -->

[h:fullTblNames 	= listSort(getMatchingLibProperties("tbl\\..*", "Lib:EventMacros"),"A+")]
[h:shortTblNames	= ""]
[h, foreach(item, fullTblNames): shortTblNames	= listAppend(shortTblNames,substring(item,4))]
[h:assert(shortTblNames != "", "There are currently no tables stored on lib:EventMacros", 0)]
[h:macro.return		= shortTblNames]

@@listMTTables
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=7 ; color=default ; playerEditable=false ; applyToSelected=false ; group=11. Tables ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------------- listMTTables ------------------------------------------------------- -->']
<!-- returns a list of all the available MAPTOOL tables -->
[h:macro.return		= json.toList(json.sort(json.get(getInfo("campaign"), "tables")))]

@@processTable
@PROPS@ fontColor=green ; autoExecute=true ; fontSize=1.00em ; sortBy=4 ; color=default ; playerEditable=true ; applyToSelected=false ; group=11. Tables ; tooltip= ; minWidth=90 ; 
[h:'<!-- ----------------------------------------- processTable ------------------------------------------------- -->']
<!-- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), getMacroName(), getMacroLocation()) -->
[h:debug			= 0]

[h:result			= macro.args]
[h:assert(json.type(result) == "OBJECT","processTable received an erronous table. Most likely this is because you used double quotes in one of the fields.",0)]
[h:origResult		= result]
[h:result			= encode(result)]
[h:result			= replace(result, "%7B", "{")]
[h:result			= replace(result, "%7D", "}")]
[h:result			= replace(result, "%3A", ":")]
[h:result			= replace(result, '%22', '"')]
[h:result			= replace(result, '%2C', ',')]
[h:result			= replace(result, '%40', '@')]

[h:shortTblName		= json.get(origResult, "shortTblName")]
[h:choice			= json.get(origResult, "button")]
[h:tableColumnSize	= json.get(origResult, "tableColumnSize")]

<!-- process choice -->
[h:rebuild			= 0]
[h:addRow			= 0]
[h:addColumn		= 0]
[h,switch(choice), CODE:
	case "Save":{ 
		<!-- do nothing just continue --> 
	};
	case "Reset to last save":{
		[bot_showTable(shortTblName)]
		[abort(0)]
	};
	case "Save & Close":{
		[closeFrame("Table Editor")]
	};
	case "<- Column ->":{
		[tableColumnSize = tableColumnSize + 1]	
		[rebuild	= 1]							
	};
	case "-> Column <-":{
		[tableColumnSize = tableColumnSize - 1]
		[rebuild	= 1]							
	};
	case "Add Row":{
		[addRow		= 1]
		[rebuild	= 1]							
	};
	case "Add Column":{
		[addColumn	= 1]
		[rebuild	= 1]							
	};
	default:{
		[abort(0)]
	};
]

[h,if(choice == "close" || choice == "submit change & close"): closeFrame("Table Editor")]
[h:assert(choice != "close", "Changes have been discarded", 0)]

<!-- create new table based on changes -->
<!-- first check if the column or row names have changed, if so process that in the table -->
[h:tmpResult		= result]
[h:columns			= ""]
[h:rows				= ""]

[h,foreach(item, result), CODE:{
	[if(startsWith(item, "@")), CODE:{
		<!-- these are the column names, check if they have changed! -->
		<!-- typical entry:  "@name": "name" (unchanged)  "@name": "Type" (changed) -->
		[value	= json.get(result, item)]
		[item	= substring(item,1)]
		<!-- value has changed so change ALL column entries in the table -->
		[if(value != item): tmpResult = replace(tmpResult, '@'+item+'"', '@'+value+'"')]
		<!-- create list of column names -->
		[columns	= listAppend(columns, value)]
	}]

	[if(endsWith(item, "@")), CODE:{
		<!-- these are the row names, check if they have changed! -->
		<!-- typical entry:  "pistol@": "pistol" (unchanged)  "pistol@": "gun" (changed) -->
		[value	= json.get(result, item)]
		[item	= substring(item,0,length(item)-1)]
		<!-- value has changed so change ALL column entries in the table -->
		[if(value != item): tmpResult = replace(tmpResult, '"'+item+'@', '"'+value+'@')]
		<!-- create list of row names -->
		[rows		= listAppend(rows, value)]
	}]
}]
[h:result			= tmpResult]
[h,if(addColumn):	columns	= listAppend(columns, encode("<new column>"))]
[h,if(addRow):		rows	= listAppend(rows, encode("<new row>"))]

<!-- finally process the remainder into a new table json structure -->
[h:table	= json.set("{}", "tableColumnSize", tableColumnSize)]
[h,foreach(rowName, rows), CODE:{
	<!-- these are the table entries -->
	<!-- typical entry:  "pistol@damage": "3d6" -->
	[row	= "{}"]
	[h,foreach(columnName, columns): row = json.set(row, columnName, json.get(result, rowName+"@"+columnName)))]
	[table	= json.set(table, rowName, row)]
	['pause("rowName","rows","row","result","columns")']
}]

[h,if(debug == 1), code:{
	<!-- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), getMacroName(), getMacroLocation()) -->
	[bot_debugInfo("result,table",0,1,0, getMacroName(), getMacroLocation())]
	[r,frame("Debug", "width=100; height=100; temporary=1"): {
		<b>DEBUG INFO</b>
		<pre>
		[r:json.indent(table)]
	}]
	[h:where = getMacroName()]
	[h:pause("shortTblName", "where", "rows", "columns")]
};{}]

<!-- and save it -->
[h:setLibProperty("tbl."+shortTblName, table, "Lib:EventMacros")]
[h,if(rebuild || debug): bot_showTable(shortTblName)]
[h:broadcast("Table is updated!")]

@@searchRow
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=default ; playerEditable=true ; applyToSelected=false ; group=11. Tables ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------------- searchRow ------------------------------------------------------- -->']
[while(!done), CODE:{
	[row		= listGet(rows, roll.count)]
	[pause("row")]
	[if(indexOf(row,"-")+1), CODE:{
		[location	= indexOf(row,"-")]
		[start		= number(substring(row, 0, location))]
		[end 		= number(substring(row, location + 1, length(row)))]
		[if(roll >= start && roll <= end): resultRow = row]
	''
	};{
		[if(roll == row): resultRow = row]
	''
	}]
	[if(roll.count >= rowCount || resultRow != ""): done = 1]
''
}]

@@setTable
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=darkgray ; playerEditable=true ; applyToSelected=false ; group=11. Tables ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------------- bot_setTable ------------------------------------------------------- -->']
<!-- keep in mind that you canNOT use numerical values for the column names!!!! -->
<!-- arguments: 0 = shortTblName, 1. = column, 2 = row (either index or name), value -->
<!-- THREE CODE LEVELS -->

[h:assert(argCount() == 4, "setTable requires EXACTLY 3 paramters: tableName, columnName, rowName, value",0)]
[h:shortTblName	= arg(0)]
[h:column		= arg(1)]
[h:row			= arg(2)]
[h:value		= encode(arg(3))]

[h:table		= getLibProperty("tbl."+shortTblName, "Lib:EventMacros")]
[h:assert(json.type(table)=="OBJECT", strformat("Cannot find the table <b>%{shortTblName}</b> on lib:EventMacros"),0)]
[h:rows			= decode(json.fields(table))]
[h,if(listContains(rows, "tableColumnSize")): rows = listDelete(rows, listFind(rows, "tableColumnSize"))]
[h:assert(listContains(rows,row), strformat("Cannot find the row <b>%{row}</b> in the table: <b>%{shortTblName}<b>. Available rows are: <b>%{rows}</b>"),0)]
[h:columns		= decode(json.fields(json.get(table, listGet(rows,0))))]
[h:assert(listContains(columns,column), strformat("Cannot find the column <b>%{column}</b> in the table: <b>%{shortTblName}</b>. Available column are: <b>%{columns}</b>"),0)]

[h:encColumn	= encode(column)]
[h:encRow		= encode(row)]

[h:tmpRow		= json.get(table, encRow)]
[h:tmpRow		= json.set(tmpRow, encColumn, value)]
[h:table		= json.set(table, encRow, tmpRow)]

[h:table		= setLibProperty("tbl."+shortTblName, table, "Lib:EventMacros")]

[bot_setTable("tiny", 'name', 6, "tom")]

<pre>
[r:table		= getLibProperty("tbl.tiny", "Lib:EventMacros")]
[r:rows			= decode(json.fields(table))]
[r:columns		= decode(json.fields(json.get(table, listGet(rows,0))))]

@@showTable
@PROPS@ fontColor=green ; autoExecute=true ; fontSize=1.00em ; sortBy=3 ; color=darkgray ; playerEditable=true ; applyToSelected=false ; group=11. Tables ; tooltip= ; minWidth=90 ; 
[h:'<!-- ----------------------------------------- showTable(shortTblName) ------------------------------------------------- -->']
<!-- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), getMacroName(), getMacroLocation()) -->
[h:debug = 0]

[h,if(argCount()): 
	shortTblName = arg(0) 
; 
	abort(input(
		"shortTblName|"+bot_listBoTTables()+"|Show which table|RADIO|VALUE=STRING"
	))
]
[h:table	= getLibProperty("tbl."+shortTblName, "Lib:EventMacros")]

<!-- ----------------------------- DEBUG --------------------------- -->
[h,if(debug == 1), code:{
	[r,frame("Debug", "width=100; height=100; temporary=1"): {
		<b>DEBUG INFO</b>
		<pre>
		[r:json.indent(table)]
	}]
	[h:pause("shortTblName")]
};{}]
<!-- ----------------------------- /DEBUG --------------------------- -->

[h,if(json.contains(table, "tableColumnSize")), CODE:{
	[size	= json.get(table, "tableColumnSize")]
	[table	= json.remove(table, "tableColumnSize")]
};{
	[size	= 10]
}]

[h:encRows		= json.fields(table)]
[h:encColumns	= json.fields(json.get(table, listGet(encRows,0)))]

<!-- create header row -->
[h:headerRow	= "<td align='center'><b>Index</b></td>"]
[h,foreach(encColumn, encColumns), CODE:{
	[column		= decode(encColumn)]
	[headerRow	= headerRow + strformat("<td><b><input type='text' name='@%{column}' value='%{column}' size='%{size}'></b></td>")]
}]

[h:processorLink	= macroLinkText('processTable@Lib:onTokenMove', 'none')]
[h:htmlStr			=	strformat("
	<form action='%{processorLink}' method='json' >
	<input type='hidden' name='shortTblName' value='%{shortTblName}'>
	<input type='hidden' name='tableColumnSize' value='%{size}'>
	<input type='submit' name='button' value='Save'>
	<input type='submit' name='button' value='Reset to last save'>
	<input type='submit' name='button' value='Save & Close'>
	<input type='submit' name='button' value='<- Column ->'>
	<input type='submit' name='button' value='-> Column <-'>
	<input type='submit' name='button' value='Add Row'>
	<input type='submit' name='button' value='Add Column'>
	<table cellpadding='0' cellspacing='0'><tr>%{headerRow}</tr>
")]

[h,if(debug == 1), code:{
	['bot_debugInfo("htmlStr",1,0,0)']
};{}]

[h,foreach(encIndex,encRows), CODE:{
	[nRow		= roll.count]
	[index		= decode(encIndex)]
	[encRow		= json.get(table, encIndex)]
	[htmlRow	= strformat("<td><input type='text' name='%{index}@' value='%{index}' size='%{size}'></td>")]
	[foreach(encColumn, encRow), CODE:{
		[nColumn	= roll.count]
		[column		= decode(encColumn)]
		[value		= decode(json.get(encRow, encColumn))]
		[htmlRow	= strformat("%{htmlRow}<td><input type='text' name='%{index}@%{column}' value='%{value}' size='%{size}'></td>")]
	}]
	[htmlStr	= strformat("%{htmlStr}<tr>%{htmlRow}</tr>")]
}]

[h:htmlStr	=	strformat("%{htmlStr}
	</table>
	<input type='submit' name='button' value='Save'>
	<input type='submit' name='button' value='Reset to last save'>
	<input type='submit' name='button' value='Save & Close'>
	<input type='submit' name='button' value='<- Column ->'>
	<input type='submit' name='button' value='-> Column <-'> 
	</form>
<br>
<b>Da Rules</b>: <br>
When I'm talking about column/row *names* I means the entries in the first column (==Index ==row names) and the top row (== column names). When I'm talking about *values* thats the rest. Every value is referred (found) by its corresponding column and row name.<br>
- do NOT use the 'single quotes' in the table. Everything should still work, but they will be removed. <br>
- do NOT use '@' for column or row names. I use this in the code as seperator, so funky stuff will happen if you're using it too. It should be ok to use it inside values, just not in the names. <br>
- every column and row MUST have a unique name <br>
- thus the 'add row/column' macro will only work once until you renamed the newly created column/row.<br>
- everything you enter is encoded and then stored in a json object. This *Should* result in a quite robust table allowing for many characters. I have not tested them all, although I'm fairly certain that it will break on 'non-printable character' (e.g. the apostrophe's in Word).<br>
")]
[h:'bot_showHTML(htmlStr)']

[r,frame("Table Editor", "width=100; height=100; temporary=1"): {
	[r:htmlStr]
	[r,if(debug == 1), code:{
		<b>DEBUG INFO</b>
		<pre>
[r:json.indent(table)]
	};{}]
}]

@@table
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=9 ; color=darkgray ; playerEditable=true ; applyToSelected=false ; group=11. Tables ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------------- bot_table ------------------------------------------------------- -->']
<!-- keep in mind that you canNOT use numerical values for the column names!!!! -->
<!-- arguments: 0 = shortTblName, optional: 1 = column (either index or name. Defaults to 0), 2 = row (either index or name, Defaults to random pick) -->
<!-- THREE CODE LEVELS -->

[h, if(argCount() > 0): shortTblName= arg(0);	shortTblName= ""]
[h, if(argCount() > 1): column		= arg(1);	column		= 0]
[h, if(argCount() > 2): roll		= arg(2);	roll		= "random"]

[if(shortTblName == ""), CODE:{
	<!-- show table list and all options to pick a value -->
	[shortTblNames	= bot_listBoTTables()]
	[abort(input("shortTblName|"+shortTblNames+"|Choose a table|RADIO|SELECT=0 VALUE=STRING"))]

	[h:table	= getLibProperty("tbl."+shortTblName, "Lib:EventMacros")]
	[h:assert(json.type(table)=="OBJECT", strformat("Cannot find the table <b>%{shortTblName}</b> on lib:EventMacros"),0)]
	[h:rows		= decode(json.fields(table))]
	[h, if(listContains(rows, "tableColumnSize")):rows		= listDelete(rows, listFind(rows, "tableColumnSize"))]
	[h:columns	= decode(json.fields(json.get(table, listGet(rows,0))))]

	[abort(input(
		"column|"+columns+"|Choose column|RADIO|SELECT=0 VALUE=STRING",
		"row|"+rows+"|Choose row|RADIO|SELECT=0 VALUE=STRING"
	))]
''
};{
	[h:table	= getLibProperty("tbl."+shortTblName, "Lib:EventMacros")]
	[h:assert(json.type(table)=="OBJECT", strformat("Cannot find the table <b>%{shortTblName}</b> on lib:EventMacros"),0)]
	[h:rows		= decode(json.fields(table))]
	[h, if(listContains(rows, "tableColumnSize")):rows		= listDelete(rows, listFind(rows, "tableColumnSize"))]
	[h:columns	= decode(json.fields(json.get(table, listGet(rows,0))))]
	[h,if(isNumber(column)): column	= listGet(columns, column)]

	[h,if(isNumber(roll) || roll == "random"),CODE:{
		<!-- retrieve the highest number for the roll -->
		[rowCount	= listCount(rows)]
		[lastRow	= listGet(rows, rowCount-1)]
		[if(indexOf(lastRow,"-")+1): end	= substring(lastRow, indexOf(lastRow,"-") + 1, length(lastRow)) ; end = lastRow]
		[if(isNumber(end)), CODE:{
			[end			= number(end)]
			[numericRows	= 1]
		''
		};{
			[end			= listCount(rows)]
			[numericRows	= 0]
		''
		}]
		
		<!-- Make the roll -->
		[roll	= if(roll == "random",roll(1, end),roll)]
		
		[if(numericRows), CODE:{
			[resultRow	= ""]
			[done		= 0]
			<!-- seperate function as the while loop does not do well in these nested if statements. SAME SCOPE -->
			[bot_searchRow()]
		''
		};{
			<!-- NOT numeric rows -->
			[row	= listGet(rows, roll-1)]
		''
		}]
	''
	};{
		<!-- the argument isnt a number and thus a string, so look for a string -->
		[row	= roll]
	''
	}]
''
}]
[pause("column", "row")]
[macro.return	= decode(json.pget(table,encode(row)+"/"+encode(column)))]

@@text2Table
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=2 ; color=default ; playerEditable=true ; applyToSelected=false ; group=11. Tables ; tooltip= ; minWidth=90 ; 
[h:'<!-- -------------------------------------- text2Table ------------------------------------------------------- -->']
<!-- this function does the actual processing of the copy pasted excel table in the html form. -->

<!-- List Parsing XPTL -->
[h: args 	= macro.args]
[h: Title 	= json.get(args, "Title")]
[h: show 	= json.get(args, "show")]
[h: text 	= encode(json.get(args, "TextBox"))]

[delim	 	= "%09"]
[lb 		= "%0A"]

[jTable		= "{}"]
[row		= ""]
[rowName	= ""]

[rows		= json.fromList( text , lb )]
[nRows		= json.length( rows )]

<!-- first line only: might be more efficient to pull this out and only do it once 
	(rather than having to evaluate and skip EVERY OTHER TIME THROUGH THE LOOP) -->
[line.txt	= json.get( rows , 0 )]						<!-- get the 1st line (omitting line break) -->
[headerRow	= json.fromList( line.txt , delim )]		<!-- "%09" if encoded, decode( "%09" ) otherwise, or specified by argument? -->
[tableName	= json.get( headerRow, 0 )]
[nCols		= json.length( headerRow )]					<!-- this might only really need to be done with the first line -->
[rows		= json.remove( rows , 0 )]					<!-- drop header row (for convenience) -->

<!-- all subsequent rows -->
[h, FOREACH( rowText , rows ), CODE: {
	[rowText	= listAppend(rowText, "tmp", delim)]		<!-- if the list ends with a couple of empty values they are discarded, so add a tmp value -->
	[row		= json.fromList( rowText , delim )]			<!-- "%09" if encoded, decode( "%09" ) otherwise, or specified by argument? -->
	[row		= json.remove( row, nCols)]					<!-- remove tmp value -->
	[jRow		= "{}" ]
	[FOR( i , 0 , nCols ), CODE: {
		[item 		= json.get( row , i )]					<!-- get the 'ith' item (omitting delimiter) -->
		[column		= json.get( headerRow , i )]			<!-- get the 'ith' column name -->

		<!-- name of current row / assemble row object -->
		[if( i == 0 ): rowName = item ; jRow = json.set( jRow , column, item )]
	}]
	[jTable		= json.set( jTable , rowName , jRow )]
}]

[h:setLibProperty("tbl."+Title, jTable, "Lib:EventMacros")]
[h,if(show):bot_showTable(Title)]

@@deferToggleDoor
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=2 ; color=default ; playerEditable=false ; applyToSelected=true ; group=5a. Door Animation ; tooltip= ; minWidth=90 ; 
[h:'<!-- ------------------------------------------- deferToggleDoor --------------------------------------- -->']
[h:debug = 0]

[H: time = json.get(getInfo("client"),"timeInMs")]
[h: init = !getFindCount(strfind(macro.args, "currentStepSize"))]

[H, if(init), code: {
	<!-- Assertions and initializing properties -->
	[me				= arg(0)]
	[mainDoor		= arg(1)]
	[doorMap		= arg(2)]
	[choice			= arg(3)]
	[isClosed		= arg(4)]
	<!-- Abort when player is on other map -->
	[currentMap		= getCurrentMapName()]
	[if(doorMap != currentMap),CODE:{
		[setCurrentMap(doorMap)]
		[removeToken(me)]
		[if(doubleDoor):	removeToken(me + 'a')]
		[setOwnerOnlyVisible(0, mainDoor)]
		[if(doubleDoor):	setOwnerOnlyVisible(0, mainDoor + 'a')]
		[setCurrentMap(currentMap)]
		[abort(0)]
	}; {}]
	[switchToken(me)]

	<!-- switchId, openMethod, doubleDoor, description, closedAngle, openAngle, openDistance, animateTime, withSwitch, proximity, drawVBL, windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, halfOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpenDoorX, crackOpenDoorY, halfOpenDoorX, halfOpenDoorY, xDirection -->
	[h:varsFromStrProp(getProperty("w42.bot.doorData"))]
	
	[if(drawVBL), CODE:{
		<!-- mt version VBL support check -->
		[if(!getLibProperty('vblSupport','lib:EventMacros')):drawVBL = 0]
	};{}]
	[assert(openMethod != "", "Please set the value openMethod of the door first (select the door and run 'set door' on the campaign panel)")]
	[rotating		= if(openMethod < 2, 1,0)]

	<!-- initialize timers -->
	[startTime		= time]
	[endTime		= min(15000,number(animateTime))]	

<!-- ROTATION INIT -->
	<!-- check if door is open or closed, and if in between reset its position to either open or closed -->
	[currentPos		= bot_getTokenFacing(me)]
<!-- SLIDING INIT -->
	[currentX		= getTokenX(1,me)]
	[currentY		= getTokenY(1,me)]
	<!-- does the door slides left right (x) or up down (y) -->
	[xDirection		= if(openMethod < 4, 1, 0)]
	[otherPos		= if(xDirection, currentY, currentX)]

<!-- ROTATION -->
	[if(isClosed && rotating), CODE:{
		[direction 		= if(openMethod, -1, 1)]
		[startPos		= closedAngle]
		[if(choice == "crackVBL"):	endPos = crackOpenAngle]
		[if(choice == "halfVBL"):	endPos = halfOpenAngle]
		[if(choice == "fullVBL"):	endPos = totalOpenAngle]
	}; {}]

	[if(!isClosed && rotating), CODE:{
		[direction 		= if(openMethod, 1, -1)]
		[if(choice == "crackVBL"):	startPos = crackOpenAngle]
		[if(choice == "halfVBL"):	startPos = halfOpenAngle]
		[if(choice == "fullVBL"):	startPos = totalOpenAngle]
		[endPos			= closedAngle]
		[setTokenFacing(startPos)]
	}; {}]
<!-- /ROTATION -->

<!-- SLIDING -->
	[if(isClosed && !rotating), CODE:{
		[direction 		= if(odd(openMethod), 1, -1)]
		[startPos		= if(xDirection, closedDoorX, closedDoorY)]
		[if(choice == "crackVBL"):	endPos	= if(xDirection, crackOpenDoorX, crackOpenDoorY)]
		[if(choice == "halfVBL"):	endPos	= if(xDirection, halfOpenDoorX, halfOpenDoorY)]
		[if(choice == "fullVBL"):	endPos	= if(xDirection, openDoorX, openDoorY)]
	}; {}]

	[if(!isClosed && !rotating), CODE:{
		[direction 		= if(odd(openMethod), -1, 1)]
		[endPos			= if(xDirection, closedDoorX, closedDoorY)]
		[if(choice == "crackVBL"):	startPos	= if(xDirection, crackOpenDoorX, crackOpenDoorY)]
		[if(choice == "halfVBL"):	startPos	= if(xDirection, halfOpenDoorX, halfOpenDoorY)]
		[if(choice == "fullVBL"):	startPos	= if(xDirection, openDoorX, openDoorY)]

		<!-- if the door is not open, make sure that its in the correct open position -->
		[moveToken(if(xDirection, startPos, otherPos), if(xDirection, otherPos, startPos), 1, me)]
	}; {}]
<!-- /SLIDING -->

	[currentPos			= startPos]
	[if(doubleDoor): doubleStartPos	= bot_getTokenFacing(me+'a') ; doubleStartPos = 0]
	[if(choice == "crackVBL"):	currentStepSize = direction * crackStepSize]
	[if(choice == "halfVBL"):	currentStepSize = direction * halfStepSize]
	[if(choice == "fullVBL"):	currentStepSize = direction * stepSize]
}; {
	[varsFromStrProp(macro.args)]
	[currentPos			= newPos]
}]

[H: elapsedTime	= time - startTime]
[h: newPos 		= startPos + floor(elapsedTime * currentStepSize)]
<!-- if newPos is on the other side of endPos than the currentPos it will have an opposite sign and thus the multiplication result will be negative -->
['pause("endPos","currentPos","newPos","elapsedTime","endTime","currentStepSize")']
[h: tooFar 		= if( (endPos - currentPos) * (endPos - newPos) < 0 || elapsedTime > endTime, 1, 0 )]
[h: newPos		= if( tooFar, endPos, newPos )]
<!-- ------------------------------------------------------>

[h, if(newPos != currentPos), CODE:{
	[if(rotating), CODE:{
		<!-- ROTATING -->
		[setTokenFacing(newPos, me)]
		[if(doubleDoor && choice == "fullVBL"): setTokenFacing(2*doubleDoorParam - newPos, me+"a")]
	}; {
		<!-- SLIDING -->
		[moveToken(if(xDirection, newPos, otherPos), if(xDirection, otherPos, newPos), 1, me)]

		[if(debug), CODE:{
			[currDX	= getTokenX(1, me+'a')]
			[currDY	= getTokenY(1, me+'a')]
			[bot_debugInfo("doubleDoor, choice, xDirection, doubleDoorParam, newPos, me, otherPos, currDX, currDY", 1)]
		};{}]

		[if(doubleDoor && choice == "fullVBL"): moveToken(if(xDirection, doubleDoorParam - newPos, getTokenX(1, me+'a')), if(xDirection, getTokenY(1, me+'a'), doubleDoorParam - newPos), 1, me+"a")]
	}]
}]

<!-- ------------------------------------------------------>

<!-- Check if animation is finished -->
[H, if(newPos != endPos && newPos != endPos ), code: {
	<!-- if not, rotate door yet another step -->
	[args = strformat("
			me				= %{me}; 
			rotating		= %{rotating}; 
			startTime		= %{startTime}; 
			endTime			= %{endTime}; 
			currentStepSize	= %{currentStepSize}; 

			startPos		= %{startPos}; 
			endPos			= %{endPos}; 
			newPos			= %{newPos}; 

			doubleDoorParam	= %{doubleDoorParam}; 
			doubleStartPos	= %{doubleStartPos}; 
			otherPos		= %{otherPos}; 
			xDirection		= %{xDirection}; 
			openMethod		= %{openMethod}; 
			choice			= %{choice}; 
			drawVBL			= %{drawVBL};
			
			doubleDoor		= %{doubleDoor}; 
			mainDoor		= %{mainDoor}
	")]
	[link = macroLinkText("deferToggleDoor@lib:onTokenMove","none",args)]
	[execLink(link,1)]
}; {
	<!-- delete the animated door and make the maindoor visible again. but not if you are the initiator in which case me = maindoor and maindoor = '' -->
	[if(mainDoor != ""), CODE:{
		[setOwnerOnlyVisible(0, mainDoor)]
		[if(doubleDoor): setOwnerOnlyVisible(0, mainDoor + 'a')]
		[removeToken(me)]
		[if(doubleDoor): removeToken(me + 'a')]
		<!-- only the initiator must set the VBL -->
		[doVBL	= 0]
	}; {
		<!-- if youre the only one running (or the initiator) also set the door visible again -->
		[numClients = listCount(getAllPlayerNames())]
		[if(numClients == 1):setOwnerOnlyVisible(0, me)]
		[doVBL	= 1]
	}]
	
	[if(drawVBL && doVBL), CODE:{
		[mainDoor		= me]
		[isClosed 		= bot_isDoorClosed(mainDoor)]
		[bot_moveStamp(me)]
		[if(doubleDoor): bot_moveStamp(me + 'a')]
	}; {}]
}]

[bot_resetTimer(1)]

@@isDoorClosed
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=7 ; color=default ; playerEditable=false ; applyToSelected=true ; group=5a. Door Animation ; tooltip= ; minWidth=90 ; 
[h:'<!-- ------------------------------------------- isDoorClosed --------------------------------------- -->']

[h,if(argCount() > 0):	mainDoor	= arg(0) ; mainDoor	= currentToken()]

[h:switchToken(mainDoor)]

<!-- switchId, openMethod, doubleDoor, description, closedAngle, openAngle, openDistance, animateTime, withSwitch, proximity, drawVBL, windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, halfOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpenDoorX, crackOpenDoorY, halfOpenDoorX, halfOpenDoorY, xDirection -->
[h:varsFromStrProp(getProperty("w42.bot.doorData"))]

[h,if(openMethod < 2):
	isClosed 		= if(bot_getTokenFacing(mainDoor) == closedAngle, 1, 0)
; 
	isClosed 		= if(getTokenX(1) == closedDoorX && getTokenY(1) == closedDoorY , 1, 0)
]

[r:macro.return = isClosed]

@@setDoor
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=99 ; color=darkgray ; playerEditable=false ; applyToSelected=true ; group=5a. Door Animation ; tooltip= ; minWidth=90 ; 
[h: '<!-- --------------------------------------- setDoor Stamp version---------------------------------------------->']

[h:mainDoor			= getSelectedNames()]
[h:assert(listCount(mainDoor)==1,"Make sure (only) one token is selected",0)]
[h:switchToken(mainDoor)]

[h:currentAngle		= bot_getTokenFacing(mainDoor)]
[h:currentJavaAngle	= bot_getTokenFacing(mainDoor, 1)]
[h:openDistance		= bot_getGridSize()]

[h:initList			= strformat(
'switchId="";
 openMethod=0;
 doubleDoor=0;
 addGMMote=1;
 description="";
 closedAngle=%{currentAngle};
 currentVBLAngle=0;
 openAngle=160;
 openDistance=%{openDistance};
 animateTime=2000;
 withSwitch=0;
 proximity=0;
 drawVBL=1;
 windowVBL=0;
 keyholeVBL=0;
 crackVBL=0;
 halfVBL=0;
 fullVBL=1;
 stepSize=0;
 crackStepSize=0;
 halfStepSize=0;
 doubleDoorParam=0;
 totalOpenAngle=0;
 crackOpenAngle=0;
 halfOpenAngle=0;
 closedDoorX=0;
 closedDoorY=0;
 openDoorX=0;
 openDoorY=0;
 crackOpenDoorX=0;
 crackOpenDoorY=0;
 halfOpenDoorX=0;
 halfOpenDoorY=0;
 xDirection=0;
 onOpen=0; 
 onClose=0;
 isClosed=1;
 choice= "fullVBL";
')]

<!-- FIRST initialize ALL vars -->
[h:varsFromStrProp(initList)]

<!-- look for potential double door -->
[h:doubleDoor		= if(findToken(mainDoor+"a") != "", 1, 0)]

<!-- THEN initialize any values already stored on the door -->
[h:varsFromStrProp(getProperty("w42.bot.doorData"))]

[h: isLocked		= if(getState("Locked"), 1, 0)]

<!-- setup macro event link -->
[h:oldMap			= getCurrentMapName()]
[h:setCurrentMap(getLibProperty("baseMapName", "lib:EventMacros"))]
	[h:macroIDList		= getMacroGroup("Event Door Macros", ",", "lib:EventMacros")]
	<!-- create macro list from the Event Button Macros group -->
	[h:macroNameList	= "<none>"]
	[h,foreach(id, macroIDList): macroNameList = listAppend(macroNameList, getStrProp(getMacroProps(id, "; ", "lib:EventMacros"),"label"))]
[h:setCurrentMap(oldMap)]

[h:macroName		= getProperty("w42.bot.macroName")]
[h,if(macroName == ""): macroName = "name of macro"]
[h:eventTypeList	= getProperty("w42.bot.eventTypeList")]
[h:vblSupport		= getLibProperty('vblSupport','lib:EventMacros')]
[h:drawVBL			= if(drawVBL && vblSupport, 1, 0)]
[h:triggerTypeList	= "onOpen, onClose"]
[h,foreach(event, eventTypeList): set(event, 1)]
[h,if(listContains(macroNameList, macroName)):currentMacro = listFind(macroNameList,macroName) ; currentMacro = 0]

[h:											warning = ""]
[h,if(closedAngle != currentAngle):			warning = "It appears there is already a value set for 'Closed Angle' ("+closedAngle+") and this does NOT correspond with the current angle ("+currentAngle+") of the door. If you are installing a new door and its currently in the 'closed' position, then change the value for 'closed angle' in the next input box to: "+ currentAngle]
[h,if(getTokenWidth() != getTokenHeight()):	warning = listAppend(warning, "The image you are using is NOT square. IF you are using VBL then this may result in pieces of VBL remaining on the map. The easiest solution is to set the door to a preset size like 'Large'.", "<br><br>")]
[h,if(warning != ""):						pause("warning")]

<!-- get the VBL under the door -->
[h:hasVbl		= !json.isEmpty(json.get(json.get(bot_VBLGrenade(1,0),0),"points"))]
[h:removeVBL	= 0]

[h: abort(input(
	if(vblSupport, "tab0|Door option|| TAB", ""),
	"junk|<html><font color=red><b>MAKE SURE THAT</b><br>
		- the door is in the CLOSED position<br>
		- for SLIDING doors: SNAP TO GRID is TURNED OFF<br>
		- when using VBL: there is NO VBL where the door-opening is.<br>
		- when using VBL: the UNROTATED* door image has the HINGES at the CENTRE and has the HANDLE on the EAST side<br>
		*Unrotated: right mouseclick --> clear facing.<br>
		Note that you *can* rotate the door in any direction you like BEFORE you use this macro, but the UNROTATED IMAGE <br>
		must fullfill the above requirements!!<br>
		</font></html>|-|LABEL|SPAN=TRUE",
	"junk|<html><b>Door Properties</b></html>|-|LABEL|SPAN=TRUE",
	"openMethod|Anti Clockwise, Clockwise, Slide to left, Slide to Right, Slide North, Slide South|How does the door open?|RADIO|SELECT="+openMethod,
	"doubleDoor|"+doubleDoor+"|Double door? (if checked make sure that there is another door with the name: "+token.name+"a)|CHECK",
	"addGMMote|"+addGMMote+"|Add Door name to GM Notes|CHECK",
	"description|"+description+"|Description of door (This appears in the toggle doors macro) (set to 0 for no description)",

	"junk|<html><i>Rotating Door</i></html>|-|LABEL|SPAN=TRUE",
	"closedAngle|"+closedAngle+"|Set the angle for closed door (number between 0 and 360)(current angle is give here)",
	"openAngle|"+openAngle+"|How many degrees does the door turn to open (typically 90 degrees)",

	"junk|<html><i>Sliding Door</i></html>|-|LABEL|SPAN=TRUE",
	"openDistance|"+openDistance+"|How much does the door slide away (in distance per cell e.g.: 50)",
	"junk|<html><b>Animation Properties</b></html>|-|LABEL|SPAN=TRUE",
	"animateTime|"+animateTime+"|How much time does it take for the door to open in milli seconds (set to 0 for no animation)",

	"junk|<html><b>Door Switch Button</b></html>|-|LABEL|SPAN=TRUE",
	"withSwitch|"+withSwitch+"|Add a switch to the door, this will summon a 'switch' token to the door?|CHECK",
	"isLocked|"+isLocked+"|Lock door? (When a door is locked only the GM can open it)|CHECK",
	"proximity|"+proximity+"|Proximity of Player token to switch (set to 0 to not check proximity)?",

	"junk|<html><b>Macro run on trigger (only works with switch)</b><br>Note that only the macros from the group: 'Event Button macros' on 'Lib:EventMacros' are in the drop downlist</html>|-|LABEL|SPAN=TRUE",
	"macroName|"+macroNameList+"|<html><span title='<html><b>Enter here the name of the macro that is used when this door is opened or closed.</html>'>Name of event macro</html></span></html>|LIST|SELECT="+currentMacro,

	"junk|<html><b>Which event triggers the macro</b></html>|-|LABEL|SPAN=TRUE",
	"onOpen|"+onOpen+"|<html><span title='<html><b>When checked:</b> The macro associated with this door,<br>will be triggered when the door is <b>opened</b></html>'>Door is opened</html></span></html>|CHECK",
	"onClose|"+onClose+"|<html><span title='<html><b>When checked:</b> The macro associated with this door,<br>will be triggered when the door is <b>closed</b></html>'>Door is closed</html></span></html>|CHECK",
	
	if(vblSupport, "tab1|VBL Options|| TAB", ""),
	if(vblSupport, "junk|<html><b>The below options are ONLY availabel if you check 'VBL for doors'</b></html>|-|LABEL|SPAN=TRUE", ""),
	if(vblSupport, "drawVBL|"+drawVBL+"|Use vision blocking for door|CHECK", ""),
	if(vblSupport && hasVbl, "removeVBL|0|<html><span title='<html><b>When checked: ALL VBL on the ENTIRE token will be erased (so not only the door line)</html>'>Remove current VBL on door</html></span></html>|CHECK", ""),
	if(vblSupport, "junk|<html><b>When you check any of these a menu will pop-up when you toggle the door</b><br>Players are allowed to:</html>|-|LABEL|SPAN=TRUE", ""),
	if(vblSupport, "windowVBL|"+windowVBL+"|peek through a window in the door|CHECK", ""),
	if(vblSupport, "keyholeVBL|"+keyholeVBL+"|peek through the key hole|CHECK", ""),
	if(vblSupport, "crackVBL|"+crackVBL+"|crack the door and peek|CHECK", ""),
	if(vblSupport, "halfVBL|"+halfVBL+"|open the door half way|CHECK", ""),
	if(vblSupport, "fullVBL|"+fullVBL+"|open the door fully|CHECK", "")
))]

<!-- make sure that if drawVBL is set that at least 1 choice is set. -->
[h,if(drawVBL && !sum(windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL)): fullVBL  = 1]

<!-- idiot checks and setting properties -->
[h:description = if(description == 0, "", description))]
[h:propList = "closedAngle, openAngle, openMethod, animateTime, doubleDoor, drawVBL, openDistance, windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL"]
[h,foreach(prop, propList): assert(isNumber(eval(prop)), "Please fill in a number for: "+prop+", even if its not used",0)]

[h:assert(closedAngle	>= 0	&& closedAngle	<= 360,	"Please enter a number between 0 and 360 for the 'angle for closed door'",0)]
[h:assert(openAngle		>= 0	&& openAngle	<= 360,	"Please enter a number between 0 and 360 for the 'angle for open door'",0)]
[h:assert(openDistance	>= 0,							"Please enter positive number for how far the doors slides away",0)]
[h:assert(animateTime	>= 10	&& animateTime	<= 10000 || animateTime == 0,	"Please enter a number between 10 and 10000 for the 'Rotation time', or set to 0 for no rotation",0)]
[h:doubleDoorName = findToken(token.name+"a")]
[h:assert(!doubleDoor || (doubleDoor && doubleDoorName != "") ,	"No <b>"+token.name+"a</b> found on map, either change the double door to the correct name or uncheck the box.",0)]

<!-- set other properties -->
[h:currentVBLAngle	= currentJavaAngle]
[h:currentX			= getTokenX(1, mainDoor)]
[h:currentY			= getTokenY(1, mainDoor)]
[h:closedDoorX		= currentX]
[h:closedDoorY		= currentY]
<!-- set the door shape to TOP DOWN -->
[h,if(vblSupport): setTokenShape("TOP DOWN", mainDoor)]

[h, if(openMethod < 2), CODE:{
	<!-- rotating door -->
	[stepSize		=  openAngle/animateTime]
	[crackStepSize	= 10/animateTime]
	[halfStepSize	= 45/animateTime]
	[doubleDoorParam= closedAngle + if(openMethod, -90, 90)]
	[totalOpenAngle	= mod(closedAngle + if(openMethod, -1, 1)*openAngle,360)]
	[crackOpenAngle	= mod(closedAngle + if(openMethod, -1, 1)*10,360)]
	[halfOpenAngle	= mod(closedAngle + if(openMethod, -1, 1)*45,360)]
	
	[startPos		=  closedAngle]
	[endPos			=  closedAngle]
	[doubleStartPos	=  closedAngle + 180]
	[doubleEndPos	=  doubleStartPos]
};{
	<!-- sliding door -->
	[stepSize		= openDistance/animateTime]
	[crackStepSize	= (openDistance/10)/animateTime]
	[halfStepSize	= (openDistance/2)/animateTime]

	[xDistance		=  0]
	[yDistance		=  0]
	<!-- 2=left, 3=right, 4=north, 5=south -->
	[switch(openMethod):
		case 2: xDistance	= - openDistance; 
		case 3: xDistance	= + openDistance; 
		case 4: yDistance	= - openDistance; 
		case 5: yDistance	= + openDistance; 
	]
	[openDoorX		= currentX + xDistance]
	[openDoorY		= currentY + yDistance]
	['pause("openMethod","currentX","currentY","closedDoorX","closedDoorY","openDoorX","openDoorY","openDistance","xDistance","yDistance")']
	[crackOpenDoorX	= currentX + floor(xDistance/10)]
	[crackOpenDoorY	= currentY + floor(yDistance/10)]
	[halfOpenDoorX	= currentX + floor(xDistance/2)]
	[halfOpenDoorY	= currentY + floor(yDistance/2)]
	
	[xDirection		=  if(openMethod < 4, 1, 0)]
	[if(doubleDoorName	== ""): doubleDoorName	=  token.name]
	[if(xDirection):
		doubleDoorParam	= getTokenX(1,doubleDoorName) + currentX)
	; 
		doubleDoorParam	= getTokenY(1,doubleDoorName) + currentY)
	]

}]

<!-- setup double door -->
[h,if(doubleDoor): setProperty("w42.bot.doorData",	"closedDoorX="	+getTokenX(1,doubleDoorName)+
													";closedDoorY="	+getTokenY(1,doubleDoorName)+
													";currentVBLAngle="	+bot_getTokenFacing(doubleDoorName, 1), doubleDoorName)
]
<!-- set the double door shape to TOP DOWN -->
[h,if(vblSupport && doubleDoor): setTokenShape("TOP DOWN", doubleDoorName)]

<!-- setup token switch -->
[h,if(withSwitch && findToken(switchId) == ""), CODE:{
	[baseMap		= getLibProperty("baseMapName", "lib:EventMacros")]
	[switchId		= copyToken("DoorLeverToken", 1, baseMap, strformat("{x:'%s', y:'%s'}", getTokenX(0), getTokenY(0)))]
	[tmpbuttonArgs	= setStrProp("", "leverToken", switchId)]
	[tmpbuttonArgs	= setStrProp(tmpbuttonArgs, "mainDoor", mainDoor)]
	[tmpbuttonArgs	= setStrProp(tmpbuttonArgs, "proximity", proximity)]
	[tmpbuttonArgs	= setStrProp(tmpbuttonArgs, "macroToCall", "operateLever@this")]
	[message  		= "This pause is unfortunately necessary for the door lever to work. Press ok to continue. A switch will appear close to the door, you can place this anywhere you want. You can also resize it or change its image."]
	[pause("message")]
	[setProperty("buttonArgs", tmpbuttonArgs, switchId)]
	[switchId		= getName(switchId)]
}; {
	[if(withSwitch), CODE:{
		[tmpbuttonArgs	= getProperty("buttonArgs", switchId)]
		[tmpbuttonArgs	= setStrProp(tmpbuttonArgs, "proximity", proximity)]
		[setProperty("buttonArgs", tmpbuttonArgs, switchId)]
	}]
}]

<!-- lock the door is set to such -->
[h:setState("Locked",isLocked)]

<!-- add gm Note -->
[h, if(addGMMote), CODE:{
	[GMNote = "<b>" + token.name + "</b><br>"]
	[if(getGMNotes() == ""): setGMNotes("<b>" + token.name + "</b><br>")]
};{}]

<!-- setup the macro link -->
[r, if(macroName), CODE:{
	[h:macroName		= listGet(macroNameList, macroName)]
	[h:setProperty("w42.bot.macroName", macroName)]
	[h:eventTypeList	= ""]
	[h,foreach(event, triggerTypeList), if(eval(event)): eventTypeList = listAppend(eventTypeList, event)]
	[h:setProperty("w42.bot.eventTypeList", eventTypeList)]
	[r,gm: "The Macro <u>"+macroName+"</u> is now linked to the following token(s)<u> "+mainDoor+"</u>. This macro will be executed when one of the following events are triggered: <u>"+eventTypeList+"</u>"]
	<br><br>
}; {
	[h:setProperty("w42.bot.macroName", "")]
}]

[h:propList		= "switchId, openMethod, doubleDoor, addGMMote, description, closedAngle, currentVBLAngle, openAngle, openDistance, animateTime, withSwitch, proximity, drawVBL, windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, halfOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpenDoorX, crackOpenDoorY, halfOpenDoorX, halfOpenDoorY, xDirection"]

[h:setProperty("w42.bot.doorData", strPropFromVars(propList, "UNSUFFIXED"), mainDoor)]

<!-- remove current VBL on the door VBLGrenade (tokOnly (1/0), clearVBL(1/0), tok)-->
[h,if(removeVBL): bot_VBLGrenade(1,1, mainDoor)]
[h,if(removeVBL && doubleDoor): bot_VBLGrenade(1,1, doubleDoorName)]

<!-- draw VBL on the door (this function uses the doorData so it has to AFTER that is set) -->
[h,if(drawVBL), CODE:{
	<!-- define the following vars for createVBL: applyVBL,VBLType,scaleX,scaleY,offsetX,offsetY,thickness,scale, fill, close, sides, centreOffset, resetFoW, rxOffset, ryOffset -->
	[xOffset	= round(getTokenWidth() / 2, 0)]

	[vblSetup	= strformat(
		"applyVBL=1; VBLType=3; scaleX=100; scaleY=100; offsetX=%{xOffset}; offsetY=0; thickness=2; fill=0; scale=0.5; close=0; sides=6; centreOffset=0; resetFoW=1; rxOffset=0; ryOffset=0;"
	)]

	<!-- get the new VBL settings and apply the new VBL cross to its current position -->
	[setProperty("w42.bot.vblSetup", vblSetup, mainDoor)]

	['checkCurrentVBL	= bot_createVBL(mainDoor,1)']
	['if(!json.isEmpty(checkCurrentVBL)), CODE:{
		[abort(input(
			"junk|<html>Setup detected VBL on the spot where the door VBL will be placed.<br>If this is your intention press ok. If you forgot to remove the<br>VBL before you set this door up, then press cancel and remove it manually?</html>|-|LABEL|SPAN=TRUE"
			"removeVBL|1|Erase the VBL|CHECK"
		))]
		[if(removeVBL): eraseVBL(checkCurrentVBL)]
	}']
	<!-- createVBL (tok,check for vbl,isDoor) -->
	[bot_createVBL(mainDoor,0,1)]
	[if(doubleDoor): bot_createVBL(doubleDoorName,0,1)]
}]

Door is successfully setup.
[selectTokens(mainDoor)]

@@setVBLDoor
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=7 ; color=default ; playerEditable=false ; applyToSelected=true ; group=5a. Door Animation ; tooltip= ; minWidth=90 ; 
[h:'<!-- ------------------------------------------- setVBLDoor --------------------------------------- -->']
<!-- IGNORE OUTPUT, NO NEW SCOPE -->

<!-- USED FOR KEY HOLE AND WINDOW -->

<!-- the following assumptions are currently made:
For a token with NO facing: The Hinge of the door starts in the centre of the total image and the door runs right. That means that the doorknob is in the right/east side. 
-->

<!-- How does this work: as ALL doors start in the centre and point east you ONLY need to keep track of whether its opened/closed, sliding/rotating and it current angle. 

For rotating doors you can simply erase the VBL of where it WAS and draw the VBL of where is IS. As the x/y coords never changes only the facing, you only need to erase the start angle and draw the end angle

For sliding doors you only need to erase when it opens and draw when it closes. The spot where it draws/erases is ALWAYS THE SAME so you need the x/y coords of the closed position together with its facing angle and with that you can draw/erase when it closes/opens

For keyhole and windows it works the same as sliding only the area is defined smaller. 
 -->

<!-- currently for vbl to work a token MUST ben impersonated -->
[h,if(argCount() > 0): mainDoor = arg(0)]
[switchToken(mainDoor)]
[gridSize	= json.get(json.get(getInfo("map"), "grid"), "size")]

<!-- switchId, openMethod, doubleDoor, description, currentVBLAngle, closedAngle, openAngle, openDistance, animateTime, withSwitch, proximity, drawVBL, windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, halfOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpenDoorX, crackOpenDoorY, halfOpenDoorX, halfOpenDoorY, xDirection -->
[varsFromStrProp(getProperty("w42.bot.doorData"))]
<!-- initiate variables -->
[varsFromStrProp("r=0; points=[]; scale=1; thickness=2; fill=0; close=0; x=0;y=0;w=0;h=0")]

[shape	= "polygon"]
[doorX	= closedDoorX]
[doorY	= closedDoorY]
[xOffset= round(getTokenWidth() / 2, 0)]
[rx		= doorX + xOffset] <!-- rotational offset -->
[ry		= doorY + round(getTokenHeight() / 2, 0)]
[x1		= rx+2] <!-- the + 2 is to prevent the erase function form cutting in the vbl wall -->
[x2		= doorX + getTokenWidth()]
[y1		= ry]
[y2		= ry]

<!-- calculate the X coords of the door. -->
[h,switch(choice),CODE:
	case "keyholeVBL": {
		<!-- key hole 1 pixel per 50 pixes grid-->
		[mDoor		= rx + round(getTokenWidth() / 4, 0)] <!-- x coord of centre of the door -->
		[width		= max(1, floor(gridSize/50))]
		[x1			= mDoor - width]
		[x2			= mDoor + width]
	}; 
	case "windowVBL": {
		<!-- window width 25% of cell -->
		[mDoor		= rx + round(getTokenWidth() / 4, 0)] <!-- x coord of centre of the door -->
		[width		= max(2, floor(gridSize/8))]
		[x1			= mDoor - width]
		[x2			= mDoor + width]
		['pause("mDoor","rx","x1","x2","width","gridSize")']	
	}; 
	default: {
		[error = "Unknown VBL choice: "+choice]
		[pause("error")]
	}
]

<!-- 'r' needs to be set depending on the current facing of the door. Default facing (== no facing) is 270. Since in this case we do NOT want to rotate the VBL; -->
[re 	= currentVBLAngle]
[rd 	= bot_getTokenFacing(mainDoor, 1)]

<!-- store new currentVBLAngle on door -->
[currentVBLAngle	= bot_getTokenFacing(mainDoor, 1)]
[setProperty("w42.bot.doorData", setStrProp(getProperty("w42.bot.doorData", mainDoor), "currentVBLAngle", currentVBLAngle), mainDoor)]

<!-- key hole or window, angle will remain unchanged so just need the current angle -->
[if(isClosed), CODE:{
	<!-- nothing needs to be erased -->
	[points1	= json.set("{ }", "x", 0, "y", 0) ]
	[points2	= json.set("{ }", "x", 0, "y", 0) ]
	[ePoints	= json.append('[]', points1, points2) ]			

	<!-- redraw door VBL where de door now is -->
	[points1	= json.set("{ }", "x", x1, "y", y1) ]
	[points2	= json.set("{ }", "x", x2, "y", y2) ]
	[dPoints	= json.append('[]', points1, points2) ]			
};{
	<!-- erase door VBL where the door originally was, so not current position !!-->
	[points1	= json.set("{ }", "x", x1, "y", y1) ]
	[points2	= json.set("{ }", "x", x2, "y", y2) ]
	[ePoints	= json.append('[]', points1, points2) ]			

	<!-- nothing needs to be drawn -->
	[points1	= json.set("{ }", "x", 0, "y", 0) ]
	[points2	= json.set("{ }", "x", 0, "y", 0) ]
	[dPoints	= json.append('[]', points1, points2) ]			
}]

[jsonVBL = "[]"]
['VBLData = json.fromStrProp(strPropFromVars("shape, x, y, w, h, points, r, scale, thickness, fill, close", "UNSUFFIXED"))']
[eShape		= json.set("{ }", "shape", "polygon", "rx", rx, "ry", ry, "r", re, "close", 0, "thickness", 2, "scale", 1, "points", ePoints)] 
[dShape		= json.set("{ }", "shape", "polygon", "rx", rx, "ry", ry, "r", rd, "close", 0, "thickness", 2, "scale", 1, "points", dPoints)] 

[eJsonVBL	= json.append(jsonVBL, eShape)]	
[dJsonVBL	= json.append(jsonVBL, dShape)]	

['pause("eJsonVBL","dJsonVBL", "isClosed", "doubleDoor", "choice")']
[eraseVBL(eJsonVBL)]
[drawVBL(dJsonVBL)]

[selectTokens(getTokens(",", '{ pc:1 }'),1,",")]
[exposeFOW()]
[deselectTokens()]

@@toggleDoor
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=1 ; color=darkgray ; playerEditable=false ; applyToSelected=true ; group=5a. Door Animation ; tooltip= ; minWidth=90 ; 
[h: '<!-- ----------------------------------------- toggleDoor -------------------------------------------------------------->']
[h: debug = 0]

[h,if(argCount() == 4), CODE: {
	<!-- a trigger button is used next to the door -->
	[mainDoor 		= getName(arg(0))]
	[closeEnough	= arg(1)]
	<!-- name of the token operating the door -->
	[operator		= arg(2)]
	[tokList		= arg(3)]
}; {
	<!-- door is openened with a macro (likely by the gm) -->
	[if(macro.args != ""):mainDoor = "Door "+arg(0); mainDoor = getSelectedNames()]
	[assert(listCount(mainDoor)==1, "Make sure (only) one door is selected",0)]
	[closeEnough	= 1]
	[operator		= ""]
}]

<!-- INITIALIZE VALUES -->
[h:onlinePlayers		= getAllPlayerNames()]
[h:thisPlayer			= getPlayerName()]
[h:animationPerClient	= getLibProperty("animationPerClient", "lib:EventMacros")]
[h:vblSupport			= getLibProperty('vblSupport','lib:EventMacros')]
[h:byStanders			= listDelete(onlinePlayers, listFind(onlinePlayers, thisPlayer))]
[h,if(animationPerClient): otherPlayers = byStanders; otherPlayers = ""]

<!-- switchId, openMethod, doubleDoor, description, closedAngle, openAngle, openDistance, animateTime, withSwitch, proximity, drawVBL, windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, halfOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpenDoorX, crackOpenDoorY, halfOpenDoorX, halfOpenDoorY, xDirection -->
[h:varsFromStrProp(getProperty("w42.bot.doorData", mainDoor))]
[h:drawVBL				= if(drawVBL && vblSupport, 1,0)]
<!-- MAKE ASSERTIONS -->
[H:assert(listCount(mainDoor)==1,	"Make sure (only) one token is selected",0)]
[h:assert(closeEnough || isGM(),	"You are standing too far away from the switch to operate it",0)]
[h:assert(animateTime != "",		"Please set the value 'time to open' of the door first (select the door and run 'set door' on the campaign panel)",0)]
[h:assert(openMethod != "",			"It looks like this door is not setup for animation. Please do this first(select the door and run 'set door' on the campaign panel)",0)]
[h:assert(closedAngle != "",		"Please set the value closed angle of the door first (select the door and run 'set door' on the campaign panel)",0)]
[h:assert(!( getState("Locked",mainDoor) && !isGM() ),	"The door is locked",0)]

[h:isClosed 			= bot_isDoorClosed(mainDoor)]

<!-- STOP KEY HOLE OR WINDOW VIEW -->
[h:choice	= getProperty("clearedVBL", mainDoor)]
[h,if(choice == "windowVBL" || choice == "keyholeVBL"), CODE:{
	[isClosed		= 1]
	[setProperty("clearedVBL", "", mainDoor)]
	['pause("choice","choice","windowVBL","keyholeVBL","closedAngle")']
	<!-- needed params: closedAngle, isClosed, mainDoor, openMethod, choice -->
	[bot_setVBLDoor()]
	[abort(0)]
}; {}]

<!-- DOOR EVENT TRIGGER -->
<!-- if an event is linked to the door being operated -->
[h:macroName		= getProperty("w42.bot.macroName", mainDoor)]
[h,if(macroName != "" && operator != ""),CODE:{
	[tokList		= listDelete(tokList, listFind(tokList, operator))]
	[eventTypeList	= getProperty("w42.bot.eventTypeList", mainDoor)]
	[eventType		= if(isClosed, "doorIsOpened", "doorIsClosed")]
	[triggered		= listContains(eventTypeList, eventType)]
	
	[args			= json.append("", operator, thisPlayer, tokList, byStanders, mainDoor, 'door', isClosed, getState("Locked",mainDoor))]
	[macro(macroName+"@Lib:EventMacros"): args]
}; {
	[macro.return=""]
}]

<!-- CHECK VBL OPTIONS -->
[h,if(drawVBL && !isClosed && choice == "" || !drawVBL): choice = "fullVBL"]
[h,if(drawVBL && isClosed), CODE:{
	[nothing	= 1]
	[propList	= "nothing, windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL"]
<!-- @@@@leave out until repaired!!! -->
['windowVBL = 0']
['keyholeVBL = 0']
	[if(windowVBL+keyholeVBL+crackVBL+halfVBL+fullVBL > 1), CODE:{
		[optionList = ""]
		[choices	= "Do nothing, Peek through the window, Peek through the key hole, Crack the door open, Open the door halfway, Open the door all the way"]
		[foreach(item, propList): optionList = if(eval(item), listAppend(optionList, listGet(choices, roll.count)), optionList)]
		<!-- some menu is required -->
		[abort(input(
			strformat("junk|<html><b>%{mainDoor} %s</b></html>|-|LABEL|SPAN=TRUE", if(description != "", "("+description+")", "")),
			"choice|"+optionList+"|You...|RADIO|VALUE=STRING"
		))]
		[choice		= listGet(propList, listFind(choices, choice))]
		[abort(if(choice == "nothing", 0,1))]
	}; {
		<!-- no menu is required, set choice to the only value set -->
		[choice = ""]
		[foreach(item, propList): choice = if(eval(item), item, choice)]
		<!-- when no choice is set at all set it to full vbl (door full open -->
		[if(choice == ""):choice = "fullVBL"]
	}]
}; {}]

[h:setProperty("clearedVBL", choice, mainDoor)]
[h:'pause("choice")']

<!-- PROCESS VBL OPTIONS: KEYHOLE AND WINDOW -->
[h,if(choice == "windowVBL" || choice == "keyholeVBL"), CODE:{
	<!-- needed params: closedAngle, isClosed, mainDoor, openMethod, choice -->
	[isClosed		= 0]
	['pause("choice","choice","windowVBL","keyholeVBL","closedAngle")']
	[bot_setVBLDoor()]
	[abort(0)]
}; {}]

<!-- openMethod: <2 = rotating (CCW 0/CW 1); >=2 = sliding (W 2/E 3/N 4/S 5)-->
[h,if(!animateTime && openMethod < 2), CODE:{
	<!-- ROTATING DOOR-->
	[direction	= if(openMethod, -1, 1)]
	[startPos	= bot_getTokenFacing(mainDoor)]
	[endPos		= if(isClosed, getProperty("totalOpenAngle", mainDoor), closedAngle)]
	[if(choice == "crackVBL"):	endPos = crackOpenAngle]
	[if(choice == "halfVBL"):	endPos = halfOpenAngle]
	
	<!-- toggle the door -->
	[setTokenFacing(endPos, mainDoor)]
	[isClosed 		= 1 - isClosed]
	[if(doubleDoor && choice == "fullVBL"), CODE:{
		[doubleStartPos		= bot_getTokenFacing(mainDoor+'a')]
		[setTokenFacing(doubleEndPos, mainDoor+"a")]
	}; {
		[doubleOldPos		= 0]
	}]

	[if(drawVBL): bot_moveStamp()]
	[abort(0)]
}; {}]

[h,if(!animateTime && openMethod >= 2), CODE:{
	<!-- SLIDING DOOR-->
	<!-- toggle the door -->
	[if(choice == "crackVBL"), CODE:{
		[if(isClosed): moveToken(crackOpenDoorX, crackOpenDoorY, 1, mainDoor)	; moveToken(closedDoorX, closedDoorY, 1, mainDoor) ]
	}; {}]
	[if(choice == "halfVBL"), CODE:{
		[if(isClosed): moveToken(halfOpenDoorX, halfOpenDoorY, 1, mainDoor)		; moveToken(closedDoorX, closedDoorY, 1, mainDoor) ]
	}; {}]
	[if(choice == "fullVBL"), CODE:{
		[if(isClosed): moveToken(openDoorX, openDoorY, 1, mainDoor)				; moveToken(closedDoorX, closedDoorY, 1, mainDoor) ]
	}; {}]

	[if(doubleDoor && choice == "fullVBL"), CODE:{
		[xDirection	= if(openMethod < 4, 1, 0)]
		[newXPos	= if(isClosed, openDoorX, closedDoorX)]
		[newYPos	= if(isClosed, openDoorY, closedDoorY)]
		[DDoorX		= if(xDirection, doubleDoorParam - newXPos, getTokenX(1, mainDoor+'a'))]
		[DDoorY		= if(xDirection, getTokenY(1, mainDoor+'a'), doubleDoorParam - newYPos)]
		[moveToken(DDoorX, DDoorY, 1, mainDoor+"a")]
	}]
	[isClosed 	= 1 - isClosed]
	[if(drawVBL):bot_moveStamp()]
	
	[if(debug): bot_debugInfo("animateTime, openMethod, choice, isClosed, crackOpenDoorX, crackOpenDoorY, mainDoor, closedDoorX, closedDoorY, xDirection, doubleDoor, xDirection, newXPos, newYPos, DDoorX, DDoorY, doubleDoorParam",0)]
	[abort(0)]
}; {}]

[h,if(animationPerClient), CODE:{
	[h:setOwner(thisPlayer, mainDoor)]
	[h:setOwnerOnlyVisible(1, mainDoor)]
	[h,if(doubleDoor), CODE:{
		[setOwner(thisPlayer, mainDoor + 'a')]
		[setOwnerOnlyVisible(1, mainDoor + 'a')]
	}; {}]
}; {}]

[h:currentMap	= getCurrentMapName()]
[h:args			= json.append("[]",mainDoor,"",currentMap, choice, isClosed)]
[h,macro('deferToggleDoor@Lib:OnTokenMove'): args]

[h,foreach(tokenOwner, otherPlayers), CODE:{
	[door = getName(copyToken(mainDoor))]
	[setOwnerOnlyVisible(1, door)]
	[setOwner(tokenOwner, door)]

	[h,if(doubleDoor), CODE:{
		[idDoor = copyToken(mainDoor + 'a')]
		[dDoor = door + 'a']
		[token(idDoor): token.name = dDoor]
		[setOwnerOnlyVisible(1, dDoor)]
		[setOwner(tokenOwner, dDoor)]
	}; {}]

	[args = json.append("[]",door, mainDoor, currentMap, choice, isClosed)]
	[broadcast(macroLink("<color='white'>", 'deferToggleDoor@Lib:OnTokenMove', 'none', args,tokenOwner))]
}]

@@toggleDoors
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=2 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=5a. Door Animation ; tooltip=<html>This will show a pop-up with all the initialized doors<br>on the OBJECT LAYER. Here you can select which to open/close ; minWidth=90 ; 
[h:'!<!-- -----------------------------------------toggleDoors ------------------------------------------------------>']
<!-- <html>This will show a pop-up with all the initialized doors<br>on the OBJECT LAYER. Here you can select which to open/close -->
[h:'<!-- create a list of doors on the object layer that have been set for animation-->']
[h:tokens	= getTokenNames(",",'{"layer":"OBJECT"}')]
[h:me		= getSelectedNames()]
[h:showClosestOnly	= if(!isGM() || me != "", 1, 0)]
[h, if(showClosestOnly):assert(listCount(me) == 1, "Make sure (only) one token is selected",0)]
[h:Doors	= ""]
[h, foreach(tok, tokens),CODE:{
	[if(startsWith(tok, "Door ") && getProperty("w42.bot.doorData", tok)!="" && !endsWith(tok, "a")): Doors = listAppend(Doors, tok)]
}]

[h: assert(Doors != "","There are no doors set on the object layer of this map",0)]

[h:Doors = listSort(Doors, "N+")]

[h:'<!-- Create list of door identifiers -->']
[h:iDoors				= ""]
[h:descriptionsDoors	= ""]
[h:playerDoors			= ""]
[h,foreach(door, Doors), CODE:{
	[id					= substring(door, 5)]
	[description		= getStrProp(getProperty("w42.bot.doorData",door),"description")]
	[iDoors				= listAppend(iDoors, id)]
	[varsFromStrProp(getProperty("w42.bot.doorData", door))]
	<!-- if player: only add doors within proximity -->
	[if(showClosestOnly), CODE:{
		[proximity		= getStrProp(getProperty("w42.bot.doorData",door),"proximity")]
		[distance		= getDistance(me, 1, door)]
		[descriptionsDoors	= listAppend(descriptionsDoors, strformat("(%{id}) %{description}"))]
		[if((distance <= proximity || proximity == 0) && getVisible(door)): playerDoors		= listAppend(playerDoors, door)]
	};{
		[descriptionsDoors	= listAppend(descriptionsDoors, strformat("(%{id}) %{description}"))]
	}]
}]

[h,if(showClosestOnly): usableDoors = playerDoors; usableDoors = Doors]

[h:'<!-- turn this list into an input string -->']
[h:inputStr	= "junk|<html><b>Toggle Doors - (name of the door) Description given</b><br></html>|-|LABEL|SPAN=TRUE"]
[h,if(usableDoors == ""):inputStr	= listAppend(inputStr, "junk|<html><b><font color=red>"+if(showClosestOnly, "You are too far from any door to open", "There are no doors on this map")+"</font></b><br></html>|-|LABEL|SPAN=TRUE", "@")]

[h,foreach(door, Doors), if(listContains(usableDoors, door)), CODE:{
		[newStr = "door" + roll.count + "|0|" + listGet(descriptionsDoors, roll.count) + "|CHECK"]
		[inputStr = listAppend(inputStr, newStr,"##")]
};{
		[eval("door" + roll.count + "=0")]
}]

[h:'<!-- execute input string -->']
[h: abort(input(inputStr))]

[h:'<!-- process results, that is animate the chosen doors -->']
[h,foreach(door, Doors), CODE:{
	['if(eval("door" + roll.count)):bot_toggleDoor(listGet(iDoors, roll.count))']
	[if(eval("door" + roll.count)):execLink(macroLinkText("toggleDoor@lib:onTokenMove","none",listGet(iDoors, roll.count)),1)]
}]
[h:'!<!-- ---------------------------------------end toggleDoors ---------------------------------------------------->']

@@doShadowPad
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=11 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=3a. ShadowPads ; tooltip= ; minWidth=90 ; 
[h:'<!----------------------------- bot_doShadowPad -------------------------------->']
<!-- 
if both pads are occupied, shadowtokens are placed on the pads in their relative position. All shadowtokens are visible to owner only, so all the clients who participate in the shadow view can see the shadow tokens. The rest not. 
The following events should be set to trigger this event:
- movedOn  (activate)
- movedOff  (deactivate)
- movedRemain (move shadow)
- movedReturn (move shadow)
'p' stands for 'primary' which is where the currentToken has moved on
's' stands for 'secondary' which is the 'other' pad that is linked to the primary
-->

[h:me			= arg(0)]
[h:event		= arg(1)]
[h:padName		= arg(2)]

<!-- introduce the settings: canSelectShadowTok:  Object Layer(0), Token Layer(1), Token Layer and autoselect Main Token(2) -->
[h:varsFromStrProp(getLibProperty('toggles','lib:EventMacros'))]
[h:switchToken(me)]

<!-- retrieve the name of the linked pad -->
[h:sName		= if(bot_inStr(padName, "Ground"), "Floor", "Ground")]
[h:id			= getGroup(strfind(padName,"ShadowPad ([^\\s]+)"),1,1)]
[h:sPadname		= strformat("ShadowPad %{id} %{sName}")]

<!-- check if the pads were already activated -->
[h:pActive		= if(isNumber(getProperty("w42.bot.Active", padName)),getProperty("w42.bot.Active", padName),0)]
[h:sActive		= if(isNumber(getProperty("w42.bot.Active", sPadName)),getProperty("w42.bot.Active", sPadName),0)]

<!-- if the linked pad was already activated, get the tokens on that pad -->
[h,if(sActive == 1): sTokList	= getProperty("w42.bot.onPad", sPadName) ; sTokList = ""]

<!-- initialize tokList -->
[h:tokList		= ""]

[h,if(event == "movedOn"), CODE:{
	<!-- retrieve names of toks already on the pad and add the new one. Store this list on the pad -->
	[pTokList	= getProperty("w42.bot.onPad", padName)]
	[if(!listContains(pTokList, me)): pTokList	= listAppend(pTokList, me)]
	[setProperty("w42.bot.onPad", pTokList, padName)]
	[setProperty("w42.bot.Active", 1, padName)]
};{}]	

[h,if(event == "movedOff"), CODE:{
<!-- retrieve the names of toks already on the pad and remove this one from it. Store the new list on the pad -->
	[pTokList	= getProperty("w42.bot.onPad", padName)]
	[pTokList	= listDelete(pTokList, listFind(pTokList, me))]
	[setProperty("w42.bot.onPad", pTokList, padName)]
	<!-- if no toks on pad left, deactivate it -->
	[if(pTokList == ""):setProperty("w42.bot.Active", 0, padName)]
	
	<!-- if shadowmove is active: remove its shadow (as you just moved off) -->
	[if(pActive && sActive): bot_removeShadow(me)]
	[if(pTokList == "" && pActive && sActive), CODE:{
		<!-- if there are no tokens on this other pad then remove ALL shadow tokens -->
		[foreach(tok, sTokList): bot_removeShadow(tok)]
	};{}]
	
	[if(pTokList != "" && pActive && sActive), CODE:{
		<!-- if there are tokens left on this other pad then set their ownership to the participating clients (==those who own tokens participating) -->
		[viewingPlayers	= "[]"]
		[tokList	= listAppend(pTokList,sTokList)]
		[foreach(tok, tokList), if(isOwnedByAll(tok)): 
				viewingPlayers = json.union(viewingPlayers, getAllPlayerNames("json")) 
			;
				viewingPlayers = json.union(viewingPlayers, getOwners("json",tok))
		]
		[tokList	= listAppend(pTokList,sTokList)]
		[foreach(tok, tokList): setOwner(viewingPlayers, tok+" shadow")]
	};{}]
};{}]	

[h, if( event == "movedOn" && sActive), CODE:{
	<!-- if a new token moved on the shadow pad and on the other pad there is at least one token (iow both pads are activated) -->
	<!-- create a list of ALL tokens -->
	[tokList	= listAppend(pTokList,sTokList)]
	
	[if(pActive), CODE:{
		<!-- if the shadowpads are already active only the new token needs to be added. All the existing pads need the ownership changed to add the current player -->
		<!-- so retrieve the owners from one of the other shadow tokens from the other and add the owners(s) of me -->
		[others		= getOwners("json", listGet(sTokList, 0)+" shadow")]
		[if(isOwnedByAll(me)): 
			viewingPlayers = json.union(others, getAllPlayerNames("json")) 
		;  
			viewingPlayers = json.union(others, getOwners("json",me)) 
		]
		
		<!-- then set the this new owner list to all the shadow tokens. Keep in mind that me+shadow is not yet created so to prevent an error remove it from the tokenlist -->
		[tokList	= listDelete(tokList, listFind(tokList, me))]
		[foreach(tok, tokList): setOwner(viewingPlayers, tok+" shadow")]
		<!-- copytoken only needs to do me so set the list to me -->
		[tokList	= me]
	};{
		<!-- The pads are activated by this move, so create a list of clients who own tokens that are on the other shadow pad, they will see the shadow tokens, the rest not. -->
		[viewingPlayers	= "[]"]
		[foreach(tok, tokList), if(isOwnedByAll(tok)): 
				viewingPlayers = json.union(viewingPlayers, getAllPlayerNames("json"))
			;
				viewingPlayers = json.union(viewingPlayers, getOwners("json",tok))
		]
	}]
	
	<!-- as a new token moved onto the shadowpad a shadowToken needs to be created, in case the this was the first token to move on this pad ALL participating tokens require a shadowToken -->
	<!-- you cannot change the properties of a copyToken so you need to change the original before the copy and then change it back. -->
	[foreach(tok, tokList), CODE:{
		<!-- how it is -->
		[isVisible	= getOwnerOnlyVisible(tok)]
		[hasHalo	= getHalo(tok)]
		[owners		= getOwners("json", tok)]
		
		<!-- in case a shadowToken is already on the map, use that instead -->
		[altShadow	= if(findToken(tok+" shadow") !="", 1, 0)]

		<!-- how they will be, and use the existing shadowTok is its there -->
		[newTok		= if(altShadow , tok+" shadow", tok)]
		[setProperty("w42.bot.isShadowToken", 1, newTok)]
		[setOwnerOnlyVisible(1, newTok)]
		[setHalo("black", newTok)]
		[setOwner(viewingPlayers, newTok)]
		[if(altShadow): setProperty("w42.bot.doNotDelete", 1, newTok)]
		[if(altShadow): setProperty("w42.bot.x", getTokenX(1, newTok), newTok)]
		[if(altShadow): setProperty("w42.bot.y", getTokenY(1, newTok), newTok)]
		
		<!-- create x and y coord for shadow token -->
		<!-- if no copy is created, move the alt shadow to the correct coord. Else retrieve x an y coords for copytoken -->
		<!-- reference tokens can be anything but need to end with ' Ground' and ' Floor'. This must NOT be added to the argument -->
		[bot_shadowCoords(tok, !altShadow)]
		
		<!-- create the new token with the correct properties -->
		[if(!altShadow): copyToken(tok,1, "", json.set("{}", "name", tok+" shadow", "layer", if(canSelectShadowTok, "TOKEN", "OBJECT"), "x", x, "y", y,"useDistance",1, "size", "small"))]
		
		<!-- how it was (restore) -->
		[setOwnerOnlyVisible(isVisible, tok)]
		[setHalo(hasHalo, tok)]
		[setOwner(owners, tok)]
		[resetProperty("w42.bot.isShadowToken", tok)]
	}]
};{}]

<!-- if token moved but remained on the on the shadow pad then move its shadow accordingly -->
[h,if( (event == "movedRemain" || event == "movedReturn") && sActive), CODE:{
	[tokList	= listAppend(getProperty("w42.bot.onPad", padName), getProperty("w42.bot.onPad", sPadName))]
	[foreach(tok, tokList):bot_shadowCoords(tok)]
};{}]

@@removeShadow
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=32 ; color=default ; playerEditable=false ; applyToSelected=false ; group=3a. ShadowPads ; tooltip= ; minWidth=90 ; 
[h:'<!-- ----------------------------------- bot_removeShadow(tok) ------------------------------------------------>']
<!-- removes the shadow tokens from the shadow pads on exit -->

[tok	= arg(0)+" shadow"]
[if(getProperty("w42.bot.doNotDelete", tok) == 1), CODE:{
	[moveToken(getProperty("w42.bot.x", tok), getProperty("w42.bot.y", tok), 1, tok)]
};{
	[removeToken(tok)]
}]

@@setReference
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=32 ; color=default ; playerEditable=false ; applyToSelected=false ; group=3a. ShadowPads ; tooltip=<html>This macro is used to setup the <b>Shadow pads.</b><br> To sync the movement of the shadow token to the real token two reference tokens are required.<br> <br> To set this up do the following:<br> 1. create two tokens with the same name where one has the suffix &#39; Ground&#39; and the other &#39; Floor&#39;<br> 2. Make sure that the reference tokens are snapped to grid and medium sized.<br> 3. Place one of the tokens on the ground floor map and one on the first floor map.<br> 4. Then select one of the reference tokens and hit this macro. Select the shadow pads to which it<br> should be linked and hit ok.<br> <br> Read the manual for more detailed instructions </html> ; minWidth=90 ; 
[h:'<!-- ----------------------------------- bot_setReference () ------------------------------------------------>']
<!-- 
<html>This macro is used to setup the <b>Shadow pads.</b><br> To sync the movement of the shadow token to the real token two reference tokens are required.<br> <br> To set this up do the following:<br> 1. create two tokens with the same name where one has the suffix &#39; Ground&#39; and the other &#39; Floor&#39;<br> 2. Make sure that the reference tokens are snapped to grid and medium sized.<br> 3. Place one of the tokens on the ground floor map and one on the first floor map.<br> 4. Then select one of the reference tokens and hit this macro. Select the shadow pads to which it<br> should be linked and hit ok.<br> <br> Read the manual for more detailed instructions </html> 
-->

[h:me = getSelectedNames()]
<!-- assert correct selected -->
[h:assert(listCount(me)==1,"Please select (only) one reference token",0)]
[h:assert(bot_inStr(me, " Floor")||bot_inStr(me, " Ground"),"This token misses the Ground or Floor suffix",0)]
[h:switchToken(me)]

[h:isFloor		= if(bot_inStr(me, " Floor"), 1,0)]
[h:reference	= substring(me, 0, indexOf(me, if(isFloor, " Floor", " Ground")))]
[h:sMe			= reference + if(isFloor, " Ground", " Floor")]
[h:assert(findToken(sMe) != "", sMe+" token not found. Create that one first",0)]

[H: '<!-- no new scope!! results in allList -->']
[h:bot_getValidTokens(1, json.set("{}", "layer", json.append("[]","TOKEN","HIDDEN","OBJECT","BACKGROUND")), 0, "ShadowPad ")]
[h:allList	= replace(allList, " Floor", "")]
[h:allList	= replace(allList, " Ground", "")]
[h:allList	= json.toList(json.unique(json.fromList(allList)))]

[h:abort(input("choice|"+allList+"|Link to which shadow pads?|LIST|VALUE=STRING"))]

[h:setProperty("w42.bot.referenceTok", reference, choice + " Ground")]
[h:setProperty("w42.bot.referenceTok", reference, choice +" Floor")]

[h:broadcast(strformat("%{reference} has been linked to %{choice}"))]

@@shadowCoords
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=32 ; color=default ; playerEditable=false ; applyToSelected=false ; group=3a. ShadowPads ; tooltip= ; minWidth=90 ; 
[h:'<!-- ----------------------------------- bot_shadowCoords (tok [,returnCoords]) ------------------------------------------------>']
<!-- this function is used for the shadow token function and either moves or returns the new coords of the shadow token -->
<!-- NO NEW SCOPE -->

[switchToken(arg(0))]
<!-- reference tokens can be anything but need to end with ' Ground' and ' Level'. This must NOT be added to the argument -->
[if(argCount() > 1): returnCoords = arg(1); returnCoords = 0]

[referenceToken	= getProperty("w42.bot.referenceTok", padName)]
[shadow			= token.name + ' shadow']

<!-- the token will belong to the reference that is closest -->
[whereAmI    	= if( (abs(getTokenX() - getTokenX(1, referenceToken + ' Ground')) + abs(getTokenX() - getTokenY(1, referenceToken + ' Ground'))) < (abs(getTokenX() - getTokenX(1, referenceToken + ' Floor')) + abs(getTokenX() - getTokenY(1, referenceToken + ' Floor'))) , -1, 1 )]

[if(returnCoords), CODE:{
	<!-- no new scope so just create the coords -->
	[x	= getTokenX(1) + whereAmI*( getTokenX(1, referenceToken + ' Ground') - getTokenX(1, referenceToken + ' Floor') )]
	[y	= getTokenY(1) + whereAmI*( getTokenY(1, referenceToken + ' Ground') - getTokenY(1, referenceToken + ' Floor') )]
};{
	[moveToken( getTokenX(1) + whereAmI*( getTokenX(1, referenceToken + ' Ground') - getTokenX(1, referenceToken + ' Floor') ), getTokenY(1) + whereAmI*( getTokenY(1, referenceToken + ' Ground') - getTokenY(1, referenceToken + ' Floor') ), 1, shadow)]
}]

@@formatTime
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=16 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Timer functions ; tooltip=Total amount of time passed since the timer was started ; minWidth=90 ; 
[h:'<!-- ----------------------- bot_formatTime(time in ms, useHTML) ---------------------------------- -->']
[seconds		= arg(0)/1000]
[if(argCount()>1): useHTML = arg(1) ; useHTML = 1]

[minutes		= floor(seconds/60)]
[seconds		= seconds - minutes*60]

[hours			= floor(minutes/60)]
[minutes		= minutes - hours*60]

[macro.return	= if(hours, hours+if(useHTML,"<b>h</b>"," hours "),"") + if(minutes, minutes+if(useHTML,"<b>m</b>"," minutes "),"") + seconds+if(useHTML,"<b>s</b>"," seconds ")]

@@pauseTime
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=12 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Timer functions ; tooltip=<html>get a subtime, which is the period that has passed since the start or the last subtime (which ever is later)<br>pass 1 as parameter to get formatted time ; minWidth=90 ; 
[h:'<!-- ----------------------- bot_pauseTime() ---------------------------------- -->']
[h:time			= if(	getLibProperty("w42.bot.timeIsPaused", "lib:EventMacros"), 
						getLibProperty("w42.bot.pauseTime", "lib:EventMacros") , 
						json.get(getInfo("client"), "timeInMs") - getLibProperty("w42.bot.pausedTime", "lib:EventMacros")
)]
[h:setLibProperty("w42.bot.pauseTime", time, "lib:EventMacros")]
[h:setLibProperty("w42.bot.timeIsPaused", 1, "lib:EventMacros")]

@@resetTimer
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy=2 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Timer functions ; tooltip= ; minWidth=90 ; 
[setLibProperty('w42.bot.lastTime'+arg(0), json.get(getInfo("client"),"timeInMs"), 'lib:EventMacros')]

@@resumeTime
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=13 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Timer functions ; tooltip=<html>get a subtime, which is the period that has passed since the start or the last subtime (which ever is later)<br>pass 1 as parameter to get formatted time ; minWidth=90 ; 
[h:'<!-- ----------------------- bot_resumeTime([makeup]) ---------------------------------- -->']
[h:pausedTime	= getLibProperty("w42.bot.pausedTime", "lib:EventMacros")]
[h:time			= json.get(getInfo("client"), "timeInMs") - pausedTime]
[h:pauseTime	= getLibProperty("w42.bot.pauseTime", "lib:EventMacros")]
[h:stoppedTime	= max(0,time - pauseTime)]
[h:pausedTime	= pausedTime + stoppedTime]
[h:setLibProperty("w42.bot.pausedTime", pausedTime, "lib:EventMacros")]
[h:setLibProperty("w42.bot.timeIsPaused", 0, "lib:EventMacros")]

@@startTime
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=11 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Timer functions ; tooltip=<html>start the timer<br>to reset just run startTime again ; minWidth=90 ; 
[h:'<!-- ----------------------- bot_startTime ---------------------------------- -->']
[h:time	= json.get(getInfo("client"), "timeInMs")]
[h:setLibProperty("w42.bot.startTime", time, "lib:EventMacros")]
[h:setLibProperty("w42.bot.subTime", time, "lib:EventMacros")]
<!-- reset pauseTimer -->
[h:setLibProperty("w42.bot.pausedTime", 0, "lib:EventMacros")]
[h:setLibProperty("w42.bot.pauseTime", 0, "lib:EventMacros")]
[h:setLibProperty("w42.bot.timeIsPaused", 0, "lib:EventMacros")]

@@subTime
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=14 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Timer functions ; tooltip=<html>get a subtime, which is the period that has passed since the start or the last subtime (which ever is later)<br>pass 1 as parameter to get formatted time ; minWidth=90 ; 
[h:'<!-- ----------------------- bot_subTime([makeup]) ---------------------------------- -->']
[if(argCount() > 0): makeUp = arg(0) ; makeUp = 0]
[h:time			= if(	getLibProperty("w42.bot.timeIsPaused", "lib:EventMacros"), 
						getLibProperty("w42.bot.pauseTime", "lib:EventMacros") , 
						json.get(getInfo("client"), "timeInMs") - getLibProperty("w42.bot.pausedTime", "lib:EventMacros")
)]

[h:subTime		= getLibProperty("w42.bot.subTime", "lib:EventMacros")]
[h:setLibProperty("w42.bot.subTime", time, "lib:EventMacros")]
[h:resultTime	= time - subTime]
[h,if(makeUp): resultTime = bot_formatTime(resultTime)]
[h:macro.return	= resultTime]

@@timeOut
@PROPS@ fontColor=red ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=default ; playerEditable=false ; applyToSelected=false ; group=Timer functions ; tooltip= ; minWidth=90 ; 
[h:'<!-- --------------------------- timeOut() --------------------------------- -->']
<!-- build in delay to make sure this macro is called only once -->
[h: lastRun			= getLibProperty('w42.bot.lastTime'+arg(0),'lib:EventMacros')]
[h,if(lastRun == ""):lastRun = 0]
[h: currentTime 	= json.get(getInfo("client"),"timeInMs")]
[h: timeLockDelay	= getLibProperty('timeLockDelay','lib:EventMacros')]

<!-- both the upper and lower time range need to be set, cause of the possibility of different timezones and client pcs that have their clock set differently -->
[h: macro.return	= if(currentTime < lastRun - timeLockDelay || currentTime > lastRun + timeLockDelay, 1, 0)]

@@totalTime
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=15 ; color=default ; playerEditable=false ; applyToSelected=false ; group=Timer functions ; tooltip=<html>Total amount of time passed since the timer was started<br>pass 1 as parameter to get formatted time<br>note that totaltime does NOT reset the timer ; minWidth=90 ; 
[h:'<!-- ----------------------- bot_totalTime([makeup]) ---------------------------------- -->']
[if(argCount() > 0): makeUp = arg(0) ; makeUp = 0]
[h:time			= if(	getLibProperty("w42.bot.timeIsPaused", "lib:EventMacros"), 
						getLibProperty("w42.bot.pauseTime", "lib:EventMacros") , 
						json.get(getInfo("client"), "timeInMs") - getLibProperty("w42.bot.pausedTime", "lib:EventMacros")
)]
[h:startTime	= getLibProperty("w42.bot.startTime", "lib:EventMacros")]

[h:resultTime	= time - startTime]
[h,if(makeUp): resultTime = bot_formatTime(resultTime)]
[h:macro.return	= resultTime]

@@getCircleCoords
@PROPS@ fontColor=purple ; autoExecute=true ; fontSize=1.00em ; sortBy=10 ; color=default ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
[h:'<!-- --------------------------------------- bot_getCircleCoords(me, range, drawToken) -------------------------------------- -->']
<!--	- from the range of 10 and larger, only the outside of the circle is drawn (faster)
		- drawToken=="": returns coordinates of the circle and does NOT draw it when
		- drawToken!="":  returns the ids of the copied tokens and DOES draw it. 
		- drawToken MUST be present on the BASE map
-->

[me			= arg(0)]
[range		= arg(1)]
[drawToken	= arg(2)]

<!-- initiate variables -->
[h:libCoords	= "lib:EventMacros"]
[h:updates		= json.set("{}", "layer", "BACKGROUND", "useDistance", 0, "facing", "[r:(1d4-1) * 90]")]
[h:baseMap		= getLibProperty("baseMapName", "lib:EventMacros")][h:copies	= ""]
[H:tX			= getTokenX(0, me)]
[H:tY			= getTokenY(0, me)]
[draw			= if(drawToken == "", 0, 1)]

<!-- upto and including th range of 10 will be filled with blast tokens. Beyond that, only the border is shown (unless draw is false) -->
[h:fullFillRange= if(draw, 1000, 10)]

[h:XCoords		= getLibProperty("circleXrange"+range, libCoords)]

[h,if(  json.type(XCoords) != "ARRAY" ), CODE:{
	[XCoords	= "[]"]
	[YCoords	= "[]"]
	<!-- calculate the x and y coords IF not already store on the lib -->

	[h,for(i,-range, range+1, 1), CODE:{
		[x	= abs(i)]
		[for(j,-range, range+1, 1), CODE:{
			[y		= abs(j)]
			[step	= (x+y) - ceil( min(x,y) /2)]
			[if(step <= range && range <= fullFillRange), CODE:{
				[XCoords	= json.append(XCoords, i)]
				[YCoords	= json.append(YCoords, j)]
				''
			};{
				[if(step == range && range > fullFillRange), CODE:{
					[XCoords	= json.append(XCoords, i)]
					[YCoords	= json.append(YCoords, j)]
				''
				};{}]
			''
			}]
		''
		}]
	''
	}] 
	<!-- store the x and y coordinates seperately -->
	[setLibProperty("circleXrange"+range, XCoords, libCoords)]
	[setLibProperty("circleYrange"+range, YCoords, libCoords)]
''
};{
	[YCoords	= getLibProperty("circleYrange"+range, libCoords)]
''
}]

<!-- special case range = 0 -->
[h,if(!range), CODE:{
	[XCoords	= "[0]"]
	[YCoords	= "[0]"]
};{}]

[h:i		= 0]
[h, if(draw), CODE:{
	<!-- copy the blast tokens onto the map, return the ids of the copies -->
	[copies	= copyToken(drawToken, listCount(XCoords), baseMap, json.set(updates, "x", "[r:tX + json.get(XCoords,i)]", "y", "[r:tY + json.get(YCoords,i)][h:i=i+1]")))]
	[macro.return	= copies]
};{
	<!-- return the coords -->
	[coords		= "[]"]
	[for(i, 0, json.length(XCoords)): coords = json.append(coords,  json.set("{}","x",tX+json.get(XCoords, i) ,"y",tY+json.get(YCoords, i) )  )]
	[macro.return	= coords]
}]

@@getConeCoords
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=20 ; color=default ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!-- bot_getConeCoords (me, x1,y1, x2,y2) -->
<!-- returns an array with all coords of the cone-->

[me			= arg(0)]
[x1			= arg(1)]
[y1			= arg(2)]
[x2			= arg(3)]
[y2			= arg(4)]

[xc			= getTokenX(0,me)]
[yc			= getTokenY(0,me)]

<!-- check if p2 is clockwise from p1, if not then swap them -->
[if(!bot_isClockWise (xc,yc,x1,y1,x2,y2)), CODE:{
	[xt	= x1]
	[yt	= y1]
	[x1	= x2]
	[y1	= y2]
	[x2	= xt]
	[y2	= yt]
}]

[centre			= json.set("{}","x",xc,"y",yc)]
[checked		= json.append("[]",centre)]
[coneCoords		= checked]
[oldConeCoords	= coneCoords]
[toCheck		= bot_getNeighbourXY(centre)]
[stop			= 0]

<!-- create array of line points -->
[lineCoords		= bot_getLineCoords (xc, yc, x1, y1)]
[lineCoords		= json.union(lineCoords, bot_getLineCoords (xc, yc, x2, y2))]

[bot_startTime()]

[while(!stop), CODE:{
	<!-- check all neighbouring coords whether they are on or outside the cone -->
	<!-- dont use bot_pointOnCone as it includes a lengthy line check, do the linecheck here -->
	[foreach(coord, toCheck), CODE:{
		[onCone	= json.contains(lineCoords, coord) + bot_pointInCone(json.get(coord, "x"), json.get(coord, "y"), me, x1,y1,  x2,y2)]
		[if(onCone): coneCoords = json.append(coneCoords, coord)]
	}]
	[checked		= json.union(checked, toCheck)]

	<!-- build a new toCheckArray of all neighbouring coords around the coords that are part of the cone -->
	<!-- optimize by removing already checked coords from coneCoords -->
	[newCoords		= json.difference(coneCoords, oldConeCoords)]
	[toCheck		= "[]"]
	[foreach(coord, coneCoords), CODE:{
		[newCoords	= bot_getNeighbourXY(coord)]
		[toCheck	= json.union(toCheck, newCoords)]
	}]
	
	<!-- remove all coords already checked -->
	[toCheck		= json.difference(json.unique(toCheck), checked)]
	[oldConeCoords	= coneCoords]
	[if(json.isEmpty(toCheck)): stop=1]
}]
[broadcast("Process took: "+bot_totalTime(1))]
[h:macro.return	= coneCoords]

@@getLineCoords
@PROPS@ fontColor=fuchsia ; autoExecute=true ; fontSize=1.00em ; sortBy=40 ; color=default ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!-- bot_getLineCoords (x0, y01, x1, y1 ,relative)-->
[x0		= arg(0)]
[y0		= arg(1)]
[x1		= arg(2)]
[y1		= arg(3)]
<!-- return coordinates relative to first coordinate -->
[if(argCount() > 4):	rel	= arg(4) ; rel = 0]

[dx		= abs(x1-x0)]
[dy		= abs(y1-y0)]
[sx		= if(x0 < x1, 1, -1)]
[sy		= if(y0 < y1, 1, -1)]
[err	= dx - dy]
[relX	= rel*x0]
[relY	= rel*y0]

[stop	= 0]
[coords	= "[]"]

[while (!stop), CODE:{
	[coord	= json.set("{}","x",x0-relX,"y",y0-relY))]
	[coords	= json.append(coords,coord)]

	[if(x0 == x1 && y0 == y1): stop = 1]
	[e2	= 2 * err]

	[if(e2 > -dy), CODE:{
		[err	= err - dy]
		[x0		= x0 + sx]
	};{}]

	[if(e2 < dx), CODE:{
		[err	= err + dx]
		[y0		= y0 + sy ]
	};{}]
}]

[macro.return	= coords]

@@getSquareCoords
@PROPS@ fontColor=green ; autoExecute=true ; fontSize=1.00em ; sortBy=30 ; color=default ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!-- bot_getSquareCoords (x1, y1, x2, y2)-->
[x1		= arg(0)]
[y1		= arg(1)]
[x2		= arg(2)+1]
[y2		= arg(3)+1]

[coords	= "[]"]

[for(x,x1,x2),CODE:{
	[for(y,y1,y2): coords	= json.append(coords, json.set("{}","x",x,"y",y)  )]
}]

[macro.return	= coords]

@@getTriangleCoords
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy=50 ; color=default ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!-- bot_getTriangleCoords (x1,y1, x2,y2, x3,y3,relative) -->
[x1	= arg(0)]
[y1	= arg(1)]
[x2	= arg(2)]
[y2	= arg(3)]
[x3	= arg(4)]
[y3	= arg(5)]
[rel	= arg(6)]

[xMin	= min(x1,x2,x3)]
[yMin	= min(y1,y2,y3)]
[xMax	= max(x1,x2,x3)]
[yMax	= max(y1,y2,y3)]

[coords	= "[]"]

[for(x,xMin,xMax), CODE:{
	[for(y,yMin,yMax), CODE:{
		[if(bot_pointInTriangle(x,y,x1,y1,x2,y2,x3,y3,0)): coords	= json.append(coords,json.set("{}","x",x,"y",y))]
	}]
}]
[macro.return	= coords]

@@pointInCone
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=20 ; color=default ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!-- bot_pointInCone (xp,yp, me, x1,y1, x2,y2) -->
<!-- checks if a point (p) is between three points (centre, 1 and 2) on a SPHERE, does NOT include boundary -->
<!-- always make sure that p2 is clockwise from p1 !! -->

<!-- isClockWise (xcentr,ycentr,x1,y1,x2,y2) -->
[h:macro.return	= if(
	bot_isClockWise		(getTokenX(0,arg(2)),getTokenY(0,arg(2)),  arg(3),arg(4),  arg(0),arg(1)) && 
	!bot_isClockWise	(getTokenX(0,arg(2)),getTokenY(0,arg(2)),  arg(5),arg(6),  arg(0),arg(1)) && 
	if(getDistanceToXY(arg(0),arg(1),0,arg(2)) <= getDistanceToXY(arg(3),arg(4),0,arg(2)),1,0), 
	1, 0
)]

@@pointInTriangle
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy=50 ; color=default ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!-- bot_pointInTriangle (xp,yp, x1,y1, x2,y2, x3,y3):boolean -->
<!-- checks if a point is between three points, does not include boundary, a line check is needed for that -->
[h:b2	= if( (arg(0) - arg(6)) * (arg(5) - arg(7)) -  (arg(4) - arg(6)) * (arg(1) - arg(7)) < 0, 1,0)]
[macro.return = if(if( (arg(0) - arg(4)) * (arg(3) - arg(5)) -  (arg(2) - arg(4)) * (arg(1) - arg(5)) < 0, 1,0) == b2 && b2 == if( (arg(0) - arg(2)) * (arg(7) - arg(3)) -  (arg(6) - arg(2)) * (arg(1) - arg(3)) < 0, 1,0),1,0)]

@@pointOnCircle
@PROPS@ fontColor=purple ; autoExecute=true ; fontSize=1.00em ; sortBy=10 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!--	bot_pointOnCircle (xp,yp, me, range) 
		OR
		bot_pointOnCircle (tok, me, range) -->
<!-- checks if a point (p) or token (tok) is on a circle centered on me with range r, DOES include boundary -->

[switch(argCount()), CODE:
	case 3:{
		[tok	= arg(0)]
		[me		= arg(1)]
		[range	= arg(2)]

		[xp		= getTokenX(0, tok)]
		[yp		= getTokenY(0, tok)]
		[x1		= getTokenX(0, me)]
		[y1		= getTokenY(0, me)]
		[angle	= bot_getTokenFacing(me,2)*bot_pi()/180]
		[x2		= x1 + round(range*bot_cos(angle),0)]
		[y2		= y1 + round(range*bot_sin(angle),0)]
	};
	case 4:{
		[xp		= arg(0)]
		[yp		= arg(1)]
		[me		= arg(2)]
		[range	= arg(3)]
	};
	default:{[assert(0,"Error in bot_pointOnCircle, wrong amount of arguments: "+argCount(),0)]}
]

[point		= json.set("{}","x",xp,"y",yp)]
<!-- bot_getCircleCoords(me, range, draw)  -->
[circle		= bot_getCircleCoords (me, range, "")]
[h:macro.return	= json.contains(circle, point)]

@@pointOnCone
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=20 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!--	bot_pointOnCone (xp,yp, me, range, arc=angle) 
		OR
		bot_pointOnCone (tok, me, range, arc=angle) 
-->
<!-- checks if a point is on a cone, DOES include boundary -->

[switch(argCount()), CODE:
	case 4:{
		[tok	= arg(0)]
		[me		= arg(1)]
		[range	= arg(2)]
		[arc	= arg(3)/2]

		[xp		= getTokenX(0, tok)]
		[yp		= getTokenY(0, tok)]
		[x1		= getTokenX(0, me)]
		[y1		= getTokenY(0, me)]
		[angle	= bot_getTokenFacing(me,2)]

		<!-- retrieve the gridcoords where the triangle corners end -->
		<!-- get both angles in radians -->
		[arc1		= (angle - arc)*bot_pi()/180]
		[arc2		= (angle + arc)*bot_pi()/180]
		<!-- get grid coords -->
		[x2			= x1 + round(range*bot_cos(arc1),0)]
		[y2			= y1 + round(range*bot_sin(arc1),0)]
		[x3			= x1 + round(range*bot_cos(arc2),0)]
		[y3			= y1 + round(range*bot_sin(arc2),0)]
	};
	case 5:{
		[xp		= arg(0)]
		[yp		= arg(1)]
		[me		= arg(2)]
		[range	= arg(3)]
		[arc	= arg(4)/2]

		[x1		= getTokenX(0, me)]
		[y1		= getTokenY(0, me)]
		[angle	= bot_getTokenFacing(me,2)]

		<!-- retrieve the gridcoords where the triangle corners end -->
		<!-- get both angles in radians -->
		[arc1		= (angle - arc)*bot_pi()/180]
		[arc2		= (angle + arc)*bot_pi()/180]
		<!-- get grid coords -->
		[x2			= x1 + round(range*bot_cos(arc1),0)]
		[y2			= y1 + round(range*bot_sin(arc1),0)]
		[x3			= x1 + round(range*bot_cos(arc2),0)]
		[y3			= y1 + round(range*bot_sin(arc2),0)]
	};
	default:{[assert(0,"Error in bot_pointOnCone, wrong amount of arguments: "+argCount(),0)]}
]

[h:p1		= bot_pointOnLine	(xp,yp,  x1,y1,  x2,y2)]
[h:p2		= bot_pointOnLine	(xp,yp,  x1,y1,  x3,y3)]
[h:p3		= bot_pointInCone	(xp,yp,  me,  x2,y2,  x3,y3)]

[h:macro.return	= if(p1 || p2 || p3, 1, 0)]

@@pointOnLine
@PROPS@ fontColor=fuchsia ; autoExecute=true ; fontSize=1.00em ; sortBy=40 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!--	bot_pointOnLine (xp,yp, x1,y1, x2,y2) 
		OR
		bot_pointOnLine (xp,yp, me, range) 
		OR
		pointOnLine (tok, me, range) (use facing) -->
<!-- checks if a point (p) or token (tok) is on a line between 2 points (1 and 2) or on a line casted from me, DOES include boundary -->

[switch(argCount()), CODE:
	case 3:{
		[tok	= arg(0)]
		[me		= arg(1)]
		[range	= arg(2)]
		[xp		= getTokenX(0, tok)]
		[yp		= getTokenY(0, tok)]
		[x1		= getTokenX(0, me)]
		[y1		= getTokenY(0, me)]
		[angle	= bot_getTokenFacing(me,2)*bot_pi()/180]
		[x2		= x1 + round(range*bot_cos(angle),0)]
		[y2		= y1 + round(range*bot_sin(angle),0)]
	};
	case 4:{
		[xp		= arg(0)]
		[yp		= arg(1)]
		[me		= arg(2)]
		[range	= arg(3)]
		[x1		= getTokenX(0, me)]
		[y1		= getTokenY(0, me)]
		[angle	= bot_getTokenFacing(me,2)*bot_pi()/180]
		[x2		= x1 + round(range*bot_cos(angle),0)]
		[y2		= y1 + round(range*bot_sin(angle),0)]
	};
	case 6:{
		[xp		= arg(0)]
		[yp		= arg(1)]
		[x1		= arg(2)]
		[y1		= arg(3)]
		[x2		= arg(4)]
		[y2		= arg(5)]
	};
	default:{[assert(0,"Error in bot_pointOnLine, wrong amount of arguments: "+argCount(),0)]}
]

[point		= json.set("{}","x",xp,"y",yp)]
<!-- bot_getLineCoords (x0, y01, x1, y1)-->
[line		= bot_getLineCoords (x1, y1, x2, y2)]

[h:macro.return	= json.contains(line, point)]

@@pointOnSquare
@PROPS@ fontColor=green ; autoExecute=true ; fontSize=1.00em ; sortBy=30 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!--	bot_pointOnSquare (xp,yp, me, range) 
		OR
		bot_pointOnSquare (tok, me, range) 
-->
<!-- checks if a point (p) is within range of me, assuming a square area with range (me, edge square) -->

[switch(argCount()), CODE:
	case 3:{
		[tok	= arg(0)]
		[me		= arg(1)]
		[range	= arg(2)]

		[xp		= getTokenX(0, tok)]
		[yp		= getTokenY(0, tok)]
	};
	case 4:{
		[xp		= arg(0)]
		[yp		= arg(1)]
		[me		= arg(2)]
		[range	= arg(3)]
	};
	default:{[assert(0,"Error in bot_pointOnSquare, wrong amount of arguments: "+argCount(),0)]}
]

[xc		= getTokenX(0, me)]
[yc		= getTokenY(0, me)]
[x1		= xc - range]
[y1		= yc - range]
[x2		= xc + range]
[y2		= yc + range]

[h:macro.return	= if(
	xp >= x1 &&
	yp >= y1 &&
	xp <= x2 &&
	yp <= y2, 
	1, 0
)]

@@pointOnTriangle
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy=50 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!--	bot_pointOnTriangle (xp,yp, x1,y1, x2,y2, x3,y3) 
		OR
		bot_pointOnTriangle (xp,yp, me, range, arc=angle) 
		OR
		bot_pointOnTriangle (tok, me, range, arc=angle) 
-->
<!-- checks if a point is between three points, DOES include boundary -->

[switch(argCount()), CODE:
	case 4:{
		[tok	= arg(0)]
		[me		= arg(1)]
		[range	= arg(2)]
		[arc	= arg(3)/2]

		[xp		= getTokenX(0, tok)]
		[yp		= getTokenY(0, tok)]
		[x1		= getTokenX(0, me)]
		[y1		= getTokenY(0, me)]
		[angle	= bot_getTokenFacing(me,2)]

		<!-- retrieve the gridcoords where the triangle corners end -->
		<!-- get both angles in radians -->
		[arc1		= (angle - arc)*bot_pi()/180]
		[arc2		= (angle + arc)*bot_pi()/180]
		<!-- get grid coords -->
		[x2			= x1 + round(range*bot_cos(arc1),0)]
		[y2			= y1 + round(range*bot_sin(arc1),0)]
		[x3			= x1 + round(range*bot_cos(arc2),0)]
		[y3			= y1 + round(range*bot_sin(arc2),0)]
	};
	case 5:{
		[xp		= arg(0)]
		[yp		= arg(1)]
		[me		= arg(2)]
		[range	= arg(3)]
		[arc	= arg(4)/2]

		[x1		= getTokenX(0, me)]
		[y1		= getTokenY(0, me)]
		[angle	= bot_getTokenFacing(me,2)]

		<!-- retrieve the gridcoords where the triangle corners end -->
		<!-- get both angles in radians -->
		[arc1		= (angle - arc)*bot_pi()/180]
		[arc2		= (angle + arc)*bot_pi()/180]
		<!-- get grid coords -->
		[x2			= x1 + round(range*bot_cos(arc1),0)]
		[y2			= y1 + round(range*bot_sin(arc1),0)]
		[x3			= x1 + round(range*bot_cos(arc2),0)]
		[y3			= y1 + round(range*bot_sin(arc2),0)]
	};
	case 8:{
		[xp			= arg(0)]
		[yp			= arg(1)]
		[x1			= arg(2)]
		[y1			= arg(3)]
		[x2			= arg(4)]
		[y2			= arg(5)]
		[x3			= arg(6)]
		[y3			= arg(7)]	
	};
	default:{
		[assert(0,"Error in bot_pointOnTriangle, wrong amount of arguments: "+argCount(),0)]
	}
]

[h:p1		= bot_pointOnLine		(xp,yp,  x1,y1,  x2,y2)]
[h:p2		= bot_pointOnLine		(xp,yp,  x1,y1,  x3,y3)]
[h:p3		= bot_pointOnLine		(xp,yp,  x3,y3,  x2,y2)]
[h:p4		= bot_pointInTriangle	(xp,yp,  x1,y1,  x2,y2,  x3,y3)]

[h:macro.return	= if(p1 || p2 || p3 || p4, 1, 0)]

@@selectOnCircle
@PROPS@ fontColor=purple ; autoExecute=true ; fontSize=1.00em ; sortBy=10 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!-- selectOnCircle (me, range) -->
<!-- selects all tokens inside of the shape -->

[me			= arg(0)]
[range		= arg(1)]
[toks		= getTokens(",", json.set("{}", "range", json.set("{}", "token", me, "distancePerCell", 0, "upto", range))  )]

[selectTokens(toks,0,",")]
[macro.return	= toks]

@@selectOnCone
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=20 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!-- selectOnCone (me, range, arc=angle) -->
<!-- selects all tokens inside of the shape -->

[me			= arg(0)]
[range		= arg(1)]
[arc		= arg(2)]
[toks		= ""]

[allToks	= getTokens(",", json.set("{}", "range", json.set("{}", "token", me, "distancePerCell", 0, "upto", range))  )]
<!-- bot_pointOnCone (tok, me, range, arc=angle) -->
[foreach(tok, allToks), if(bot_pointOnCone(tok, me, range, arc)): toks	= listAppend(toks, tok)]

[selectTokens(toks,0,",")]
[macro.return	= toks]

@@selectOnLine
@PROPS@ fontColor=fuchsia ; autoExecute=true ; fontSize=1.00em ; sortBy=40 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!-- selectOnLine (me, range, sort)(use tokenfacing) -->
<!-- OR selectOnLine (me, x2,y2, sort) -->
<!-- selects all tokens inside of the shape -->

[h:assert(argCount() > 2, "ERROR in selectOnline: wrong number of arguments. Either pass: me,range,sort(=1/0) or me, x2,y2,sort", 0)]

[if(argCount() == 3), CODE:{
	[me			= arg(0)]
	[range		= arg(1)]
	[sort		= arg(2)]
	
	[x1			= getTokenX(0, me)]
	[y1			= getTokenY(0, me)]
	[angle		= bot_getTokenFacing(me,2)*bot_pi()/180]
	[x2			= x1 + round(range*bot_cos(angle),0)]
	[y2			= y1 + round(range*bot_sin(angle),0)]
};{
	[me			= arg(0)]
	[x1			= getTokenX(0, me)]
	[y1			= getTokenY(0, me)]
	[x2			= arg(1)]
	[y2			= arg(2)]
	[sort		= arg(3)]
}]

[area		= bot_getLineCoords (x1, y1, x2, y2, 1)]

[allToks	= getTokens(",", json.set("{}", "area", json.set("{}", "token", me, "offsets", area)  )  )]

[if(sort), CODE:{
	[tmpArray	= "[]"]
	[foreach(tok, allToks): tmpArray	= json.append(tmpArray,json.set("{}", "tok", tok, "distance", getDistance(me,0,tok)))]
	[tmpArray	= json.sort(tmpArray,'a','distance')]
	[allToks	= ""]
	[foreach(obj, tmpArray): allToks	= listAppend(allToks, json.get(obj, "tok"))]
};{}]

[selectTokens(allToks, 0, ",")]
[macro.return	= allToks]

@@selectOnSquare
@PROPS@ fontColor=green ; autoExecute=true ; fontSize=1.00em ; sortBy=30 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!-- selectOnSquare (me, range) -->
<!-- selects all tokens inside of the shape -->

[me			= arg(0)]
[range		= arg(1)]
[toks		= ""]

<!-- the formula for range makes sure that the corners of the square are taken into account as well. -->
[allToks	= getTokens(",", json.set("{}", "range", json.set("{}", "token", me, "distancePerCell", 0, "upto", ceil(sqrt(2*range*range)+range/10) ))  )]
<!-- bot_pointOnCone (tok, me, range, arc=angle) -->
[foreach(tok, allToks), if(bot_pointOnSquare(tok, me, range)): toks	= listAppend(toks, tok)]

[selectTokens(toks,0,",")]
[macro.return	= toks]

@@selectOnTriangle
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy=50 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!-- selectOnTriangle (me, range) -->
<!-- selects all tokens inside of the shape -->

[me			= arg(0)]
[range		= arg(1)]
[arc		= arg(2)]
[toks		= ""]

[allToks	= getTokens(",", json.set("{}", "range", json.set("{}", "token", me, "distancePerCell", 0, "upto", range))  )]
<!-- bot_pointOnTriangle (tok, me, range, arc=angle) -->
[foreach(tok, allToks), if(bot_pointOnTriangle(tok, me, range, arc)): toks	= listAppend(toks, tok)]

[selectTokens(toks,0,",")]
[macro.return	= toks]

@@selectOnTriangle NEW (but not correct
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy=99 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!-- selectOnTriangle (me, range,arc) -->
<!-- selects all tokens inside of the shape -->

[me			= arg(0)]
[range		= arg(1)]
[arc		= arg(2)/2]

[angle	= bot_getTokenFacing(me,2)]

<!-- retrieve the gridcoords where the triangle corners end -->
<!-- get both angles in radians -->
[arc1		= (angle - arc)*bot_pi()/180]
[arc2		= (angle + arc)*bot_pi()/180]
<!-- get grid coords -->
[x2			= round(range*bot_cos(arc1),0)]
[y2			= round(range*bot_sin(arc1),0)]
[x3			= round(range*bot_cos(arc2),0)]
[y3			= round(range*bot_sin(arc2),0)]
[area		= bot_getTriangleCoords (0,0,x2,y2,x3,y3)]
[pause("x2","y2","x3","y3","arc1","arc2","area")]

[allToks	= getTokens(",", json.set("{}", "area", json.set("{}", "token", me, "offsets", area)  )  )]
[selectTokens(allToks, 0, ",")]
[macro.return	= allToks]

@@showCircle
@PROPS@ fontColor=purple ; autoExecute=true ; fontSize=1.00em ; sortBy=10 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!--	showCircle (me, range, arc=angle, drawToken) -->

<!-- this is a completely redundant functions as everything is done by bot_getCircleCoords, but for function name consistancy this is added. -->
<!-- returns coordinates of the circle and does NOT draw it when drawToken=="" ;  returns the ids of the copied tokens and DOES draw it, when drawToken !="" -->

[macro.return = bot_getCircleCoords(arg(0), arg(1), arg(2))]

@@showCone
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=1.00em ; sortBy=20 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!-- showCone (tok, range, arc=angle, drawToken) -->
<!-- returns an array with all coords of the cone-->
<!-- draws the cone on grid if option set true-->

[me			= arg(0)]
[range		= arg(1)]
[arc		= arg(2)/2]
[drawToken	= arg(3)]

[x1			= getTokenX(0, me)]
[y1			= getTokenY(0, me)]
[angle		= bot_getTokenFacing(me,2)]
[libCoords	= "lib:EventMacros"]

<!-- retrieve the gridcoords where the cone corners end. -->
<!-- get both angles in radians -->
[arc1		= (angle - arc)*bot_pi()/180]
[arc2		= (angle + arc)*bot_pi()/180]
<!-- get grid coords -->
[x2			= x1 + round(range*bot_cos(arc1),0)]
[y2			= y1 + round(range*bot_sin(arc1),0)]
[x3			= x1 + round(range*bot_cos(arc2),0)]
[y3			= y1 + round(range*bot_sin(arc2),0)]

[XCoords	= getLibProperty("coneXrange_"+range+"_"+angle+"_"+arc, libCoords)]

[if(  json.type(XCoords) != "ARRAY" ), CODE:{
	<!-- that cone does not yet exist, so create it -->
	[coords			= bot_getConeCoords(me,  x2,y2,  x3,y3)]
	[XCoords		= "[]"]
	[YCoords		= "[]"]
	
	[foreach(coord, coords), CODE:{
		<!-- create a set of x and y at the origin point for future use -->
		[XCoords	= json.append(XCoords, json.get(coord, "x") - x1)]
		[YCoords	= json.append(YCoords, json.get(coord, "y") - y1)]
	}]
	
	[setLibProperty("coneXrange_"+range+"_"+angle+"_"+arc, XCoords, libCoords)]
	[setLibProperty("coneYrange_"+range+"_"+angle+"_"+arc, YCoords, libCoords)]
};{
	<!-- that cone does exist, so get Y as well -->
	[YCoords		= getLibProperty("coneYrange_"+range+"_"+angle+"_"+arc, libCoords)]
}]

[h, if(drawToken != ""), CODE:{
	<!-- copy the blast tokens onto the map, return the ids of the copies -->
	[copies			= "[]"]
	[baseMap		= getLibProperty("baseMapName", "lib:EventMacros")]
	[copies			= ""]
	[updates		= json.set("{}", "layer", "BACKGROUND", "useDistance", 0, "facing", "[r:(1d4-1) * 90]")]
	[i				= 0]
	[copies	= copyToken(drawToken, listCount(XCoords), baseMap, json.set(updates, "x", "[r:x1 + json.get(XCoords,i)]", "y", "[r:y1 + json.get(YCoords,i)][h:i=i+1]")))]
	[broadcast(copies)]
	[macro.return	= copies]
};{
	<!-- return the coords -->
	[coords			= "[]"]
	[for(i, 0, json.length(XCoords)): coords = json.append(coords,  json.set("{}","x",x1+json.get(XCoords, i) ,"y", y1+json.get(YCoords, i) )  )]
	[macro.return	= coords]
}]

@@showLine
@PROPS@ fontColor=fuchsia ; autoExecute=true ; fontSize=1.00em ; sortBy=40 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!--	showLine (x1,y1, x2,y2, drawToken) 
		showLine (me, range, drawToken) 
-->
<!-- returns an array with all coords of the line-->
<!-- draws the line on grid (if option set true)-->

[switch(argCount()), CODE:
	case 3:{
		[me			= arg(0)]
		[range		= arg(1)]
		[drawToken	= arg(2)]

		[x1			= getTokenX(0, me)]
		[y1			= getTokenY(0, me)]

		[angle		= bot_getTokenFacing(me,2)]
		<!-- retrieve the gridcoords where the cone corners end. -->
		<!-- get angle in radians -->
		[arc		= angle*bot_pi()/180]
		<!-- get grid coords -->
		[x2			= x1 + round(range*bot_cos(arc),0)]
		[y2			= y1 + round(range*bot_sin(arc),0)]
	};
	case 5:{
		[x1			= arg(0)]
		[y1			= arg(1)]
		[x2			= arg(2)]
		[y2			= arg(3)]
		[drawToken	= arg(4)]
	};
	default:{[assert(0,"Error in showLine, wrong amount of arguments: "+argCount(),0)]}
]

[h:coords	= bot_getLineCoords(x1,y1,  x2,y2)]

[h, if(drawToken != ""), CODE:{
	<!-- copy the blast tokens onto the map, return the ids of the copies -->
	[copies			= "[]"]
	[h:baseMap		= getLibProperty("baseMapName", "lib:EventMacros")][h:copies	= ""]
	[updates		= json.set("{}", "layer", "BACKGROUND", "useDistance", 0, "facing", "[r:(1d4-1) * 90]")]
	[i				= 0]
	[copies			= copyToken(drawToken, json.length(coords), baseMap, json.set(updates, "x", "[r:json.get(json.get(coords,i),'x')]", "y", "[r:json.get(json.get(coords,i),'y')][h:i=i+1]") )]
	[macro.return	= copies]
};{
	<!-- return the coords -->
	[macro.return	= coords]
}]

@@showSquare
@PROPS@ fontColor=green ; autoExecute=true ; fontSize=1.00em ; sortBy=30 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!--	showSquare (me, range, drawToken) 
		OR
		showSquare (x1,y1, x2,y2, drawToken) 
	-->
<!-- returns an array with all coords of the square-->
<!-- draws the square on grid (if option set true)-->

[switch(argCount()), CODE:
	case 3:{
		[me		= arg(0)]
		[range	= arg(1)]
		[drawToken	= arg(2)]

		[xc		= getTokenX(0, me)]
		[yc		= getTokenY(0, me)]

		[x1		= xc - range]
		[y1		= yc - range]
		[x2		= xc + range]
		[y2		= yc + range]
	};
	case 5:{
		[x1		= arg(0)]
		[y1		= arg(1)]
		[x2		= arg(2)]
		[y2		= arg(3)]
		[drawToken	= arg(4)]
	};
	default:{[assert(0,"Error in showSquare, wrong amount of arguments: "+argCount(),0)]}
]

[h:coords	= bot_getSquareCoords(x1,y1,  x2,y2)]

[h, if(drawToken != ""), CODE:{
	<!-- copy the blast tokens onto the map, return the ids of the copies -->
	[copies			= "[]"]
	[h:baseMap		= getLibProperty("baseMapName", "lib:EventMacros")][h:copies	= ""]
	[updates		= json.set("{}", "layer", "BACKGROUND", "useDistance", 0, "facing", "[r:(1d4-1) * 90]")]
	[i				= 0]
	[copies			= copyToken(drawToken, json.length(coords), baseMap, json.set(updates, "x", "[r:json.get(json.get(coords,i),'x')]", "y", "[r:json.get(json.get(coords,i),'y')][h:i=i+1]") )]
	[macro.return	= copies]
};{
	<!-- return the coords -->
	[macro.return	= coords]
}]

@@showTriangle
@PROPS@ fontColor=maroon ; autoExecute=true ; fontSize=1.00em ; sortBy=50 ; color=darkgray ; playerEditable=false ; applyToSelected=false ; group=10. GeoFunctions ; tooltip= ; minWidth=90 ; 
<!--	showTriangle (x1,y1, x2,y2, x3,y3, drawToken) 
		OR
		showTriangle (me, range, arc=angle, drawToken) 
-->
<!-- returns coordinates of the triangle and draws it on grid if options set true -->

[switch(argCount()), CODE:
	case 4:{
		[me		= arg(0)]
		[range	= arg(1)]
		[arc	= arg(2)/2]
		[drawToken	= arg(3)]

		[x1		= getTokenX(0, me)]
		[y1		= getTokenY(0, me)]
		[angle		= bot_getTokenFacing(me,2)]

		<!-- retrieve the gridcoords where the cone corners end. -->
		<!-- get both angles in radians -->
		[arc1	= (angle - arc)*bot_pi()/180]
		[arc2	= (angle + arc)*bot_pi()/180]
		<!-- get grid coords -->
		[x2		= x1 + round(range*bot_cos(arc1),0)]
		[y2		= y1 + round(range*bot_sin(arc1),0)]

		[x3		= x1 + round(range*bot_cos(arc2),0)]
		[y3		= y1 + round(range*bot_sin(arc2),0)]
	};
	case 7:{
		[x1			= arg(0)]
		[y1			= arg(1)]
		[x2			= arg(2)]
		[y2			= arg(3)]
		[x3			= arg(4)]
		[y3			= arg(5)]	
		[drawToken		= arg(5)]
		};
	default:{[assert(0,"Error in bot_showTriangle, wrong amount of arguments: "+argCount(),0)]}
]

[h:coords	= json.union(
	bot_getTriangleCoords( x1,y1,  x2,y2,  x3,y3 ),
	bot_getLineCoords(x1,y1,  x2,y2) ), 
	bot_getLineCoords(x1,y1,  x3,y3) ),
	bot_getLineCoords(x3,y3,  x2,y2) )
]

[h, if(drawToken != ""), CODE:{
	<!-- copy the blast tokens onto the map, return the ids of the copies -->
	[copies			= "[]"]
	[h:baseMap		= getLibProperty("baseMapName", "lib:EventMacros")][h:copies	= ""]
	[updates		= json.set("{}", "layer", "BACKGROUND", "useDistance", 0, "facing", "[r:(1d4-1) * 90]")]
	[i				= 0]
	[copies			= copyToken(drawToken, json.length(coords), baseMap, json.set(updates, "x", "[r:json.get(json.get(coords,i),'x')]", "y", "[r:json.get(json.get(coords,i),'y')][h:i=i+1]") )]
	[macro.return	= copies]
};{
	<!-- return the coords -->
	[macro.return	= coords]
}]

@@getNeighbourXY
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=default ; playerEditable=false ; applyToSelected=false ; group=10. Geofunctions - support ; tooltip= ; minWidth=90 ; 
<!-- getNeighbourXY (coord) -->
<!-- returns an array with all neighbouring coords -->

[x		= json.get(arg(0), "x")]
[y		= json.get(arg(0), "y")]

[h:macro.return	= '[
	{"x":'+(x-1)+',"y":'+(y-1)+'},
	{"x":'+(x  )+',"y":'+(y-1)+'},
	{"x":'+(x+1)+',"y":'+(y-1)+'},
	
	{"x":'+(x-1)+',"y":'+(y  )+'},
	{"x":'+(x+1)+',"y":'+(y  )+'},
	
	{"x":'+(x-1)+',"y":'+(y+1)+'},
	{"x":'+(x  )+',"y":'+(y+1)+'},
	{"x":'+(x+1)+',"y":'+(y+1)+'}
]']

@@isClockWise
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy= ; color=default ; playerEditable=true ; applyToSelected=false ; group=10. Geofunctions - support ; tooltip= ; minWidth=90 ; 
<!-- isClockWise (xcentr,ycentr,x1,y1,x2,y2) -->
<!-- checks if p2 is clockwise from p1 -->
[macro.return	= if(-(arg(2) - arg(0))*(arg(5) - arg(1)) + (arg(3) - arg(1))*(arg(4) - arg(0)) > 0,0,1)]

@@isClockWise BCK
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=99 ; color=default ; playerEditable=true ; applyToSelected=false ; group=10. Geofunctions - support ; tooltip= ; minWidth=90 ; 
<!-- isClockWise (xcentr,ycentr,x1,y1,x2,y2) -->
<!-- checks if p2 is clockwise from p1 -->
[x1	= arg(2) - arg(0)]
[y1	= arg(3) - arg(1)]
[x2	= arg(4) - arg(0)]
[y2	= arg(5) - arg(1)]

[macro.return	= if(-x1*y2 + y1*x2 > 0,0,1)]

@@pointInCone BCK
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=99 ; color=default ; playerEditable=true ; applyToSelected=false ; group=10. Geofunctions - support ; tooltip= ; minWidth=90 ; 
<!-- pointInCone (me, x1,y1, x2,y2, xp,yp) -->
<!-- checks if a point (p) is between three points (centre, 1 and 2) on a SPHERE, does NOT include boundary -->

[me			= arg(0)]
[x1			= arg(1)]
[y1			= arg(2)]
[x2			= arg(3)]
[y2			= arg(4)]
[xp			= arg(5)]
[yp			= arg(6)]

[xc			= getTokenX(0,me)]
[yc			= getTokenY(0,me)]
[distance	= getDistanceToXY(xp,yp,0,me)]
[r			= getDistanceToXY(x1,y1,0,me)]

[CW			= bot_isClockWise	(xc,yc,  x1,y1,  xp,yp)]
[CCW		= !bot_isClockWise	(xc,yc,  x2,y2,  xp,yp)]
[IR			= if(distance <= r,1,0)]

<!-- always make sure that p2 is clockwise from p1 !! -->
[h:macro.return	= if(CW && CCW && IR, 1, 0)]

@@getValidTokens
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=11pt ; sortBy=26 ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Summon ; tooltip= ; minWidth=90 ; 
[H: '<!-- -------------------------------- getValidTokens(useCurrentMap) ------------------------------------ -->']
[H: '<!-- based on Orpheus WoD campaign macro -->']

[h,if(argCount() > 0): useCurrentMap	= arg(0); useCurrentMap	= 0]
[h,if(argCount() > 1): conditions		= arg(1); conditions	= "{}"]
[h,if(argCount() > 2): use_None			= arg(2); use_None		= 1]
[h,if(argCount() > 3): startsWithTxt	= lower(arg(3)); startsWithTxt	= ""]

[h:baseMapName		= getLibProperty("baseMapName", "lib:EventMacros")]
[h:oldMap			= getCurrentMapName()]
[h:assert(listContains(getAllMapNames(),baseMapName), "Uknown map: '"+baseMapName+"' Set the correct BASE map value in the settings macro of the Bag of Tricks macro panel",0)]
[h,if(use_None): noneImageId = getImage('image:none')]
[h, if(!useCurrentMap):setCurrentMap(baseMapName)]

[h:pcPropType		= getLibProperty("summonPcPropType","lib:EventMacros")]
[h:npcPropType		= getLibProperty("summonNpcPropType","lib:EventMacros")]
[h:propTypesList	= getLibProperty("summonPropTypesList","lib:EventMacros")]
[h:specialList		= getLibProperty("summonSpecialList","lib:EventMacros")]
[h:tokenList 		= listSort(getTokenNames(",",conditions),"N")]

[h,if(startsWithTxt != ""), CODE:{
	<!-- if startswith string is used, narrow the list to those only -->
	[newTokenList	= ""]
	[foreach(tok, tokenList): newTokenList = if(startsWith(lower(tok), startsWithTxt), listAppend(newTokenList, tok), newTokenList)]
	[tokenList		= newTokenList]
}; {}]

[h:'<!-- remove non existing tokens from specialList -->']
[h:tmpList = ""]
[h, foreach(item, specialList), CODE:{
	[if(findToken(item) != ""), CODE:{
		[if(getLayer(item) == 'TOKEN'): tmpList = listAppend(tmpList, item)]
	}; {}]
}]
[h: specialList 	= tmpList]

[h:pcList			= ""]
[h:npcList			= ""]
[h:charList			= ""]
[h:allList			= ""]
[h,foreach(propType, propTypesList): set(propType+"List","")]

[h:fancyPcList		= ""]
[h:fancyNpcList		= ""]
[h:fancyCharList	= ""]
[h:fancyAllList		= ""]
[h,foreach(propType, propTypesList): set("fancy"+propType+"List","")]
[h:fancySpecialList	= ""]
[h:specialNumber	=0]

[H,FOREACH(tok, tokenList), CODE:{
	[pc 			= if(getPropertyType(tok) == pcPropType && isPC(tok),1 ,0)]
	[npc 			= if(getPropertyType(tok) == npcPropType && isNPC(tok),1 ,0)]
	[foreach(propType, propTypesList):set(propType, if(getPropertyType(tok) == propType, 1, 0))]
	[special		= listContains(specialList,  tok)]

	[if(pc), CODE:{
		[pcList		= listAppend(pcList, tok)]
		[token(tok): fancyPcList = listAppend(fancyPcList, tok + getTokenImage(60))]
		[charList	= listAppend(charList, tok)]
		[token(tok): fancyCharList = listAppend(fancyCharList, tok + getTokenImage(60))]
	}; {}]
	[if(npc), CODE:{
		[npcList	= listAppend(npcList, tok)]
		[token(tok): fancyNpcList = listAppend(fancyNpcList, tok + getTokenImage(60))]
		[charList	= listAppend(charList, tok)]
		[token(tok): fancyCharList = listAppend(fancyCharList, tok + getTokenImage(60))]
	}; {}]
	[foreach(propType, propTypesList), CODE:{
		[tmpEval	= eval(propType)]		
		[if(tmpEval): set(propType+"List", listAppend(eval(propType+"List"), tok))]
		[if(tmpEval), token(tok): set("fancy"+propType+"List", listAppend(eval("fancy"+propType+"List"), tok + getTokenImage(60)))]
	}]
	[if(special), CODE:{
		[token(tok): fancySpecialList = listAppend(fancySpecialList, tok + getTokenImage(60))]
	}; {}]
	
	[allList		= listAppend(allList, tok)]
	[token(tok): fancyAllList = listAppend(fancyAllList, tok + getTokenImage(60))]

}]

[h,if(use_None), CODE:{
	[pcList		= if(pcList 	!= "", listAppend("none", pcList), "none")]
	[npcList	= if(npcList	!= "", listAppend("none", npcList), "none")]
	[charList	= if(charList	!= "", listAppend("none", charList), "none")]
	[allList	= if(allList 	!= "", listAppend("none", allList), "none")]

	[if(fancyPcList == ""):		fancyPcList		= "none" + noneImageId ; fancyPcList	= listAppend("none" + noneImageId, fancyPcList)]
	[if(fancyNpcList == ""):	fancyNpcList	= "none" + noneImageId ; fancyNpcList	= listAppend("none" + noneImageId, fancyNpcList)]
	[if(fancyCharList == ""):	fancyCharList	= "none" + noneImageId ; fancyCharList	= listAppend("none" + noneImageId, fancyCharList)]
	[if(fancyAllList == ""):	fancyAllList	= "none" + noneImageId ; fancyAllList	= listAppend("none" + noneImageId, fancyAllList)]

	[foreach(propType, propTypesList), CODE:{
		[set(propType+"List", listAppend("none", eval(propType+"List")))]
		[set("fancy"+propType+"List", if(eval("fancy"+propType+"List") == "", "none" + noneImageId , listAppend("none" + noneImageId, eval("fancy"+propType+"List"))))]
	}]

	[specialList	= listAppend("none", specialList)]
	[if(fancySpecialList == ""): fancySpecialList	= "none" + noneImageId ; fancySpecialList	= listAppend("none" + noneImageId, fancySpecialList)]
}; {
	[h,foreach(propType, propTypesList), CODE:{
		[set(propType+"List", eval(propType+"List"))]
		[set("fancy"+propType+"List", eval("fancy"+propType+"List")]
	}]
}]

[h, if(!useCurrentMap):setCurrentMap(oldMap)]

@@summonToken
@PROPS@ fontColor=blue ; autoExecute=true ; fontSize=11pt ; sortBy=25 ; color=lightgray ; playerEditable=false ; applyToSelected=false ; group=Summon ; tooltip= ; minWidth=90 ; 
[H: '<!-- summonToken -->']
[H: '<!-- based on Orpheus WoD campaign macro -->']
[h:me = getSelected()]
[h:assert(listCount(me) <= 1, "Make sure only one token is selected",0)]
[h, if(listCount(me) == 1), CODE:{
	[switchToken(me)]
	[h: X = getTokenX(0)]
	[h: Y = getTokenY(0)]
	[H: PrimePC	= getName() ]
}; {
	[h: X = 0]
	[h: Y = 0]
	[H: PrimePC	= ""]
}]

[h, if(argCount() > 0): useCurrentMap = arg(0); useCurrentMap = 0]
[h, if(argCount() > 1): conditions = arg(1); conditions = "{}"]

[H: '<!-- no new scope!! -->']
[h: bot_getValidTokens(useCurrentMap, conditions)]

[H: '<!-- User choice of what to use, at which level, on who -->']
[h:inputStr		= "junk|<html><b>Summon Token</b> - More token types can be added from the Settings macro</html>|-|LABEL|SPAN=TRUE"]
[h,if(listCount(fancyPCList)	> 1):	inputStr = listAppend(inputStr, "pcNumber | " 	+ fancyPCList	+ " | PC | LIST | ICON=TRUE  ICONSIZE=30", '@')		; pcNumber		= 0]
[h,if(listCount(fancyNPCList)	> 1):	inputStr = listAppend(inputStr, "npcNumber | " 	+ fancyNPCList	+ " | NPC | LIST | ICON=TRUE  ICONSIZE=30", '@')	; npcNumber		= 0]
[h,if(listCount(fancyCharList)	> 1):	inputStr = listAppend(inputStr, "charNumber | "	+ fancyCharList	+ " | (N)PC | LIST | ICON=TRUE  ICONSIZE=30", '@')	; charNumber	= 0]
[h,if(listCount(fancyAllList)	> 1):	inputStr = listAppend(inputStr, "allNumber | " 	+ fancyAllList	+ " | ALL | LIST | ICON=TRUE  ICONSIZE=30", '@')	; allNumber		= 0]

[h, foreach(propType, propTypesList), CODE:{
	[fancyList	= eval("fancy"+propType+"List")]
	[if(listCount(fancyList)	> 1):	inputStr = listAppend(inputStr, propType + "Number | " + fancyList + " | "+propType+" | LIST | ICON=TRUE  ICONSIZE=30", '@') ; set(propType + "Number", 0)]
}]
[h, if(listCount(fancySpecialList) > 1):inputStr 	= listAppend(inputStr, "specialNumber | " 	+ fancySpecialList	+ " | Special | LIST | ICON=TRUE  ICONSIZE=30", '@')]

[h:'<!-- ask for number -->']
[h:inputStr		= listAppend(inputStr,"junk|<html><b>Number of each selected token to summon:</b></html>|-|LABEL|SPAN=TRUE", '@')]
[h:inputStr 	= listAppend(inputStr, "bot_amount|1|give amount", '@')]
[h:inputStr 	= listAppend(inputStr, "bot_spread|0|Spread summoned tokens|CHECK", '@')]

[h:'<!-- ask for coords -->']
[h:inputStr		= listAppend(inputStr,"junk|<html><b>Summon Token(s) to:</b></html>|-|LABEL|SPAN=TRUE", '@')]
[h:inputStr		= listAppend(inputStr,"junk|<html>If you select a token before you run this macro then its<br>coords will be used here</html>|-|LABEL|SPAN=TRUE", '@')]
[h:inputStr 	= listAppend(inputStr, "X|"+X+"|X-coordinate to place token", '@')]
[h:inputStr 	= listAppend(inputStr, "Y|"+Y+"|Y-coordinate to place token", '@')]

[h:'<!-- show coords of selected token-->']
[h, if(PrimePC != ""):inputStr		= listAppend(inputStr,"junk|"+X+","+Y+"|<html><b>Location of "+PrimePC+"</b>|LABEL", '@')]

[h:'<!-- create the dialog string -->']
[h:inputStr 	= listFormat(inputStr, "input( %list )", " ' %item ' ", ",", "@")]

[h:'<!-- ask for input-->']
[h:abort(eval(inputStr))]

[h: updates = json.set("{}", "useDistance", 0)]
[h: updates = json.set(updates, "x", X+1)]
[h: updates = json.set(updates, "y", Y)]

[h:summonedList = json.append("",me)]

[r,if(pcNumber):		summonedList = json.merge(summonedList, copyToken(listGet(pcList, pcNumber), bot_amount, baseMapName, updates))]
[r,if(npcNumber):		summonedList = json.merge(summonedList, copyToken(listGet(npcList, npcNumber), bot_amount, baseMapName, updates))]
[r,if(charNumber):		summonedList = json.merge(summonedList, copyToken(listGet(charList, charNumber), bot_amount, baseMapName, updates))]
[r,if(allNumber):		summonedList = json.merge(summonedList, copyToken(listGet(allList, allNumber), bot_amount, baseMapName, updates))]
[r, foreach(propType, propTypesList, ""), CODE:{
	[r,if(eval(propType+"Number")):	summonedList = json.merge(summonedList, copyToken(listGet(eval(propType+"List"), eval(propType+"Number")), bot_amount, baseMapName, updates))]
}]

[r,if(specialNumber):	summonedList = json.merge(summonedList, copyToken(listGet(specialList, specialNumber), bot_amount, baseMapName, updates))]

[h, if(bot_spread), CODE:{
	[selectTokens(summonedList, 1, "json")]
	[msg = "This message is needed to spread the tokens"]
	[pause("msg")]
	[bot_formationSquare()]
}; {}]

@@mapTeleport
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=2 ; color=default ; playerEditable=false ; applyToSelected=false ; group=4. Teleport & Roof ; tooltip= ; minWidth=90 ; 
[h:'<!-- ------------------------------------------- mapTeleport ------------------------------------------------- -->']

<!-- define the following vars: tok, padName, doAbort, eventMacroPreInterTeleport, eventMacroPostInterTeleport,doScaleTeleport,doSwitchInterMap -->
<!-- doSwitchInterMap:
	0: swap to other map
	1: do not swap to other map
	2: do not swap to other map AND retrieve xy coords from current pad
 -->
[h:varsFromStrProp(arg(0))]

[newMap = getProperty("w42.bot.pairedMap", padName)]
[oldMap = getCurrentMapName()]

[startCentreX 	= getTokenX(0, padName)]
[startCentreY 	= getTokenY(0, padName)]
[if(startsWith(padName, "InterJump")): padName = replace(padName, "Jump", "Drop")]

[if(doSwitchInterMap ==2), CODE:{
	<!-- no map swapping and the coords of the OTHER pad are stored on this pad. So no map change required -->
	<!-- note that gridsizes can differ over maps so you need to keep that in mind!! -->
	[endCentreX 	= getProperty("w42.bot.otherPadX", padName)]
	[endCentreY 	= getProperty("w42.bot.otherPadY", padName)]
	[endGridSize	= getProperty("w42.bot.otherPadG", padName)]
	[w2				= getProperty("w42.bot.otherPadW", padName)]
	[h2				= getProperty("w42.bot.otherPadH", padName)]
};{
	[setCurrentMap(newMap)]
	[endCentreX 	= getTokenX(0, padName)]
	[endCentreY 	= getTokenY(0, padName)]
	[w2				= bot_ppc2GridCoord(getTokenWidth(padName))]
	[h2				= bot_ppc2GridCoord(getTokenHeight(padName))]
	[setCurrentMap(oldMap)]
}]

[CurrentX	= getTokenX(0, tok)]
[CurrentY	= getTokenY(0, tok)]
[CurrentGS	= bot_getGridSize()]

[h,if(doScaleTeleport), CODE:{
	<!-- round2grid returns a coordinate rounded to multiple of grid size  -->v
	[w1		= bot_ppc2GridCoord(getTokenWidth(padName))]
	[h1		= bot_ppc2GridCoord(getTokenHeight(padName))]

	[wc		= w2/w1]
	[hc		= h2/h1]
	[if(CurrentX == startCentreX + w1 - CurrentGS): 
		NewX	= endCentreX + w2 - endGridSize 
	; 
		NewX	= round(wc*(CurrentX - startCentreX) + endCentreX)
	]
	[if(CurrentY == startCentreY + h1 - CurrentGS): 
		NewY	= endCentreY + h2 - endGridSize 
	; 
		NewY	= round(hc*(CurrentY - startCentreY) + endCentreY)
	]
};{
	[NewX	= CurrentX - startCentreX + endCentreX]
	[NewY	= CurrentY - startCentreY + endCentreY]
}]

<!-- moveTokenToMap only works with gridcell coords NOT with distance per cell, so convert x/y to grid -->
['NewX	= round(NewX/endGridSize)']
['NewY	= round(NewY/endGridSize)']
['pause("w1","h1","w2","h2","wc","hc","NewX","NewY","CurrentX","startCentreX","endCentreX","CurrentY","startCentreY","endCentreY")']

[Token(tok): w42.bot.init = getInitiative()]

<!-- check if token is standing on a roof, if so, deactivate it. -- ROOFSWAP (inHouse, me, roofName, showHalo) -->
[h, if(hasProperty("w42.bot.onRoof", tok)): bot_roofSwap(0, tok, getProperty("w42.bot.onRoof", tok), if(bot_inStr(getProperty("w42.bot.onRoof", tok), "roof"),1,0))]

<!-- execute a linked event from the settings BEFORE teleport-->
[h, if(eventMacroPreInterTeleport != "<none>"), CODE:{
	[macro(eventMacroPreInterTeleport+"@Lib:EventMacros"): json.append("", strPropFromVars("tok, padName, CurrentX, CurrentY, NewX, NewY, oldMap, newMap", "UNSUFFIXED"))]
}; {}]

[moveTokenToMap(tok, newMap, NewX, NewY, 100)]

[if(doSwitchInterMap != 2), CODE:{
	[setCurrentMap(newMap)]
	[if(isNumber(w42.bot.init)), CODE:{
		[Token(tok): addToInitiative()]
		[Token(tok): setInitiative(w42.bot.init)]
	}; {}]
	[goto(currentToken())]
	[selectTokens(tok)]
	[exposeFOW()]
};{}]

<!-- execute a linked event from the settings AFTER teleport-->
[h, if(eventMacroPostInterTeleport != "<none>"), CODE:{
	[macro(eventMacroPostInterTeleport+"@Lib:EventMacros"): json.append("", strPropFromVars("tok, padName, CurrentX, CurrentY, NewX, NewY, oldMap, newMap", "UNSUFFIXED"))]
}; {}]

[if(doSwitchInterMap == 0):abort(doAbort)]
[if(doSwitchInterMap != 2):setCurrentMap(oldMap)]

@@roofSwap
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=4 ; color=default ; playerEditable=false ; applyToSelected=false ; group=4. Teleport & Roof ; tooltip= ; minWidth=90 ; 
[h:'<!-- --------------------- ROOFSWAP (inHouse, me, roofName, showHalo, roofHaloColor) ------------------------------------ -->']

[h:inHouse		= arg(0)]
[h:me			= arg(1)]
[h:roofName		= arg(2)]
[h:showHalo		= arg(3)]
[h,if(argCount()>4): roofHaloColor	= arg(4)]

[h:switchToken(roofName)]
[h:useAltImage	= getLibProperty("useAltImage","lib:EventMacros")]

[H, if(inHouse), code: {
	[assert(if(listContains(json.toList(json.get(getInfo("campaign"),"tables")), "tbl_Image"),1,0), "You will need to install the Bag of Tricks Image Tables first before you can use this option. See the how to install on the the forum",0)]
	[nameList	= getProperty("w42.bot.tokens.onHouse")]
	[if(useAltImage && getTokenHandout() != ""): noRoofImg	= getTokenHandout(); noRoofImg	= tblImage("tbl_Image",1)]
	[roofImg	= getTokenImage()]

	[if(nameList == ""), CODE:{
		[setTokenImage(noRoofImg)]
		[if(showHalo):setHalo(roofHaloColor)]
		[setProperty("w42.bot.layer.original", getLayer())]
		[setLayer("BACKGROUND")]
	}]
	
	[if(roofImg != noRoofImg):setProperty("w42.bot.image.original", roofImg)]
	[if(!listContains(nameList, me)): nameList	= listAppend(nameList, me)]
	[setProperty("w42.bot.tokens.onHouse",nameList)]
	<!-- also store the name of the roof on the token, so in case of teleport it can be deactivated -->
	[setProperty("w42.bot.onRoof",roofName, me)]
}; {
	[nameList	= getProperty("w42.bot.tokens.onHouse")]
	[if(listContains(nameList, me)): nameList	= listDelete(nameList, listFind(nameList,me))]
	[setProperty("w42.bot.tokens.onHouse",nameList)]
	<!-- remove property from token -->
	[resetProperty("w42.bot.onRoof", me)]

	[if(nameList == ""), CODE:{
		[setTokenImage(getProperty("w42.bot.image.original"))]
		[if(showHalo):setHalo("None")]
		[setLayer(getProperty("w42.bot.layer.original"))]
	};{}]
}]

[if(getProperty("w42.bot.vblBgScale") != ""): bot_setVBLRoof(roofName, inHouse)]

[h:'pause("nameList", "me", "roofName")']

@@setRoof
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=3 ; color=darkgray ; playerEditable=false ; applyToSelected=true ; group=4. Teleport & Roof ; tooltip= ; minWidth=90 ; 
[h: '<!-- ---------------------------------------------- setRoof -------------------------------------------- --> ']

[h:roof				= getName(getSelected())]
[h:assert(listCount(roof)==1,"Make sure (only) one token is selected",0)]
[h:assert(startsWith(roof, "Roof "),"Make sure the 'roof' is called 'Roof <number>'",0)]
[h:switchToken(roof)]
[h:tmpDoors			= getProperty("w42.bot.Doors", roof)]

<!-- check if roof has been previously set with VBL -->
[h: oldAddVBL = if(hasProperty("w42.bot.vblSetup"), 1, 0)]

<!-- mt version VBL support check -->
[h:vblSupport		= getLibProperty('vblSupport','lib:EventMacros')]

<!-- create a list of doors on the object layer that have been set for animation-->
[h:tokens			= getTokenNames(",",'{"layer":"OBJECT"}')]
[h:Doors			= ""]
[h, foreach(tok, tokens),CODE:{
	[if(startsWith(tok, "Door ") && getProperty("w42.bot.doorData", tok)): Doors	= listAppend(Doors, tok)]
}]
[h:Doors			= listSort(Doors, "N+")]

<!-- Create list of door identifiers -->
[h:iDoors			= ""]
[h:desciptionsDoors	= ""]
[h,foreach(door, Doors), CODE:{
		[id					= substring(door, 5)]
		[iDoors				= listAppend(iDoors, id)]
		[h,if(hasProperty("description", door)): description	= getProperty("description", door); description	= ""]
		[desciptionsDoors	= listAppend(desciptionsDoors, strformat("(%{id}) %{description}"))]
}]

<!-- turn this list into an input string -->
[H: 				inputStr 	= "[]"]
[h,if(vblSupport):	inputStr	= json.append(inputStr, "junk|<html><b>Apply VBL</b> - this will store the current VBL of the building<br>and replace it by a Cross VBL. As soon as a token moves onto the roof<br>The cross VBL will be swapped by the stored building VBL. </html>|-|LABEL|SPAN=TRUE")]
[h,if(vblSupport):	inputStr	= json.append(inputStr, "addVBL|"+oldAddVBL+"|Apply VBL Cross|CHECK") ; addVBL = 0]
[h, if(Doors != ""):inputStr	= json.append(inputStr, "junk|<html><b>Link doors</b> - set the entry/exit doors for this roof. This will<br>prevent a token from moving onto the roof by NOT using the door.<br>A token can only enter the building by first moving over one of the<br>selected door tokens.</html>|-|LABEL|SPAN=TRUE")]
[h,foreach(door, Doors), CODE:{
		[			newStr		= "door" + roll.count + "|"+listContains(tmpDoors,door)+"|" + listGet(desciptionsDoors, roll.count) + "|CHECK"]
		[			inputStr	= json.append(inputStr, newStr)]
}]

<!-- put local variables in input form -->
[H: inputStr = json.evaluate(inputStr)]
 
<!-- get user input -->
[H: abort(input(json.toList(inputStr,"##")))]

<!-- process results, that add the chosen doors -->
[h:tmpDoors		= ""]
[h,foreach(door, Doors), CODE:{
	[if(eval("door" + roll.count)):tmpDoors	= listAppend(tmpDoors, door)]
}]
[h:setProperty("w42.bot.Doors", tmpDoors, roof)]

<!-- add X VBL to roof and also store any BG VBL -->
[h, if(addVBL && oldAddVBL != addVBL), CODE:{
	[vblSetup	= strformat(
		"applyVBL=1; VBLType=0; scaleX=100; scaleY=100; offsetX=0; offsetY=0; thickness=1; fill=0; scale=1; close=0; sides=6; centreOffset=0; resetFoW=1; rxOffset=0; ryOffset=0;"
	)]

	<!-- get the new VBL settings and apply the new VBL cross to its current position -->
	[setProperty("w42.bot.vblSetup", vblSetup, roof)]
	[bot_createVBL(roof)]
	<!-- createVBL will restore the bgVBL and apply the fgVBL in this case we want the fgVBL only -->
	[bot_setVBLRoof(roof, 0)]
}]

<!-- REMOVE X VBL from  roof and also restore any BG VBL -->
[h, if(!addVBL && oldAddVBL != addVBL), CODE:{
	<!-- remove the cross and set the old VBL -->
	[bot_setVBLRoof(roof, 1)]
	<!-- remove all VBL data  from the roof -->
	[bot_removeVBL(roof)]
}]

@@setVBLRoof
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=99 ; color=default ; playerEditable=false ; applyToSelected=true ; group=4. Teleport & Roof ; tooltip= ; minWidth=90 ; 
[h:'<!-- ----------------------------------------- setVBLRoof (id, on/off) -------------------------------------------- -->']
[debug = 0]

[me				= arg(0)]
[tokenOnRoof	= arg(1)]

[if(tokenOnRoof), CODE:{
	<!-- a token moves onto the roof. So remove the cross and restore the building VBL -->
	<!-- erase all vbl on roof and restore the VBL of the building beneath (erase is done int he drawbgvbl function) -->
	[bot_drawBgVBL(me)]	
};{
	<!-- a token moves OFF the roof. So remove the bg VBL and restore the cross -->
	<!-- erase all vbl on roof and restore the VBL of the building beneath -->
	[rectVBL	= getProperty("w42.bot.rectVBL")]
	[eraseVBL(rectVBL)]

	<!-- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), getMacroName(), getMacroLocation()) -->
	[h,if(debug == 1), CODE:{
		[bot_debugInfo("me, tokenOnRoof, rectVBL",0,1,0, getMacroName(), getMacroLocation())]
	};{}]

	<!-- 0 parameter prevents restoring bgVBL -->
	[bot_drawFgVBL(me, 0)]
}]

[selectTokens(getTokens(",", '{ pc:1 }'),1,",")]
[exposeFOW()]
[deselectTokens()]

@@teleport
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=1 ; color=default ; playerEditable=false ; applyToSelected=false ; group=4. Teleport & Roof ; tooltip= ; minWidth=90 ; 
[h:'<!--teleport(token,startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport)-->']

<!-- define the following vars: tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport -->
[h:varsFromStrProp(arg(0))]

[h, Token(tok):CurrentX 	= getTokenX(1)]
[h, Token(tok):CurrentY 	= getTokenY(1)]

[h,if(doScaleTeleport), CODE:{
	[gs		= bot_getGridSize()]
	[w1		= bot_round2Grid(getTokenWidth(padName))]
	[h1		= bot_round2Grid(getTokenHeight(padName))]
	[w2		= bot_round2Grid(getTokenWidth(teleportEndName))]
	[h2		= bot_round2Grid(getTokenHeight(teleportEndName))]

	[wc		= w2/w1]
	[hc		= h2/h1]
	[if(bot_round2Grid(CurrentX) == bot_round2Grid(startCentreX) + w1 - gs): NewX	= endCentreX + w2 - gs ; NewX = round(wc*(CurrentX - startCentreX) + endCentreX)]
	[if(bot_round2Grid(CurrentY) == bot_round2Grid(startCentreY) + h1 - gs): NewY	= endCentreY + h2 - gs ; NewY = round(hc*(CurrentY - startCentreY) + endCentreY)]
};{
	[NewX	= CurrentX + endCentreX - startCentreX]
	[NewY	= CurrentY + endCentreY - startCentreY]
}]

[h,if(!isSnapToGrid(tok)),CODE:{
	<!-- if pads are not snapped and the token is, you get strange offsets after the teleport, this fixes that -->
<!-- needs propper testing at gridsize 28 and other circumstances @@@@ -->
	[gs		= bot_getGridSize()]
	[NewX	= round(NewX/gs)*gs]
	[NewY	= round(NewY/gs)*gs]
};{}]

	['pause("w1","h1","w2","h2","wc","hc","NewX","NewY","CurrentX","startCentreX","endCentreX","CurrentY","startCentreY","endCentreY")']

<!-- execute a linked event from the settings BEFORE teleport-->
[h, if(eventPreMacroTeleport != "<none>"), CODE:{
	[macro(eventPreMacroTeleport+"@Lib:EventMacros"): json.append("", strPropFromVars("tok, padName, teleportEndName, CurrentX, CurrentY, NewX, NewY", "UNSUFFIXED"))]
}; {}]

<!-- check if token is standing on a roof, if so, deactivate it. -- ROOFSWAP (inHouse, me, roofName, showHalo) -->
[h, if(hasProperty("w42.bot.onRoof", tok)): 
	bot_roofSwap(0, tok, getProperty("w42.bot.onRoof", tok), if(bot_inStr(getProperty("w42.bot.onRoof", tok), "roof"),1,0))
]

[h, Token(tok):moveToken(NewX, Newy , 1 )]
[h:selectTokens(tok)]
[h:exposeFOW()]

<!-- execute a linked event from the settings AFTER teleport-->
[h, if(eventPostMacroTeleport != "<none>"), CODE:{
	[macro(eventPostMacroTeleport+"@Lib:EventMacros"): json.append("", strPropFromVars("tok, padName, teleportEndName, CurrentX, CurrentY, NewX, NewY", "UNSUFFIXED"))]
}; {}]

@@mod
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=6 ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Math ; tooltip= ; minWidth=39 ; 
[H: macro.return = arg(0) - arg(1) * floor(arg(0) / arg(1))]

@@odd
@PROPS@ fontColor=black ; autoExecute=true ; fontSize=1.00em ; sortBy=7 ; color=teal ; playerEditable=false ; applyToSelected=false ; group=Math ; tooltip= ; minWidth=39 ; 
[h:'<!------------------------------------- ODD ------------------------------------------------>']
[r:if(band(arg(0),1) == 0, 0, 1)]
